<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>rglWebGL</title>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      cel.style.position = "absolute";
      var pad = unpackPadding(sizing.padding);
      cel.style.top = pad.top + "px";
      cel.style.right = pad.right + "px";
      cel.style.bottom = pad.bottom + "px";
      cel.style.left = pad.left + "px";
      el.style.width = "100%";
      el.style.height = "100%";

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var rect = el.getBoundingClientRect();
            var result = bindingDef.initialize(el, rect.width, rect.height);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        var getSize = function(el) {
          if (sizeObj) {
            return {w: sizeObj.getWidth(), h: sizeObj.getHeight()}
          } else {
            var rect = el.getBoundingClientRect();
            return {w: rect.width, h: rect.height}
          }
        };

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          var size = getSize(el);
          initResult = binding.initialize(el, size.w, size.h);
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = getSize(el);
          var resizeHandler = function(e) {
            var size = getSize(el);
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();
</script>
<script>/* el is the div, holding the rgl object as el.rglinstance,
     which holds x as el.rglinstance.scene
   x is the JSON encoded rglwidget.
*/


HTMLWidgets.widget({

  name: 'rglWebGL',

  type: 'output',

  factory: function(el, width, height) {
    el.width = width;
    el.height = height;
    var rgl = new rglwidgetClass(),
        onchangeselection = function(e) {
          for (var i = 0; i < rgl.scene.crosstalk.sel_handle.length; i++)
            rgl.clearBrush(except = e.rglSubsceneId);
          rgl.selection(e, false);
        },
        onchangefilter = function(e) {
          rgl.selection(e, true);
        };
    
    return { 
      renderValue: function(x) {
        var i, pel, player, groups,
            inShiny = (typeof Shiny !== "undefined");
      
        x.crosstalk.group = groups = [].concat(x.crosstalk.group);
        x.crosstalk.id = [].concat(x.crosstalk.id);
        x.crosstalk.key = [].concat(x.crosstalk.key);
        x.crosstalk.sel_handle = new Array(groups.length);
        x.crosstalk.fil_handle = new Array(groups.length);
        x.crosstalk.selection = [];
        for (i = 0; i < groups.length; i++) {
          x.crosstalk.sel_handle[i] = new crosstalk.SelectionHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.sel_handle[i].on("change", onchangeselection);
          x.crosstalk.fil_handle[i] = new crosstalk.FilterHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.fil_handle[i].on("change", onchangefilter);
        }
        if (inShiny) {
          // Shiny calls this multiple times, so we need extra cleanup
          // between
          rgl.sphere = undefined;
        }
        rgl.initialize(el, x);
        rgl.initGL();
  
  /* We might have been called after (some of) the players were rendered.
     We need to make sure we respond to their initial values. */

        if (typeof x.players !== "undefined") {
          var players = [].concat(x.players);
          for (i = 0; i < players.length; i++) {
            pel = document.getElementById(players[i]);
            if (pel) {
              player = pel.rglPlayer;
              if (player && (!player.initialized || inShiny)) {
                rgl.Player(pel, player);
                player.initialized = true;
              }
            }
          }
        }
        rgl.drag = 0;
        rgl.drawScene();
      },

      resize: function(width, height) {
        el.width = width;
        el.height = height;
        el.rglinstance.resize(el);
        el.rglinstance.drawScene();
      }
    };
  }
});
</script>
<style type="text/css">.rglPlayer {
width: auto;
height: auto;
}
.rglPlayer .rgl-button {
width: auto;
display: inline-block;
font-size: 75%;
}
.rglPlayer .rgl-slider {
display: inline-block;
width: 30%;
}
.rglPlayer .rgl-label {
display: inline;
padding-left: 6px;
padding-right: 6px;
}
</style>
<script>//// To generate the help pages for this library, use

// jsdoc --template /usr/local/lib/node_modules/foodoc/template *.src.js -R README.md -c JSDoc.json

// To test, set environment variable RGL_DEBUGGING=true
// before building.

/* globals rglwidgetClass: true */

/**
 * The class of an rgl widget
 * @class
*/
rglwidgetClass = function() {
    this.canvas = null;
    this.userMatrix = new CanvasMatrix4();
    this.types = [];
    this.prMatrix = new CanvasMatrix4();
    this.mvMatrix = new CanvasMatrix4();
    this.vp = null;
    this.prmvMatrix = null;
    this.origs = null;
    this.gl = null;
    this.scene = null;
    this.select = {state: "inactive", subscene: null, region: {p1: {x:0, y:0}, p2: {x:0, y:0}}};
    this.drawing = false;
};

    rglwidgetClass.f_is_lit = 1;
    rglwidgetClass.f_is_smooth = 2;
    rglwidgetClass.f_has_texture = 4;
    rglwidgetClass.f_depth_sort = 8;
    rglwidgetClass.f_fixed_quads = 16;
    rglwidgetClass.f_is_transparent = 32;
    rglwidgetClass.f_is_lines = 64;
    rglwidgetClass.f_sprites_3d = 128;
    rglwidgetClass.f_is_subscene = 256;
    rglwidgetClass.f_is_clipplanes = 512;
    rglwidgetClass.f_fixed_size = 1024;
    rglwidgetClass.f_is_points = 2048;
    rglwidgetClass.f_is_twosided = 4096;
    rglwidgetClass.f_fat_lines = 8192;
    rglwidgetClass.f_is_brush = 16384;
    rglwidgetClass.f_has_fog = 32768;
    rglwidgetClass.f_rotating = 65536;
    
    rglwidgetClass.prototype.fogNone = 0;
    rglwidgetClass.prototype.fogLinear = 1;
    rglwidgetClass.prototype.fogExp = 2;
    rglwidgetClass.prototype.fogExp2 = 3;

    /**
     * Methods related to obsolete approaches.
     * @name ___OBSOLETE_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start the writeWebGL scene. This is only used by writeWebGL; rglwidget has
       no debug element.
     */
    rglwidgetClass.prototype.start = function() {
      if (typeof this.prefix !== "undefined") {
        this.debugelement = document.getElementById(this.prefix + "debug");
        this.debug("");
      }
      this.drag = 0;
      this.drawScene();
    };
</script>
<script>    /**
     * Utility methods
     * @name ___UTILITY_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Multiply matrix by vector
     * @returns {number[]}
     * @param M {number[][]} Left operand
     * @param v {number[]} Right operand
     */
    rglwidgetClass.multMV = function(M, v) {
        return [ M.m11 * v[0] + M.m12 * v[1] + M.m13 * v[2] + M.m14 * v[3],
                 M.m21 * v[0] + M.m22 * v[1] + M.m23 * v[2] + M.m24 * v[3],
                 M.m31 * v[0] + M.m32 * v[1] + M.m33 * v[2] + M.m34 * v[3],
                 M.m41 * v[0] + M.m42 * v[1] + M.m43 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Multiply row vector by Matrix
     * @returns {number[]}
     * @param v {number[]} left operand
     * @param M {number[][]} right operand
     */
    rglwidgetClass.multVM = function(v, M) {
        return [ M.m11 * v[0] + M.m21 * v[1] + M.m31 * v[2] + M.m41 * v[3],
                 M.m12 * v[0] + M.m22 * v[1] + M.m32 * v[2] + M.m42 * v[3],
                 M.m13 * v[0] + M.m23 * v[1] + M.m33 * v[2] + M.m43 * v[3],
                 M.m14 * v[0] + M.m24 * v[1] + M.m34 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Euclidean length of a vector
     * @returns {number}
     * @param v {number[]}
     */
    rglwidgetClass.vlen = function(v) {
      return Math.sqrt(rglwidgetClass.dotprod(v, v));
    };

    /**
     * Dot product of two vectors
     * @instance rglwidgetClass
     * @returns {number}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.dotprod = function(a, b) {
      return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    };

    /**
     * Cross product of two vectors
     * @returns {number[]}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.xprod = function(a, b) {
      return [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]];
    };

    /**
     * Bind vectors or matrices by columns
     * @returns {number[][]}
     * @param a {number[][]}
     * @param b {number[]|number[][]}
     */
    rglwidgetClass.cbind = function(a, b) {
      if (b.length < a.length)
        b = rglwidgetClass.repeatToLen(b, a.length);
      else if (a.length < b.length)
        a = rglwidgetClass.repeatToLen(a, b.length);
      return a.map(function(currentValue, index) {
            return [].concat(currentValue).concat(b[index]);
      });
    };

    /**
     * Swap elements
     * @returns {any[]}
     * @param a {any[]}
     * @param i {number} Element to swap
     * @param j {number} Other element to swap
     */
    rglwidgetClass.swap = function(a, i, j) {
      var temp = a[i];
      a[i] = a[j];
      a[j] = temp;
    };

    /**
     * Flatten a matrix into a vector
     * @returns {any[]}
     * @param a {any[][]}
     */
    rglwidgetClass.flatten = function(arr, result) {
      var value;
      if (typeof result === "undefined") result = [];
      for (var i = 0, length = arr.length; i < length; i++) {
        value = arr[i];
        if (Array.isArray(value)) {
          rglwidgetClass.flatten(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    };

    /**
     * set element of 1d or 2d array as if it was flattened.
     * Column major, zero based!
     * @returns {any[]|any[][]}
     * @param {any[]|any[][]} a - array
     * @param {number} i - element
     * @param {any} value
     */
    rglwidgetClass.prototype.setElement = function(a, i, value) {
      if (Array.isArray(a[0])) {
        var dim = a.length,
            col = Math.floor(i/dim),
            row = i % dim;
        a[row][col] = value;
      } else {
        a[i] = value;
      }
    };

    /**
     * Transpose an array
     * @returns {any[][]}
     * @param {any[][]} a
     */
    rglwidgetClass.prototype.transpose = function(a) {
      var newArray = [],
          n = a.length,
          m = a[0].length,
          i;
      for(i = 0; i < m; i++){
        newArray.push([]);
      }

      for(i = 0; i < n; i++){
        for(var j = 0; j < m; j++){
          newArray[j].push(a[i][j]);
        }
      }
      return newArray;
    };

    /**
     * Calculate sum of squares of a numeric vector
     * @returns {number}
     * @param {number[]} x
     */
    rglwidgetClass.prototype.sumsq = function(x) {
      var result = 0, i;
      for (i=0; i < x.length; i++)
        result += x[i]*x[i];
      return result;
    };

    /**
     * Convert a matrix to a CanvasMatrix4
     * @returns {CanvasMatrix4}
     * @param {number[][]|number[]} mat
     */
    rglwidgetClass.prototype.toCanvasMatrix4 = function(mat) {
      if (mat instanceof CanvasMatrix4)
        return mat;
      var result = new CanvasMatrix4();
      mat = rglwidgetClass.flatten(this.transpose(mat));
      result.load(mat);
      return result;
    };

    /**
     * Convert an R-style numeric colour string to an rgb vector
     * @returns {number[]}
     * @param {string} s
     */
    /* jshint bitwise:false */ 
    rglwidgetClass.prototype.stringToRgb = function(s) {
      s = s.replace("#", "");
      var bigint = parseInt(s, 16);
      return [((bigint >> 16) & 255)/255,
              ((bigint >> 8) & 255)/255,
               (bigint & 255)/255];
    };
    /* jshint bitwise:true */
    /**
     * Which list does a particular id come from?
     * @returns { string }
     * @param {number} id The id to look up.
     */
    rglwidgetClass.prototype.whichList = function(id) {
      var obj = this.getObj(id),
          flags = obj.flags;
        if (obj.type === "light")
          return "lights";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_subscene))
            return "subscenes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_clipplanes))
            return "clipplanes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent))
            return "transparent";
        return "opaque";
    };
    
    /**
     * Take a component-by-component product of two 3 vectors
     * @returns {number[]}
     * @param {number[]} x
     * @param {number[]} y
     */
    rglwidgetClass.prototype.componentProduct = function(x, y) {
      if (typeof y === "undefined") {
        this.alertOnce("Bad arg to componentProduct");
      }
      var result = new Float32Array(3), i;
      for (i = 0; i<3; i++)
        result[i] = x[i]*y[i];
      return result;
    };

    /**
     * Get next higher power of two
     * @returns { number }
     * @param { number } value - input value
     */
    rglwidgetClass.prototype.getPowerOfTwo = function(value) {
      var pow = 1;
      while(pow<value) {
        pow *= 2;
      }
      return pow;
    };

    /**
     * Unique entries
     * @returns { any[] }
     * @param { any[] } arr - An array
     */
    rglwidgetClass.prototype.unique = function(arr) {
      arr = [].concat(arr);
      return arr.filter(function(value, index, self) {
        return self.indexOf(value) === index;
      });
    };

    /**
     * Shallow compare of arrays
     * @returns { boolean }
     * @param { any[] } a - An array
     * @param { any[] } b - Another array
     */
    rglwidgetClass.prototype.equalArrays = function(a, b) {
      return a === b || (a && b &&
                      a.length === b.length &&
                      a.every(function(v, i) {return v === b[i];}));
    };
    
    /**
     * Repeat an array to a desired length
     * @returns {any[]}
     * @param {any | any[]} arr The input array
     * @param {number} len The desired output length
     */
    rglwidgetClass.repeatToLen = function(arr, len) {
      arr = [].concat(arr);
      if (!arr.length) 
        throw new RangeError("array is length 0");
      while (arr.length < len/2)
        arr = arr.concat(arr);
      return arr.concat(arr.slice(0, len - arr.length));
    };

    /**
     * Give a single alert message, not to be repeated.
     * @param {string} msg  The message to give.
     */
    rglwidgetClass.prototype.alertOnce = function(msg) {
      // debugger;
      if (typeof this.alerted !== "undefined")
        return;
      this.alerted = true;
      alert(msg);
    };

    /**
     * Get an object by id number.
     * @returns { Object }
     * @param {number} id
     */
    rglwidgetClass.prototype.getObj = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("getObj id is "+typeof id);
      }
      return this.scene.objects[id];
    };

    /**
     * Get ids of a particular type from a subscene or the whole scene
     * @returns { number[] }
     * @param {string} type What type of object?
     * @param {number} subscene  Which subscene?  If not given, find in the whole scene
     */
    rglwidgetClass.prototype.getIdsByType = function(type, subscene) {
      var
        result = [], i, self = this, ids;
      if (typeof subscene === "undefined") {
        Object.keys(this.scene.objects).forEach(
          function(key) {
            key = parseInt(key, 10);
            if (self.getObj(key).type === type)
              result.push(key);
          });
      } else {
        ids = this.getObj(subscene).objects;
        for (i=0; i < ids.length; i++) {
          if (this.getObj(ids[i]).type === type) {
            result.push(ids[i]);
          }
        }
      }
      return result;
    };

    /**
     * Get a particular material property for an obj
     * @returns { any }
     * @param {object} obj  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterial = function(obj, property) {
      var mat;
      if (typeof obj.material === "undefined")
        console.error("material undefined");
      mat = obj.material[property];
      if (typeof mat === "undefined")
          mat = this.scene.material[property];
      return mat;
    };
    
   /**
     * Get a particular material property for an id
     * @returns { any }
     * @param {number} id  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterialId = function(id, property) {
      var obj = this.getObj(id);
      return this.getMaterial(obj, property);
    };

    rglwidgetClass.prototype.getAdj = function (obj, index, offset, text) {
      var len, pos;
      if (typeof obj.pos === "undefined")
        return rglwidgetClass.flatten(obj.adj);
      pos = obj.pos[index % obj.pos.length];
      switch(pos) {
        case 0: return [0.5, 0.5, 0.5];
        case 1: return [0.5, 1 + offset, 0.5];
        case 3: return [0.5, -offset, 0.5];
        case 5: return [0.5, 0.5, -offset];
        case 6: return [0.5, 0.5, 1 + offset];
        case 2: 
        case 4: if (typeof text === "undefined")
                  len = 1;
                else
                  len = text.length;
                if (pos === 2)
                  return [1 + offset/len, 0.5, 0.5];
                else
                  return [-offset/len, 0.5, 0.5];
      }
    };

    /**
     * Count clipping planes in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplanes = function() {
      var self = this,
          bound = 0;
      
      Object.keys(this.scene.objects).forEach(
        function(key) {
          var obj = self.getObj(parseInt(key, 10));
          if (obj.type === "clipplanes")
            bound = bound + obj.offsets.length;
        });
      return bound;
    };

    /**
     * Count clipping plane objects in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplaneObjs = function() {
      return this.countObjs("clipplanes");
    };

    /**
     * Count lights in a scene
     * @returns { number }
     */
    rglwidgetClass.prototype.countLights = function() {
      return this.countObjs("light");
    };

    /**
     * Count objects of specific type in a scene
     * @returns { number }
     * @param { string } type - Type of object to count
     */
    rglwidgetClass.prototype.countObjs = function(type) {
      var self = this,
          bound = 0;

      Object.keys(this.scene.objects).forEach(
        function(key) {
          if (self.getObj(parseInt(key, 10)).type === type)
            bound = bound + 1;
        });
      return bound;
    };

    /**
     * Display a debug message
     * @param { string } msg - The message to display
     * @param { Object } [img] - Image to insert before message
     */
    rglwidgetClass.prototype.debug = function(msg, img) {
      if (typeof this.debugelement !== "undefined" && this.debugelement !== null) {
        this.debugelement.innerHTML = msg;
        if (typeof img !== "undefined") {
          this.debugelement.insertBefore(img, this.debugelement.firstChild);
        }
      } else if (msg !== "")
        alert(msg);
    };

    /**
     * If we are in an ioslides or slidy presentation, get the
     * DOM element of the current slide
     * @returns { Object }
     */
    rglwidgetClass.prototype.getSlide = function() {
      var result = this.el, done = false;
      while (result && !done && this.scene.context.rmarkdown) {
      	switch(this.scene.context.rmarkdown) {
          case "ioslides_presentation":
            if (result.tagName === "SLIDE") return result;
            break;
          case "slidy_presentation":
            if (result.tagName === "DIV" && result.classList.contains("slide"))
              return result;
            break;
          default: return null;
      	}
      	result = result.parentElement;
      }
      return null;
    };

    /**
     * Is this scene visible in the browser?
     * @returns { boolean }
     */
    rglwidgetClass.prototype.isInBrowserViewport = function() {
      var rect = this.canvas.getBoundingClientRect(),
          windHeight = (window.innerHeight || document.documentElement.clientHeight),
          windWidth = (window.innerWidth || document.documentElement.clientWidth);
      if (this.scene.context && this.scene.context.rmarkdown !== null) {
      	if (this.slide)
      	  return (this.scene.context.rmarkdown === "ioslides_presentation" &&
      	          this.slide.classList.contains("current")) ||
      	         (this.scene.context.rmarkdown === "slidy_presentation" &&
      	          !this.slide.classList.contains("hidden"));
      }
      return (
      	rect.top >= -windHeight &&
      	rect.left >= -windWidth &&
      	rect.bottom <= 2*windHeight &&
      	rect.right <= 2*windWidth);
    };
    
    rglwidgetClass.keydiff = function(obj1, obj2) {
      var keys = Object.keys(obj1), i, result = [];
      for (i=0;i<keys.length;i++) {
        if (typeof obj1[keys[i]] !== "undefined" &&
            typeof obj2[keys[i]] === "undefined")
          result.push(keys[i]);
      }
      return result;
    };

    rglwidgetClass.isSet = function(flags, flag) {
      /* jshint bitwise: false */
      return (flags & flag) !== 0;
      /* jshint bitwise: true */
    };
    
    rglwidgetClass.prototype.user2window = function(p, subid) {
      var m, v = [].concat(p);
      
      this.setmvMatrix(subid);
      m = new CanvasMatrix4(this.mvMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.setprMatrix(subid);
      m = new CanvasMatrix4(this.prMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.getViewport(subid);
      v[0] = v[0]*0.5/v[3] + 0.5 + this.vp.x/this.vp.width;
      v[1] = v[1]*0.5/v[3] + 0.5 + this.vp.y/this.vp.height;
      v[2] = (1 + v[2]/v[3])*0.5;
      return v.slice(0, 3);
    };

    /**
     * Andrew's convex hull algorithm. 
     * From Wikipedia, used under Creative Commons Attribution-ShareAlike License
     * @returns { Array } Indices of convex hull points
     */
    rglwidgetClass.chull = function(points) {
      function cross(a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
      }
        
      points.sort(function(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      });

      var lower = [], upper = [];
      for (var i = 0; i < points.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
          lower.pop();
        }
        lower.push(points[i]);
      }

      for (i = points.length - 1; i >= 0; i--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
          upper.pop();
        }
        upper.push(points[i]);
      }

      upper.pop();
      lower.pop();
      return lower.concat(upper);
    };
    
    /**
     * Round number to given precision
     * @param { number } x
     * @param { number } digits
     * @returns { number } 
     */
    rglwidgetClass.signif = function(x, digits) { 
      return parseFloat(x.toPrecision(digits));
    };
      
    /**
     * Check for NA, NaN, undefined, or null
     * @param x
     * @returns { bool }
     */
    rglwidgetClass.missing = function(x) {
      return x !== "-Inf" && x !== "Inf" &&
             (isNaN(x) || x === null || typeof(x) === "undefined");
    };

    /**
     * Write matrix to log
     * @param M
     */
    rglwidgetClass.logMatrix = function(M) {
      console.log("matrix(c("+M.m11+","+M.m12+","+M.m13+","+M.m14+",\n"+
                              M.m21+","+M.m22+","+M.m23+","+M.m24+",\n"+
                              M.m31+","+M.m32+","+M.m33+","+M.m34+",\n"+
                              M.m41+","+M.m42+","+M.m43+","+M.m44+"), byrow=TRUE, ncol=4)");
    };
    
    /**
     * Write vector to log
     * @param {vector} v
     */
     
    rglwidgetClass.logVec3 = function(v) {
      console.log("c("+v[0]+","+v[1]+","+v[2]+")");
    };
    
    /**
     * Sum two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vsum = function(x, y) {
       var i, result = [].concat(x);
       for (i = 0; i < y.length; i++)
         result[i] += y[i];
        return result;
     };
     
    /**
     * difference of two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vdiff = function(x, y) {
        return rglwidgetClass.vsum(x, rglwidgetClass.vscale(y, -1));
     };

    /**
     * Scale a vector
     * @param {number} s
     * @param {vector} x
     */
     rglwidgetClass.vscale = function(x, s) {
       var i, result = [].concat(x);
       for (i = 0; i < x.length; i++)
         result[i] *= s;
        return result;
     };
    
    /**
     * Normalize a vector
     * @param {vector} v
     */
    rglwidgetClass.normalize = function(v) {
      return rglwidgetClass.vscale(v, 1/rglwidgetClass.vlen(v));
    };
    
    /**
     * Compute the dimensions of a regular array
     * without checking that it is regular
     */ 
    rglwidgetClass.arrayDim = function(arr) {
      var result = [];
      while (typeof arr.length !== "undefined") {
        result = result.concat(arr.length);
        arr = arr[0];
      }
      return result;
    };
</script>
<script>/**
     * Methods related to buffered data
     * @name ___METHODS_FOR_BUFFERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Detect rglBuffered object
     * @param { Object } obj - vertices or similar 
     */
    rglwidgetClass.prototype.isBuffered = function(obj) {
      return typeof obj === "string";
    };

    /* The next two functions are taken from 
     
     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
     
     They were written by Mozilla Contributors and dedicated
     to the public domain under CC0. */
     
    /* Array of bytes to Base64 string decoding */
    rglwidgetClass.prototype.b64ToUint6 = function(nChr) {
      return nChr > 64 && nChr < 91 ? nChr - 65 : 
             nChr > 96 && nChr < 123 ? nChr - 71 : 
             nChr > 47 && nChr < 58 ? nChr + 4 : 
             nChr === 43 ? 62 : 
             nChr === 47 ? 63 : 
             0;
    };

    /* jshint bitwise:false */
    rglwidgetClass.prototype.base64DecToArr = function(sBase64, nBlocksSize) {
      var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""),
        nInLen = sB64Enc.length, 
        nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
        taBytes = new Uint8Array(nOutLen);
      for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
          for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
            taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
          }
          nUint24 = 0;
        }
      }
      return taBytes;
    };
    /* jshint bitwise:true */
    
    rglwidgetClass.prototype.getArrayBuffer = function(base64) {
      return this.base64DecToArr(base64, 4).buffer;
    };

    rglwidgetClass.prototype.getBufferedData = function(v) {
      return this.readAccessor(parseInt(v, 10), this.scene.buffer);
    };
    
    rglwidgetClass.prototype.readAccessor = function(acc, buf) {
      var typeSignedByte = 5120, 
          typeUnsignedByte = 5121, 
          typeSignedShort = 5122, 
          typeUnsignedShort = 5123, 
          typeSignedInt = 5124, 
          typeUnsignedInt = 5125, 
          typeFloat = 5126, 
          typeDouble = 5130, 
          accessor = buf.accessors[acc], 
          bufferView = buf.bufferViews[accessor.bufferView], 
          buffer = buf.buffers[bufferView.buffer], 
          bytes, 
          lens = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          }, 
          rowsizes = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 2,
            MAT3: 3,
            MAT4: 4
          }, 
          offset = 0, 
          len = lens[accessor.type], 
          rowsize = rowsizes[accessor.type], 
          count = len * accessor.count, 
          nrows = count / rowsize, 
          values, arr = [], row, i, j, k;
          
      if (typeof buffer.bytes === "string") 
        buffer.bytes = this.getArrayBuffer(buffer.bytes);
        
      bytes = buffer.bytes;
      
      if (typeof accessor.byteOffset !== "undefined") 
        offset += accessor.byteOffset;
        
      if (typeof bufferView.byteOffset !== "undefined") 
        offset += bufferView.byteOffset;
        
      switch (accessor.componentType) {
       case typeSignedByte:
        values = new Int8Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedByte:
        values = new Uint8Array(buffer.bytes, offset, count);
        break;

       case typeSignedShort:
        values = new Int16Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedShort:
        values = new Uint16Array(buffer.bytes, offset, count);
        break;

       case typeSignedInt:
        values = new Int32Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedInt:
        values = new Uint32Array(buffer.bytes, offset, count);
        break;

       case typeFloat:
        values = new Float32Array(buffer.bytes, offset, count);
        break;

       case typeDouble:
        values = new Float64Array(buffer.bytes, offset, count);
        break;
      }

      /* This is all very inefficient, but is convenient
             to work with the old code. */
      k = 0;
      for (i = 0; i < nrows; i++) {
        row = [];
        for (j = 0; j < rowsize; j++) {
          if (accessor.normalized) {
            switch(accessor.componentType) {
              case typeSignedByte:
                row.push(Math.max(values[k++]/127, -1.0));
                break;
              case typeSignedShort:
                row.push(Math.max(values[k++]/32767, -1.0));
                break;
              case typeUnsignedByte:
                row.push(values[k++]/255);
                break;
              case typeUnsignedShort:
                row.push(values[k++]/65535);
                break;
            }
          } else
            row.push(values[k++]);
        }
        arr.push(row);
      }
      return arr;
    };
    
    rglwidgetClass.prototype.expandBufferedFields = function(obj) {
      /* this list needs to match the one in convertScene.R */
      var fields = ["vertices", "normals", "indices", 
                    "texcoords", "colors", "centers"], i, field;
      for (i = 0; i < fields.length; i++) {
        field = obj[fields[i]];
        if (this.isBuffered(field))
          obj[fields[i]] = this.getBufferedData(field);
      }
    };
</script>
<script>    /**
     * Methods related to subscenes
     * @name ___METHODS_FOR_SUBSCENES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */

    /**
     * Is a particular id in a subscene?
     * @returns { boolean }
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.inSubscene = function(id, subscene) {
      return this.getObj(subscene).objects.indexOf(id) > -1;
    };

    /**
     * Translate from window coordinates to viewport coordinates
     * @returns { Object } translated coordinates
     * @param { number } subsceneid - which subscene to use?
     * @param { Object } coords - point to translate
     */
    rglwidgetClass.prototype.translateCoords = function(subsceneid, coords) {
      var viewport = this.getObj(subsceneid).par3d.viewport;
      return {x: coords.x - viewport.x*this.canvas.width,
              y: coords.y - viewport.y*this.canvas.height};
    };

    /**
     * Check whether point is in viewport of subscene
     * @returns {boolean}
     * @param { Object } coords - screen coordinates of point
     * @param { number } subsceneid - subscene to check
     */
    rglwidgetClass.prototype.inViewport = function(coords, subsceneid) {
      var viewport = this.getObj(subsceneid).par3d.viewport,
        x0 = coords.x - viewport.x*this.canvas.width,
        y0 = coords.y - viewport.y*this.canvas.height;
      return 0 <= x0 && x0 <= viewport.width*this.canvas.width &&
             0 <= y0 && y0 <= viewport.height*this.canvas.height;
    };

    /**
     * Find which subscene contains a point
     * @returns { number } subscene id
     * @param { Object } coords - coordinates of point
     */
    rglwidgetClass.prototype.whichSubscene = function(coords) {
      var self = this,
          recurse = function(subsceneid) {
            var subscenes = self.getChildSubscenes(subsceneid), i, id;
            for (i=0; i < subscenes.length; i++) {
              id = recurse(subscenes[i]);
              if (typeof(id) !== "undefined")
                return(id);
            }
            if (self.inViewport(coords, subsceneid))
              return(subsceneid);
            else
              return undefined;
          },
          rootid = this.scene.rootSubscene,
          result = recurse(rootid);
      if (typeof(result) === "undefined")
        result = rootid;
      return result;
    };

    /**
     * Add an id to a subscene.
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.addToSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          ids = [id],
          obj = this.getObj(id), i;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined") {
        ids = ids.concat(obj.newIds);
      }
      thesub.objects = [].concat(thesub.objects);
      for (i = 0; i < ids.length; i++) {
        id = ids[i];
        if (thesub.objects.indexOf(id) === -1) {
          thelist = this.whichList(id);
          thesub.objects.push(id);
          thesub[thelist].push(id);
        }
      }
    };

    /**
     * Delete an id from a subscene
     * @param { number } id - the id to add
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.delFromSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          obj = this.getObj(id),
          ids = [id], i, j;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined")
        ids = ids.concat(obj.newIds);
      thesub.objects = [].concat(thesub.objects); // It might be a scalar
      for (j=0; j<ids.length;j++) {
        id = ids[j];
        i = thesub.objects.indexOf(id);
        if (i > -1) {
          thesub.objects.splice(i, 1);
          thelist = this.whichList(id);
          i = thesub[thelist].indexOf(id);
          thesub[thelist].splice(i, 1);
        }
      }
    };

    /**
     * Set the ids in a subscene
     * @param { number[] } ids - the ids to set
     * @param { number } subsceneid - the id of the subscene
     */
    rglwidgetClass.prototype.setSubsceneEntries = function(ids, subsceneid) {
      var sub = this.getObj(subsceneid);
      sub.objects = ids;
      this.initSubscene(subsceneid);
    };

    /**
     * Get the ids in a subscene
     * @returns {number[]}
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getSubsceneEntries = function(subscene) {
      return this.getObj(subscene).objects;
    };

    /**
     * Get the ids of the subscenes within a subscene
     * @returns { number[] }
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getChildSubscenes = function(subscene) {
      return this.getObj(subscene).subscenes;
    };

    /**
     * Find a particular subscene by inheritance
     * @returns { number } id of subscene to use
     * @param { number } subsceneid - child subscene
     * @param { string } type - type of inheritance:  "projection" or "model"
     */
    rglwidgetClass.prototype.useid = function(subsceneid, type) {
      var sub = this.getObj(subsceneid);
      if (sub.embeddings[type] === "inherit")
        return(this.useid(sub.parent, type));
      else
        return subsceneid;
    };

    /**
     * Find bboxdeco for a subscene
     * @returns { number } id of bboxdeco, or undefined if none
     * @param { number } sub- subscene
     */
    rglwidgetClass.prototype.getBBoxDeco = function(sub) {
      var objects = sub.objects, i, obj;
      for (i = 0; i < objects.length; i++) {
        obj = this.getObj(objects[i]);
        if (obj.type === "bboxdeco")
          return obj;
      }
      if (sub.parent) 
        return this.getBBoxDeco(this.getObj(sub.parent));
      else
        return undefined;
    };
</script>
<script>    /**
     * Methods related to shaders
     * @name ___METHODS_FOR_SHADERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get flags that will end up as shader defines.
     * Static method so it can be called from R
     */
    rglwidgetClass.getDefFlags = function(flags, type, normals, round_points) {
      var f = {};
      f.fat_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_fat_lines);
      f.fixed_quads = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads);
      f.fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size);
      f.has_fog = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_fog);
      f.has_normals = (typeof normals !== "undefined") ||
                        type === "spheres";
      f.has_texture = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_texture);
      f.is_brush = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_brush);
      f.is_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lines);
      f.is_lit = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit);
      f.is_points = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_points);
      f.is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
      f.is_twosided = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_twosided);
      f.needs_vnormal = !rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d) &&
        (f.is_lit && !f.fixed_quads && !f.is_brush) || (f.is_twosided && f.has_normals);
      f.rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating);
      f.round_points = round_points;
      return f;
    };
     
    
    /**
     * Generate the defines for the shader code for an object.
     * 
     * This is a static method so it can be called from R.
     * 
     * @returns {string}
     * @param  id - id of object
     * @param  type - type of object
     * @param  flags - object flags
     * @param  nclipplanes - number of clipping planes in scene 
     *         (may not all be active)
     * @param  nlights - number of lights in scene (ditto)
     * @param  normals - normals for object
     * @param  pointSize - point size for object 
     * @param  textype - texture type for object 
     * @param  antialias - use antialiasing?
     */
    rglwidgetClass.getDefines = function(id, type, flags,
      nclipplanes, nlights, normals, pointSize, textype,
      texmode, texenvmap, antialias, fl) {
      var
        title, defines;
      
      if (typeof fl === "undefined")
        fl = rglwidgetClass.getDefFlags(flags, type, normals, antialias);
        
      title = "  /* ****** "+type+" object "+id+" shader ****** */\n";
      
      defines = "#define NCLIPPLANES " + nclipplanes + "\n"+
                "#define NLIGHTS " + nlights + "\n";
      
      if (fl.fat_lines)
        defines = defines + "#define FAT_LINES 1\n";
      
      if (fl.fixed_quads)
        defines = defines + "#define FIXED_QUADS 1\n";

      if (fl.fixed_size)
        defines = defines + "#define FIXED_SIZE 1\n";

      if (fl.has_fog)
        defines = defines + "#define HAS_FOG 1\n";
        
      if (fl.has_normals)
        defines = defines + "#define HAS_NORMALS 1\n";
        
      if (fl.has_texture) {
        defines = defines + "#define HAS_TEXTURE 1\n";
        defines = defines + "#define TEXTURE_" + textype + "\n";
        defines = defines + "#define TEXMODE_" + texmode + "\n";
        if (texenvmap)
          defines = defines + "#define USE_ENVMAP 1\n";
      }
      
      if (fl.is_brush)
        defines = defines + "#define IS_BRUSH 1\n";  

      if (type === "linestrip")
        defines = defines + "#define IS_LINESTRIP 1\n";         

      if (fl.is_lit)
        defines = defines + "#define IS_LIT 1\n"; 
      
      if (fl.is_points) {
        defines = defines + "#define IS_POINTS 1\n";
        defines = defines + "#define POINTSIZE " + Number.parseFloat(pointSize).toFixed(1) + "\n";
      }
        
      if (type === "sprites")
        defines = defines + "#define IS_SPRITES 1\n";
        
      if (type === "text")
        defines = defines + "#define IS_TEXT 1\n";

      if (fl.is_transparent)
        defines = defines + "#define IS_TRANSPARENT 1\n"; 
        
      if (fl.is_twosided)
        defines = defines + "#define IS_TWOSIDED 1\n";
        
      if (fl.needs_vnormal)
        defines = defines + "#define NEEDS_VNORMAL 1\n";

      if (fl.rotating)
        defines = defines + "#define ROTATING 1\n";
        
      if (fl.round_points)        
        defines = defines + "#define ROUND_POINTS 1\n";   

      // console.log(result);
      return title + defines;
    };

    /**
     * Create code for vertex and fragment shaders
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShaders = function(obj) {
      var header, 
        vertex = obj.userVertexShader, 
        fragment = obj.userFragmentShader;
      
      header = rglwidgetClass.getDefines(
        obj.id, obj.type, obj.flags, 
        this.countClipplanes(), this.countLights(), 
        obj.normals, 
        this.getMaterial(obj, "size"), 
        this.getMaterial(obj, "textype"),
        this.getMaterial(obj, "texmode"),
        this.getMaterial(obj, "texenvmap"),
        this.getMaterial(obj, "point_antialias"),
        obj.defFlags
      );

      if (typeof vertex === "undefined")
        vertex = rglwidgetClass.rgl_vertex_shader();
        
      if (typeof fragment === "undefined") 
        fragment = rglwidgetClass.rgl_fragment_shader();

//      console.log("vertex:");
//      console.log(header + vertex);
//      console.log("fragment:");
//      console.log(header + fragment);
      
      return {vertex: header + vertex,
              fragment: header + fragment};
    };
    
    
    /**
     * Call gl functions to create and compile shader from code
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShader = function(shaderType, code) {
        var gl = this.gl, shader;
        shader = gl.createShader(shaderType);
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost())
            alert(gl.getShaderInfoLog(shader));
        return shader;
    };

</script>
<script>rglwidgetClass.rgl_vertex_shader = function() {
return  "#line 2 1\n"+
"// File 1 is the vertex shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"\n"+
"attribute vec3 aPos;\n"+
"attribute vec4 aCol;\n"+
"uniform mat4 mvMatrix;\n"+
"uniform mat4 prMatrix;\n"+
"varying vec4 vCol;\n"+
"varying vec4 vPosition;\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"attribute vec3 aNorm;\n"+
"uniform mat4 normMatrix;\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"attribute vec2 aTexcoord;\n"+
"varying vec2 vTexcoord;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_SIZE\n"+
"uniform vec3 textScale;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_QUADS\n"+
"attribute vec3 aOfs;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"varying float normz;\n"+
"uniform mat4 invPrMatrix;\n"+
"#else\n"+
"attribute vec3 aPos1;\n"+
"attribute vec3 aPos2;\n"+
"varying float normz;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"attribute vec3 aNext;\n"+
"attribute vec2 aPoint;\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"uniform float uAspect;\n"+
"uniform float uLwd;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  \n"+
"#ifndef IS_BRUSH\n"+
"#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n"+
"  vPosition = mvMatrix * vec4(aPos, 1.);\n"+
"#endif\n"+
"  \n"+
"#ifndef FIXED_QUADS\n"+
"  gl_Position = prMatrix * vPosition;\n"+
"#endif\n"+
"#endif // !IS_BRUSH\n"+
"  \n"+
"#ifdef IS_POINTS\n"+
"  gl_PointSize = POINTSIZE;\n"+
"#endif\n"+
"  \n"+
"  vCol = aCol;\n"+
"  \n"+
"// USE_ENVMAP implies NEEDS_VNORMAL\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n"+
"                        normalize(vNormal.xyz/vNormal.w)));\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"  /* normz should be calculated *after* projection */\n"+
"  normz = (invPrMatrix*vNormal).z;\n"+
"#else\n"+
"  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n"+
"  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n"+
"  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n"+
"  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n"+
"  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"  \n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n"+
"#endif\n"+
"  \n"+
"#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n"+
"  vTexcoord = aTexcoord;\n"+
"#endif\n"+
"  \n"+
"#if defined(FIXED_SIZE) && !defined(ROTATING)\n"+
"  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w;\n"+
"  gl_Position = pos + vec4(aOfs*textScale, 0.);\n"+
"#endif\n"+
"  \n"+
"#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n"+
"  vec4 pos = mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w + vec4(aOfs,  0.);\n"+
"  gl_Position = prMatrix*pos;\n"+
"#endif\n"+
"  \n"+
"#ifdef FAT_LINES\n"+
"  /* This code was inspired by Matt Deslauriers' code in \n"+
"   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n"+
"  vec2 aspectVec = vec2(uAspect, 1.0);\n"+
"  mat4 projViewModel = prMatrix * mvMatrix;\n"+
"  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n"+
"  currentProjected = currentProjected/currentProjected.w;\n"+
"  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n"+
"  vec2 currentScreen = currentProjected.xy * aspectVec;\n"+
"  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n"+
"  float len = uLwd;\n"+
"  vec2 dir = vec2(1.0, 0.0);\n"+
"  vPoint = aPoint;\n"+
"  vLength = length(nextScreen - currentScreen)/2.0;\n"+
"  vLength = vLength/(vLength + len);\n"+
"  if (vLength > 0.0) {\n"+
"    dir = normalize(nextScreen - currentScreen);\n"+
"  }\n"+
"  vec2 normal = vec2(-dir.y, dir.x);\n"+
"  dir.x /= uAspect;\n"+
"  normal.x /= uAspect;\n"+
"  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n"+
"  gl_Position = currentProjected + offset;\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_BRUSH\n"+
"  gl_Position = vec4(aPos, 1.);\n"+
"#endif\n"+
"}\n" ;};
rglwidgetClass.rgl_fragment_shader = function() {
return  "#line 2 2\n"+
"// File 2 is the fragment shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"varying vec4 vCol; // carries alpha\n"+
"varying vec4 vPosition;\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"varying vec2 vTexcoord;\n"+
"uniform sampler2D uSampler;\n"+
"#endif\n"+
"\n"+
"#ifdef HAS_FOG\n"+
"uniform int uFogMode;\n"+
"uniform vec3 uFogColor;\n"+
"uniform vec4 uFogParms;\n"+
"#endif\n"+
"\n"+
"#if defined(IS_LIT) && !defined(FIXED_QUADS)\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if NCLIPPLANES > 0\n"+
"uniform vec4 vClipplane[NCLIPPLANES];\n"+
"#endif\n"+
"\n"+
"#if NLIGHTS > 0\n"+
"uniform mat4 mvMatrix;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"uniform vec3 emission;\n"+
"uniform float shininess;\n"+
"#if NLIGHTS > 0\n"+
"uniform vec3 ambient[NLIGHTS];\n"+
"uniform vec3 specular[NLIGHTS]; // light*material\n"+
"uniform vec3 diffuse[NLIGHTS];\n"+
"uniform vec3 lightDir[NLIGHTS];\n"+
"uniform bool viewpoint[NLIGHTS];\n"+
"uniform bool finite[NLIGHTS];\n"+
"#endif\n"+
"#endif // IS_LIT\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"uniform bool front;\n"+
"varying float normz;\n"+
"#endif\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  vec4 fragColor;\n"+
"#ifdef FAT_LINES\n"+
"  vec2 point = vPoint;\n"+
"  bool neg = point.y < 0.0;\n"+
"  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n"+
"                 -(point.y - vLength)/(1.0 - vLength);\n"+
"#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n"+
"  if (neg && length(point) <= 1.0) discard;\n"+
"#endif\n"+
"  point.y = min(point.y, 0.0);\n"+
"  if (length(point) > 1.0) discard;\n"+
"#endif // FAT_LINES\n"+
"  \n"+
"#ifdef ROUND_POINTS\n"+
"  vec2 coord = gl_PointCoord - vec2(0.5);\n"+
"  if (length(coord) > 0.5) discard;\n"+
"#endif\n"+
"  \n"+
"#if NCLIPPLANES > 0\n"+
"  for (int i = 0; i < NCLIPPLANES; i++)\n"+
"    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n"+
"#endif\n"+
"    \n"+
"#ifdef FIXED_QUADS\n"+
"    vec3 n = vec3(0., 0., 1.);\n"+
"#elif defined(IS_LIT)\n"+
"    vec3 n = normalize(vNormal.xyz);\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TWOSIDED\n"+
"    if ((normz <= 0.) != front) discard;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n"+
"    vec3 lightdir;\n"+
"    vec4 colDiff;\n"+
"    vec3 halfVec;\n"+
"    vec4 lighteffect = vec4(emission, 0.);\n"+
"    vec3 col;\n"+
"    float nDotL;\n"+
"#ifdef FIXED_QUADS\n"+
"    n = -faceforward(n, n, eye);\n"+
"#endif\n"+
"    \n"+
"#if NLIGHTS > 0\n"+
"    for (int i=0;i<NLIGHTS;i++) {\n"+
"      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n"+
"      lightdir = lightDir[i];\n"+
"      if (!viewpoint[i])\n"+
"        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n"+
"      if (!finite[i]) {\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      } else {\n"+
"        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      }\n"+
"      col = ambient[i];\n"+
"      nDotL = dot(n, lightdir);\n"+
"      col = col + max(nDotL, 0.) * colDiff.rgb;\n"+
"      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n"+
"      lighteffect = lighteffect + vec4(col, colDiff.a);\n"+
"    }\n"+
"#endif\n"+
"    \n"+
"#else // not IS_LIT\n"+
"    vec4 colDiff = vCol;\n"+
"    vec4 lighteffect = colDiff;\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TEXT\n"+
"    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"    \n"+
"#ifdef HAS_TEXTURE\n"+
"\n"+
"// These calculations use the definitions from \n"+
"// https://docs.gl/gl3/glTexEnv\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n"+
"    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n"+
"#else\n"+
"    vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXTURE_rgb\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(textureColor.rgb, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif //TEXTURE_rgb\n"+
"        \n"+
"#ifdef TEXTURE_rgba\n"+
"\n"+
"#ifdef TEXMODE_replace\n"+
"// already done\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*textureColor;\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_decal\n"+
"    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n"+
"                     textureColor.a*textureColor.rgb, \n"+
"                     lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"    \n"+
"#endif //TEXTURE_rgba\n"+
"    \n"+
"#ifdef TEXTURE_alpha\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(lighteffect.rgb, textureColor.a);\n"+
"#endif \n"+
"\n"+
"#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n"+
"    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n"+
"#endif\n"+
" \n"+
"#endif\n"+
"    \n"+
"// The TEXTURE_luminance values are not from that reference    \n"+
"#ifdef TEXTURE_luminance\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance\n"+
" \n"+
"    \n"+
"#ifdef TEXTURE_luminance_alpha\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance_alpha\n"+
"    \n"+
"    fragColor = textureColor;\n"+
"\n"+
"#elif defined(IS_TEXT)\n"+
"    if (textureColor.a < 0.1)\n"+
"      discard;\n"+
"    else\n"+
"      fragColor = textureColor;\n"+
"#else\n"+
"    fragColor = lighteffect;\n"+
"#endif // HAS_TEXTURE\n"+
"    \n"+
"#ifdef HAS_FOG\n"+
"    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n"+
"    // In Exp and Exp2: use density = density/far\n"+
"    // fogF will be the proportion of fog\n"+
"    // Initialize it to the linear value\n"+
"    float fogF;\n"+
"    if (uFogMode > 0) {\n"+
"      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n"+
"      if (uFogMode > 1)\n"+
"        fogF = mix(uFogParms.w, 1.0, fogF);\n"+
"      fogF = fogF*uFogParms.z;\n"+
"      if (uFogMode == 2)\n"+
"        fogF = 1.0 - exp(-fogF);\n"+
"      // Docs are wrong: use (density*c)^2, not density*c^2\n"+
"      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n"+
"      else if (uFogMode == 3)\n"+
"        fogF = 1.0 - exp(-fogF*fogF);\n"+
"      fogF = clamp(fogF, 0.0, 1.0);\n"+
"      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n"+
"    } else gl_FragColor = fragColor;\n"+
"#else\n"+
"    gl_FragColor = fragColor;\n"+
"#endif // HAS_FOG\n"+
"    \n"+
"}\n" ;};
</script>
<script>    /**
     * Methods related to textures
     * @name ___METHODS_FOR_TEXTURES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getTexFilter = function(filter) {
      var gl = this.gl || this.initGL();
      switch(filter) {
        case "nearest": return gl.NEAREST;
        case "linear": return gl.LINEAR;
        case "nearest.mipmap.nearest": return gl.NEAREST_MIPMAP_NEAREST;
        case "linear.mipmap.nearest": return gl.LINEAR_MIPMAP_NEAREST;
        case "nearest.mipmap.linear": return gl.NEAREST_MIPMAP_LINEAR;
        case "linear.mipmap.linear": return gl.LINEAR_MIPMAP_LINEAR;
        default: console.error("Unknown filter: "+filter);
      }
    };
     
    /**
     * Handle a texture after its image has been loaded
     * @param { Object } texture - the gl texture object
     * @param { Object } textureCanvas - the canvas holding the image
     */
    rglwidgetClass.prototype.handleLoadedTexture = function(texture, textureCanvas) {
      var gl = this.gl || this.initGL();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);

      gl.bindTexture(gl.TEXTURE_2D, null);
    };

    /**
     * Get maximum dimension of texture in current browser.
     * @returns {number}
     */
    rglwidgetClass.prototype.getMaxTexSize = function() {
      var gl = this.gl || this.initGL();	
      return Math.min(4096, gl.getParameter(gl.MAX_TEXTURE_SIZE));
    };
    
    /**
     * Load an image to a texture
     * @param { string } uri - The image location
     * @param { Object } texture - the gl texture object
     */
    rglwidgetClass.prototype.loadImageToTexture = function(uri, texture) {
      var canvas = this.textureCanvas,
          ctx = canvas.getContext("2d"),
          image = new Image(),
          self = this;

       image.onload = function() {

         var w = image.width,
             h = image.height,
             canvasX = self.getPowerOfTwo(w),
             canvasY = self.getPowerOfTwo(h),
             maxTexSize = self.getMaxTexSize();
         while (canvasX > 1 && canvasY > 1 && (canvasX > maxTexSize || canvasY > maxTexSize)) {
           canvasX /= 2;
           canvasY /= 2;
         }
         canvas.width = canvasX;
         canvas.height = canvasY;
         ctx.imageSmoothingEnabled = true;
         ctx.drawImage(image, 0, 0, canvasX, canvasY);
         self.handleLoadedTexture(texture, canvas);
         self.texturesLoading -= 1;
         if (!self.texturesLoading)
           self.drawScene();
       };
       if (!self.texturesLoading)
         self.texturesLoading = 0; // may have been undefined
       self.texturesLoading += 1;
       image.src = uri;
     };

    /**
     * Draw text to the texture canvas
     * @returns { Object } object with text measurements
     * @param { string } text - the text
     * @param { number } cex - expansion
     * @param { string } family - font family
     * @param { number } font - font number
     */
    rglwidgetClass.prototype.drawTextToCanvas = function(text, cex, family, font) {
       var canvasX, canvasY,
           scaling = 20,
           textColour = "white",

           backgroundColour = "rgba(0,0,0,0)",
           canvas = this.textureCanvas,
           ctx = canvas.getContext("2d"),
           i, textHeight = 0, textHeights = [], width, widths = [], 
           offsetx, offsety = 0, line, lines = [], offsetsx = [],
           offsetsy = [], lineoffsetsy = [], fontStrings = [],
           maxTexSize = this.getMaxTexSize(),
           getFontString = function(i) {
             textHeights[i] = scaling*cex[i];
             var fontString = textHeights[i] + "px",
                 family0 = family[i],
                 font0 = font[i];
             if (family0 === "sans")
               family0 = "sans-serif";
             else if (family0 === "mono")
               family0 = "monospace";
             fontString = fontString + " " + family0;
             if (font0 === 2 || font0 === 4)
               fontString = "bold " + fontString;
             if (font0 === 3 || font0 === 4)
               fontString = "italic " + fontString;
             return fontString;
           };
       cex = rglwidgetClass.repeatToLen(cex, text.length);
       family = rglwidgetClass.repeatToLen(family, text.length);
       font = rglwidgetClass.repeatToLen(font, text.length);

       canvasX = 1;
       line = -1;
       offsetx = maxTexSize;
       for (i = 0; i < text.length; i++)  {
         ctx.font = fontStrings[i] = getFontString(i);
         width = widths[i] = ctx.measureText(text[i]).width;
         if (offsetx + width > maxTexSize) {
           offsety = offsety + 2*textHeight;
           if (line >= 0)
             lineoffsetsy[line] = offsety;
           line += 1;
           if (offsety > maxTexSize)
             console.error("Too many strings for texture.");
           textHeight = 0;
           offsetx = 0;
         }
         textHeight = Math.max(textHeight, textHeights[i]);
         offsetsx[i] = offsetx;
         offsetx += width;
         canvasX = Math.max(canvasX, offsetx);
         lines[i] = line;
       }
       offsety = lineoffsetsy[line] = offsety + 2*textHeight;
       for (i = 0; i < text.length; i++) {
       	 offsetsy[i] = lineoffsetsy[lines[i]];
       }
       
       canvasX = this.getPowerOfTwo(canvasX);
       canvasY = this.getPowerOfTwo(offsety);

       canvas.width = canvasX;
       canvas.height = canvasY;

       ctx.fillStyle = backgroundColour;
       ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

       ctx.textBaseline = "alphabetic";
       for(i = 0; i < text.length; i++) {
         ctx.font = fontStrings[i];
         ctx.fillStyle = textColour;
         ctx.textAlign = "left";
         ctx.fillText(text[i], offsetsx[i],  offsetsy[i]);
       }
       return {canvasX:canvasX, canvasY:canvasY,
               widths:widths, textHeights:textHeights,
               offsetsx:offsetsx, offsetsy:offsetsy};
     };

</script>
<script>    /**
     * Methods related to projections
     * @name ___METHODS_FOR_PROJECTIONS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get the viewport
     */
     
    rglwidgetClass.prototype.getViewport = function(id) {
      var vp = this.getObj(id).par3d.viewport,
         x = vp.x*this.canvas.width,
         y = vp.y*this.canvas.height,
         width = vp.width*this.canvas.width,
         height = vp.height*this.canvas.height;
       this.vp = {x:x, y:y, width:width, height:height};
    };
    
    /**
     * Set the gl viewport and scissor test
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setViewport = function(id) {
       var gl = this.gl || this.initGL();
       this.getViewport(id);
       gl.viewport(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.scissor(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.enable(gl.SCISSOR_TEST);
     };

    /**
     * Set the projection matrix for a subscene
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setprMatrix = function(id) {
       var subscene = this.getObj(id),
          embedding = subscene.embeddings.projection;
       if (embedding === "replace")
         this.prMatrix.makeIdentity();
       else
         this.setprMatrix(subscene.parent);
       if (embedding === "inherit")
         return;
       // This is based on the Frustum::enclose code from geom.cpp
       var bbox = subscene.par3d.bbox,
           scale = subscene.par3d.scale,
           ranges = [(bbox[1]-bbox[0])*scale[0]/2,
                     (bbox[3]-bbox[2])*scale[1]/2,
                     (bbox[5]-bbox[4])*scale[2]/2],
           radius = Math.sqrt(this.sumsq(ranges))*1.1; // A bit bigger to handle labels
       if (radius <= 0) radius = 1;
       var observer = subscene.par3d.observer,
           distance = observer[2],
           FOV = subscene.par3d.FOV, ortho = FOV === 0,
           t = ortho ? 1 : Math.tan(FOV*Math.PI/360),
           near = distance - radius,
           far = distance + radius,
           hlen,
           aspect = this.vp.width/this.vp.height,
           z = subscene.par3d.zoom,
           userProjection = subscene.par3d.userProjection;
       if (far < 0.0)
         far = 1.0;
       if (near < far/100.0)
         near = far/100.0;
       this.frustum = {near:near, far:far};
       hlen = t*near;
       if (ortho) {
         if (aspect > 1)
           this.prMatrix.ortho(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.ortho(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       } else {
         if (aspect > 1)
           this.prMatrix.frustum(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.frustum(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       }
       this.prMatrix.multRight(userProjection);
     };

    /**
     * Set the model-view matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmvMatrix = function(id) {
       var observer = this.getObj(id).par3d.observer;
       this.mvMatrix.makeIdentity();
       this.setmodelMatrix(id);
       this.mvMatrix.translate(-observer[0], -observer[1], -observer[2]);

     };

    /**
     * Set the model matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmodelMatrix = function(id) {
      var subscene = this.getObj(id),
          embedding = subscene.embeddings.model;
      if (embedding === "replace") {
        var bbox = subscene.par3d.bbox,
            center = [(bbox[0]+bbox[1])/2,
                      (bbox[2]+bbox[3])/2,
                      (bbox[4]+bbox[5])/2];
        this.mvMatrix.translate(-center[0], -center[1], -center[2]);
      }
      if (embedding !== "inherit") {
        var scale = subscene.par3d.scale;
        this.mvMatrix.scale(scale[0], scale[1], scale[2]);
        this.mvMatrix.multRight( subscene.par3d.userMatrix );
      }
      if (embedding !== "replace")
        this.setmodelMatrix(subscene.parent);
     };

    /**
     * Set the normals matrix for a subscene
     * @param { number } subsceneid - id of the subscene
     */
     rglwidgetClass.prototype.setnormMatrix2 = function() {
       this.normMatrix = new CanvasMatrix4(this.mvMatrix);
       this.normMatrix.invert();
       this.normMatrix.transpose();
     };

    /**
     * Set the combined projection-model-view matrix
     */
    rglwidgetClass.prototype.setprmvMatrix = function() {
       this.prmvMatrix = new CanvasMatrix4( this.mvMatrix );
       this.prmvMatrix.multRight( this.prMatrix );
     };

    rglwidgetClass.prototype.setInvPrMatrix = function() {
      this.invPrMatrix = new CanvasMatrix4( this.prMatrix );
      this.invPrMatrix.invert();
      this.invPrMatrix.transpose();
    };
</script>
<script>    /**
     * Methods related to mouse handling
     * @name ___METHODS_FOR_MOUSE_HANDLING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getCursor = function(mode) {
      switch(mode) {
        case "none": 
          return "none";
        case "trackball":
        case "xAxis":
        case "yAxis":
        case "zAxis":
        case "polar":
          return "grab";
        case "selecting":
          return "crosshair";
        case "fov":
        case "zoom":
          return "zoom-in";
        case "user":
          return "default";
      }
      return "dragging";
    };
    
    /**
     * Set mouse mode for a subscene
     * @param { string } mode - name of mode
     * @param { number } button - button number (0 to 4)
     * @param { number } subscene - subscene id number
     * @param { number } stayActive - if truthy, don't clear brush
     */
    rglwidgetClass.prototype.setMouseMode = function(mode, button, subscene, stayActive) {
      var sub = this.getObj(subscene),
          which = ["none", "left", "right", "middle", "wheel"][button];
      if (!stayActive && sub.par3d.mouseMode[which] === "selecting")
        this.clearBrush(null);
      sub.par3d.mouseMode[which] = mode;
      if (button === 1 || (button === 0 && mode !== "none"))
        this.canvas.style.cursor = this.getCursor(mode);
      if (button === 0 && mode !== "none")
        sub.needsBegin = mode;
    };

    /**
     * Compute mouse coordinates relative to current canvas
     * @returns { Object }
     * @param { Object } event - event object from mouse click
     */
    rglwidgetClass.prototype.relMouseCoords = function(event) {
      var rect = this.canvas.getBoundingClientRect();
      return {x:event.clientX-rect.left, y:event.clientY-rect.top};
    };
    
    /**
     * Send mouse selection to Shiny
     */
    rglwidgetClass.prototype.recordSelection = function(subid) {
      var result = {};
      if (typeof this.select !== "undefined" && 
          typeof this.select.state !== "undefined" &&
          this.select.state !== "inactive") {
        result = { subscene: subid,
                   state: this.select.state,
                   region: this.select.region
                 };
        this.setmvMatrix(subid);
        result.model = this.mvMatrix;
        this.setprMatrix(subid);
        result.proj = this.prMatrix;
        this.getViewport(subid);
        result.view = this.vp;
      } else
        result.state = "inactive";
      Shiny.setInputValue(this.scene.selectionInput + ":shinyMouse3d", result);
    }; 

    /**
     * Set mouse handlers for the scene
     */
    rglwidgetClass.prototype.setMouseHandlers = function() {
      var self = this, activeSubscene, handler,
          handlers = {}, drag = 0;

      handlers.rotBase = 0;

      self.screenToVector = function(x, y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
          radius = Math.max(width, height)/2.0,
          cx = width/2.0,
          cy = height/2.0,
          px = (x-cx)/radius,
          py = (y-cy)/radius,
          plen = Math.sqrt(px*px+py*py);
        if (plen > 1.e-6) {
          px = px/plen;
          py = py/plen;
        }
        var angle = (Math.SQRT2 - plen)/Math.SQRT2*Math.PI/2,
          z = Math.sin(angle),
          zlen = Math.sqrt(1.0 - z*z);
        px = px * zlen;
        py = py * zlen;
        return [px, py, z];
      };

      handlers.trackballdown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.rotBase = self.screenToVector(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.trackballmove = function(x,y) {
        var rotCurrent = self.screenToVector(x,y),
            rotBase = handlers.rotBase,
            dot = rotBase[0]*rotCurrent[0] +
                  rotBase[1]*rotCurrent[1] +
                  rotBase[2]*rotCurrent[2],
            angle = Math.acos( dot/rglwidgetClass.vlen(rotBase)/rglwidgetClass.vlen(rotCurrent) )*180.0/Math.PI,
            axis = rglwidgetClass.xprod(rotBase, rotCurrent),
            objects = self.scene.objects,
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            l = activeModel.par3d.listeners,
            i;
        if (angle === 0.0)
          return;    
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(angle, axis[0], axis[1], axis[2]);
        }
        self.drawScene();
      };
      handlers.trackballend = 0;

      self.clamp = function(x, lo, hi) {
      	return Math.max(lo, Math.min(x, hi));
      };

      self.screenToPolar = function(x,y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
    	  r = Math.min(width, height)/2,
    	  dx = self.clamp(x - width/2, -r, r),
    	  dy = self.clamp(y - height/2, -r, r);
    	  return [Math.asin(dx/r), Math.asin(-dy/r)];
      };

      handlers.polardown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.dragBase = self.screenToPolar(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
          activeSub.camBase = [-Math.atan2(activeSub.saveMat.m13, activeSub.saveMat.m11),
                               Math.atan2(activeSub.saveMat.m32, activeSub.saveMat.m22)];
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.polarmove = function(x,y) {
        var dragCurrent = self.screenToPolar(x,y),
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            objects = self.scene.objects,
            l = activeModel.par3d.listeners,
            i, j, changepos = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          for (j=0; j<2; j++)
            changepos[j] = -(dragCurrent[j] - handlers.dragBase[j]);
          activeSub.par3d.userMatrix.makeIdentity();
          activeSub.par3d.userMatrix.rotate(changepos[0]*180/Math.PI, 0,-1,0);
          activeSub.par3d.userMatrix.multRight(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(changepos[1]*180/Math.PI, -1,0,0);
        }
        self.drawScene();
      };
      handlers.polarend = 0;

      handlers.axisdown = function(x) {
        handlers.rotBase = self.screenToVector(x, self.canvas.height/2);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.axismove = function(x) {
        var rotCurrent = self.screenToVector(x, self.canvas.height/2),
            rotBase = handlers.rotBase,
            angle = (rotCurrent[0] - rotBase[0])*180/Math.PI,
            rotMat = new CanvasMatrix4();
        rotMat.rotate(angle, handlers.axis[0], handlers.axis[1], handlers.axis[2]);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(activeSub.saveMat);
          activeSub.par3d.userMatrix.multLeft(rotMat);
        }
        self.drawScene();
      };
      handlers.axisend = 0;

      handlers.y0zoom = 0;
      handlers.zoomdown = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        handlers.y0zoom = y;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.zoom0 = Math.log(activeSub.par3d.zoom);
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.zoommove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom = Math.exp(activeSub.zoom0 + (y-handlers.y0zoom)/self.canvas.height);
        }
        self.drawScene();
      };
      handlers.zoomend = 0;

      handlers.y0fov = 0;
      handlers.fovdown = function(x, y) {
        handlers.y0fov = y;
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.fov0 = activeSub.par3d.FOV;
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.fovmove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.FOV = Math.max(1, Math.min(179, activeSub.fov0 +
             180*(y-handlers.y0fov)/self.canvas.height));
        }
        self.drawScene();
      };
      handlers.fovend = 0;
      
      handlers.selectingdown = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height, 
          p = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	self.select.region = {p1: p, p2: p};
      	if (self.select.subscene && self.select.subscene !== activeSubscene)
      	  self.delFromSubscene(self.scene.brushId, self.select.subscene);
      	self.select.subscene = activeSubscene;
      	self.addToSubscene(self.scene.brushId, activeSubscene);
      	self.select.state = "changing";
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene); 
      	self.drawScene();
      	self.canvas.style.cursor = "crosshair";
      };
      
      handlers.selectingmove = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height;
      	if (self.select.state === "inactive") 
      	  return;
      	self.select.region.p2 = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene);
      	self.drawScene();
      };
      
      handlers.selectingend = 0;
      /* jshint evil:true */
      handlers.userdown = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].begin;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.usermove = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].update;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.userend = function() {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].end;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self);
        }
      };

      self.canvas.onpointerdown = function ( ev ){
        // pointers and mice differ in capture rules; 
        // act like a mouse.
        if (ev.target.hasPointerCapture(ev.pointerId))
          ev.target.releasePointerCapture(ev.pointerId);
          
        if (!ev.which) // Use w3c defns in preference to MS
        switch (ev.button) {
          case 0: ev.which = 1; break;
          case 1:
          case 4: ev.which = 2; break;
          case 2: ev.which = 3;
        }
        drag = ["none", "left", "middle", "right", "wheel"][ev.which];
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height-coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f;
        handler = sub.par3d.mouseMode[drag];
        switch (handler) {
        case "xAxis":
          handler = "axis";
          handlers.axis = [1.0, 0.0, 0.0];
          break;
        case "yAxis":
          handler = "axis";
          handlers.axis = [0.0, 1.0, 0.0];
          break;
        case "zAxis":
          handler = "axis";
          handlers.axis = [0.0, 0.0, 1.0];
          break;
        }
        f = handlers[handler + "down"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
          ev.preventDefault();
        } else
          console.warn("Mouse handler '" + handler + "' is not implemented.");

      };

      self.canvas.onpointerup = function ( ev ){
        if ( !drag ) return;
        var f = handlers[handler + "end"];
        if (f) {
          f.call(self);
          ev.preventDefault();
        }
        drag = 0;
        handlers.onpointermove( ev );
      };

      self.canvas.onpointerout = self.canvas.onpointerup;

      handlers.onpointermove = function ( ev ) {
        var coords = self.relMouseCoords(ev), sub, f;
        coords.y = self.canvas.height - coords.y;
        if (ev.buttons === 0) {
          activeSubscene = self.whichSubscene(coords);
          drag = "none";
          sub = self.getObj(activeSubscene);
          handler = sub.par3d.mouseMode.none;
          if (handler !== "none") {
            if (sub.needsBegin) {
              f = handlers[handler + "down"];
              if (f) {
                coords = self.translateCoords(activeSubscene, coords);
                f.call(self, coords.x, coords.y);
              }
              sub.needsBegin = 0;
            }
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.none);
          } else {
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.left);  
            return;
          }
        }
        f = handlers[handler + "move"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
        }
      };
      

      self.canvas.onpointerenter = function() {
        self.canvas.addEventListener("pointermove",               handlers.onpointermove);
      };
      
      self.canvas.onpointerleave = function() {
        self.canvas.removeEventListener("pointermove",
          handlers.onpointermove);
      };

      handlers.setZoom = function(ds) {
        var i;
        if (typeof activeSubscene === "undefined")
          activeSubscene = self.scene.rootSubscene;
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            l = activeProjection.par3d.listeners;

        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom *= ds;
        }
        self.drawScene();
      };
      
      handlers.pushwheel = function(ev) {
        ev.deltaY = -ev.deltaY;
        handlers.pullwheel(ev);
      };
      
      handlers.pullwheel = function(ev) {
        var del = 1.05;
        if (ev.shiftKey) del = 1.005;
        var ds = ev.deltaY < 0 ? del : (1 / del);
        handlers.setZoom(ds);
      };
      
      handlers.user2wheel = function(ev) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks.wheel.rotate;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
          fn.call(self, ev.deltaY < 0 ? 1 : 2);
        }        
      };
        
      handlers.wheelHandler = function(ev) {
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height - coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f,
            handler = sub.par3d.mouseMode.wheel,
            evlocal;
            
        ev.deltaY = ev.deltaY || ev.detail || ev.deltaX || ev.wheelDelta;
                      
        switch(handler) {
          case "none": break;
          case "push":
          case "pull":
          case "user2":
            f = handlers[handler + "wheel"];
            if (f) {
              evlocal = {};
              evlocal.deltaY = ev.deltaY;
              evlocal.shiftKey = ev.shiftKey;
              evlocal.preventDefault = function() { ev.preventDefault(); };
              f.call(self, evlocal);
            }
            break;
          default: 
            evlocal = {};
            evlocal.preventDefault = function() { ev.preventDefault(); };
            evlocal.which = 4;
            evlocal.clientX = self.canvas.width/2;
            evlocal.clientY = self.canvas.height/2;
            self.canvas.onpointerdown(evlocal);
            evlocal.clientX += ev.deltaX;
            evlocal.clientY += ev.deltaY;
            handlers.onpointermove(evlocal);
            self.canvas.onpointerup(evlocal);
        }
        ev.preventDefault();
      };
      
      handlers.get_finger_dist = function(ev) {
        var diffX = ev.touches[0].clientX - ev.touches[1].clientX,
            diffY = ev.touches[0].clientY - ev.touches[1].clientY;
        return Math.sqrt(diffX * diffX + diffY * diffY); 
      };
      
      handlers.touchstart = function(ev) {
        var touch = ev.touches[0],
          mouseEvent = new MouseEvent("pointerdown",
            {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
        ev.preventDefault();
        if (ev.touches.length === 2) {
          var coords = self.relMouseCoords(touch);
          coords.y = self.canvas.height-coords.y;
          activeSubscene = self.whichSubscene(coords);
          handlers.finger_dist0 = handlers.get_finger_dist(ev);
          handlers.zoomdown(coords.x, coords.y);
        }
        self.dispatchEvent(mouseEvent);
      };
      
      handlers.touchend = function(ev) {
        var mouseEvent;
        ev.preventDefault();
        if (ev.touches.length === 1) {
          mouseEvent = new MouseEvent("pointerup", {});
          self.dispatchEvent(mouseEvent);
        }
      };
      
      handlers.touchmove = function(ev) {
        var touch = ev.touches[0],
          mouseEvent;
        ev.preventDefault();
        if (ev.touches.length > 1) {
          var coords = self.relMouseCoords(touch),
              new_dist = handlers.get_finger_dist(ev);
          coords.y = self.canvas.height*Math.log(handlers.finger_dist0/new_dist) + handlers.y0zoom;
          handlers.zoommove(coords.x, coords.y);
        } else {
          mouseEvent = new MouseEvent("pointermove",
          {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          self.dispatchEvent(mouseEvent);
        }
      };

      self.canvas.addEventListener("DOMMouseScroll", handlers.wheelHandler, false);
      self.canvas.addEventListener("mousewheel", handlers.wheelHandler, false);
      self.canvas.addEventListener("touchstart", handlers.touchstart, {passive: false});
      self.canvas.addEventListener("touchend", handlers.touchend, {passive: false});
      self.canvas.addEventListener("touchmove", handlers.touchmove, {passive: false});
	  };
</script>
<script>    /**
     * Methods related to initialization
     * @name ___METHODS_FOR_INITIALIZATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Initial test for WebGL
     */
    rglwidgetClass.prototype.initGL0 = function() {
      if (!window.WebGLRenderingContext){
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org");
        return;
      }
    };

    /**
     * Initialize WebGL
     * @returns { Object } the WebGL context
     */
    rglwidgetClass.prototype.initGL = function() {
      var self = this, success = false;
      if (this.gl) {
      	if (!this.drawing && this.gl.isContextLost())
          this.restartCanvas();
        else
          return this.gl;
      }
      // if (!this.isInBrowserViewport()) return; Return what??? At this point we know this.gl is null.
      this.canvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      this.canvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      this.gl = this.canvas.getContext("webgl", this.webGLoptions) ||
               this.canvas.getContext("experimental-webgl", this.webGLoptions);
      success = !!(this.gl && this.gl instanceof WebGLRenderingContext);
      if (!success)
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org"); 
      this.index_uint = this.gl.getExtension("OES_element_index_uint");
      var save = this.startDrawing();
      Object.keys(this.scene.objects).forEach(function(key){
        self.initObjId(parseInt(key, 10));
        });
      this.stopDrawing(save);
      return this.gl;
    };

    /**
     * Resize the display to match element
     * @param { Object } el - DOM element to match
     */
    rglwidgetClass.prototype.resize = function(el) {
      this.canvas.width = el.width;
      this.canvas.height = el.height;
    };

    /**
     * Initialize the sphere object
     */
    rglwidgetClass.prototype.initSphere = function(sections, segments) {
      var v = [], phi = [], theta = [], it = [], centers = [],
           i, j, k, ind, result = {};
       
      for (i = 0; i <= sections; i++) {
        phi.push(i/sections - 0.5);
      }

      for (j = 0; j <= segments; j++) {
        theta.push(2*j/segments);
        for (i = 0; i <= sections; i++) {
          /* These are [x,y,z,s,t]: */
          v.push([Math.sin(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),
                  Math.sin(Math.PI*phi[i]),
                  Math.cos(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),                               
                  theta[j]/2,
                  phi[i] + 0.5]);
           // console.log("xyzst="+v[v.length-1]);
        }
      }
      result.values = new Float32Array(rglwidgetClass.flatten(v));
      result.vertexCount = v.length;
      
      for (j = 0; j < segments; j++) {
        for (i = 0; i < sections; i++) {
          ind = i + (sections + 1)*j;
          if (i > 0)                       // Not south pole
            it.push([ind, 
                     ind + sections + 1,
                     ind + 1]);
          if (i < sections - 1)             // Not north pole
            it.push([ind + sections + 1, 
                     ind + sections + 2,
                     ind + 1]);
        }
      }
      result.it = new Uint16Array(rglwidgetClass.flatten(it));
      
      for (i = 0; i < it.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 3; k++) {// vertices
            centers[i][j] += v[it[i][k]][j]/3;
          }
        }
      }
      result.centers = centers;
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:0, radofs:-1, oofs:-1,
                         tofs:3, nextofs:-1, pointofs:-1, stride:5};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "sphere";
      this.sphere = result;
      this.initShapeGL(this.sphere);
    };

    /**
     * Initialize the cube object
     */
    rglwidgetClass.prototype.initCube = function() {
   var v = [[0, 0, 0], [1, 0, 0], 
            [0, 1, 0], [1, 1, 0], 
            [0, 0, 1], [1, 0, 1],
            [0, 1, 1], [1, 1, 1]],
          ib = [[0, 2, 3, 1], 
                [2, 6, 7, 3], 
                [1, 3, 7, 5], 
                [0, 4, 6, 2], 
                [0, 1, 5, 4], 
                [4, 5, 7, 6]], 
          centers = [], i, j, k, 
          i0, i1, i2,
          normal, result = {};
       
      for (i = 0; i < ib.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 4; k++) {// vertices
            centers[i][j] += v[ib[i][k]][j]/4;
          }
        }
      }
      result.centers = centers; 
      result.values = new Float32Array(6*4*3*2);
      result.vertexCount = 24;
      result.vertices = new Array(24);
      result.normals = new Array(24);
      for (i=0; i < 6; i++) {
        for (j=0; j < 4; j++) {
          i0 = ib[i][j];
          result.vertices[4*i + j] = v[i0];
          i1 = ib[i][(j + 1) % 4];
          i2 = ib[i][(j + 2) % 4];
          if (j === 0)
            normal = rglwidgetClass.normalize(rglwidgetClass.xprod(rglwidgetClass.vdiff(v[i1], v[i0]),
                                  rglwidgetClass.vdiff(v[i2], v[i0])));
          result.normals[4*i + j] = normal;
          for (k=0; k < 3; k++) {
            result.values[i*24 + j*6 + k] = v[i0][k];
            result.values[i*24 + j*6 + 3 + k] = normal[k];
          }
        }
        for (j=0; j<4; j++)
          ib[i][j] = 4*i + j;
      }
      result.ib = new Uint16Array(rglwidgetClass.flatten(ib));
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:3, radofs:-1, oofs:-1,
                         tofs:-1, nextofs:-1, pointofs:-1, stride:6};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "quads";
      this.cube = result;
      this.initShapeGL(this.cube);
    };
    

    /**
     * Do the gl part of initializing the sphere and cube
     */
    rglwidgetClass.prototype.initShapeGL = function(shape) {
      var gl = this.gl || this.initGL();
      if (gl.isContextLost()) return;
      shape.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, shape.buf);
      gl.bufferData(gl.ARRAY_BUFFER, shape.values, gl.STATIC_DRAW);
      shape.ibuf = [gl.createBuffer(), gl.createBuffer()];
      return;
    };

    /* Initialize common sphere object from spheres object
    */
    rglwidgetClass.prototype.initShapeFromObj = function(shape, obj) {
      var i, pass, f, mode, self = this,
        /* This function selects things that would be
           the back, ignoring perspective -- this is what 
           we want for the bounding box decoration. */
        is_back = function(i) {
                var normal = [].concat(shape.normals[i]),
                  pt = shape.vertices[i];
                normal.push(-rglwidgetClass.dotprod(normal, pt));
                normal = rglwidgetClass.multVM(normal, self.normMatrix);
                return normal[2] < 0 || (normal[2] === 0 && normal[0] < 0);
              }; 
      shape.ofsLoc = obj.ofsLoc;
      shape.texLoc = obj.texLoc;
      shape.texture = obj.texture;
      shape.sampler = obj.sampler;
      shape.uFogMode = obj.uFogMode;
      shape.uFogColor = obj.uFogColor;
      shape.uFogParms = obj.uFogParms;
      shape.userAttribLocations = obj.userAttribLocations;
      shape.userUniformLocations = obj.userUniformLocations;
      shape.normLoc = obj.normLoc;
      shape.invPrMatLoc = obj.invPrMatLoc;
      shape.clipLoc = obj.clipLoc;
      shape.nextLoc = obj.nextLoc;
      shape.pointLoc = obj.pointLoc;
      shape.aspectLoc = obj.aspectLoc;
      shape.lwdLoc = obj.lwdLoc;
      shape.prog = obj.prog;
      shape.material = obj.material;
      shape.flags = obj.flags;
      shape.defFlags = obj.defFlags;
      shape.someHidden = obj.someHidden;
      shape.fastTransparency = obj.fastTransparency;
      shape.nlights = obj.nlights;
      shape.emission = obj.emission;
      shape.emissionLoc = obj.emissionLoc;
      shape.shininess = obj.shininess;
      shape.shininessLoc = obj.shininessLoc;
      shape.ambient = obj.ambient;
      shape.ambientLoc = obj.ambientLoc;
      shape.specular = obj.specular;
      shape.specularLoc = obj.specularLoc;
      shape.diffuse = obj.diffuse;
      shape.diffuseLoc = obj.diffuseLoc;
      shape.lightDir = obj.lightDir;
      shape.lightDirLoc = obj.lightDirLoc;
      shape.viewpoint = obj.viewpoint;
      shape.viewpointLoc = obj.viewpointLoc;
      shape.finite = obj.finite;
      shape.finiteLoc = obj.finiteLoc;
      shape.prMatLoc = obj.prMatLoc;
      shape.mvMatLoc = obj.mvMatLoc;
      shape.normMatLoc = obj.normMatLoc;
      shape.frontLoc = obj.frontLoc;
      shape.index_uint = false;
      shape.is_transparent = obj.is_transparent;
      shape.ignoreExtent = obj.ignoreExtent;
      if (shape.passes !== obj.passes ||
          JSON.stringify( shape.pmode) !== JSON.stringify(obj.pmode)) {
        shape.passes = obj.passes;
        shape.pmode = obj.pmode;
        for (pass = 0; pass < obj.passes; pass++) {
          mode =  shape.pmode[pass];
          if (typeof  shape.indices[mode] === "undefined") {
            f = [];
            switch (mode) {
            case "culled": break;
            case "points":
              f.length =  shape.vertexCount;
              for (i=0; i < f.length; i++)
                f[i] = i;
              break;
            case "lines":
              if (typeof shape.it !== "undefined") {
                f.length = 2* shape.it.length;
      	        for (i=0; i <  shape.it.length/3; i++) {
      	          f[6*i] =  shape.it[3*i];
      	          f[6*i + 1] =  shape.it[3*i + 1];
      	          f[6*i + 2] =  shape.it[3*i + 1];
      	          f[6*i + 3] =  shape.it[3*i + 2];
      	          f[6*i + 4] =  shape.it[3*i + 2];
      	          f[6*i + 5] =  shape.it[3*i];
      	        }
              } else {
                f.length = 2*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[8*i] = shape.ib[4*i];
                  f[8*i + 1] = shape.ib[4*i + 1];
                  f[8*i + 2] = shape.ib[4*i + 1];
                  f[8*i + 3] = shape.ib[4*i + 2];
                  f[8*i + 4] = shape.ib[4*i + 2];
                  f[8*i + 5] = shape.ib[4*i + 3];
                  f[8*i + 6] = shape.ib[4*i + 3];
                  f[8*i + 7] = shape.ib[4*i];
                }
              }
      	      break;
      	    case "filled":
      	      if (typeof shape.it !== "undefined")
      	        f =  shape.it;
      	      else if (typeof shape.ib !== "undefined") {
      	        f.length = 1.5*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[6*i] = shape.ib[4*i];
                  f[6*i+1] = shape.ib[4*i + 1];
                  f[6*i+2] = shape.ib[4*i + 2];
                  f[6*i+3] = shape.ib[4*i];
                  f[6*i+4] = shape.ib[4*i + 2];
                  f[6*i+5] = shape.ib[4*i + 3];
                }      	        
      	      }
      	      break;
      	    }              
            shape.indices[mode] = new Uint16Array(f);
          }
        }
      }       
      for (pass = 0; pass < obj.passes; pass++) {
        mode =  shape.pmode[pass];
        shape.f[pass] =  shape.indices[mode];
        if (typeof obj.draw_front !== "undefined" &&
            !obj.draw_front) {
          shape.f[pass] = shape.f[pass].filter(is_back);   
        }
      }
      // console.log("Names in  shapes not in  shape:"+JSON.stringify(rglwidgetClass.keydiff(obj,  shape)));
       shape.initialized = true;
    };

    /**
     * Initialize a subscene
     * @param { number } id - id of subscene.
     */
    rglwidgetClass.prototype.initSubscene = function(id) {
      var sub = this.getObj(id),
          i, obj;

      if (sub.type !== "subscene")
        return;

      sub.par3d.userMatrix = this.toCanvasMatrix4(sub.par3d.userMatrix);
      sub.par3d.userProjection = this.toCanvasMatrix4(sub.par3d.userProjection);
      sub.par3d.userProjection.transpose();
      sub.par3d.listeners = [].concat(sub.par3d.listeners);
      sub.backgroundId = undefined;
      sub.subscenes = [];
      sub.clipplanes = [];
      sub.transparent = [];
      sub.opaque = [];
      sub.lights = [];
      sub.needsBegin = true;
      if (typeof sub.objects !== "undefined")
        sub.objects = [].concat(sub.objects); /* make sure it's an array */
      for (i=0; i < sub.objects.length; i++) {
        obj = this.getObj(sub.objects[i]);
        if (typeof obj === "undefined") {
          sub.objects.splice(i, 1);
          i--;
        } else if (obj.type === "background")
          sub.backgroundId = obj.id;
        else
          sub[this.whichList(obj.id)].push(obj.id);
      }
    };
    
    rglwidgetClass.prototype.initBBox = function(obj) {
      if (!this.cube)
        this.initCube();
      obj.cube = {id: obj.id + 0.1,
                    type: "quads",
                    flags: obj.flags,
                    material: obj.material,
                    colors: [obj.colors[0]],
                    vertices: this.cube.vertices,
                    normals: this.cube.normals,
                    draw_front: obj.draw_front,
                    initialized: false
        };
      if (this.getMaterial(obj.cube, "front") !==
          this.getMaterial(obj.cube, "back"))
        /* jshint bitwise: false */  
        obj.cube.flags |= rglwidgetClass.f_is_twosided;
        /* jshint bitwise: true */
      this.scene.objects[obj.cube.id] = obj.cube;
      obj.ticks = {id: obj.id + 0.2,
                     type: "lines",
                     flags: rglwidgetClass.f_has_fog,
                     material: obj.material,
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     axes: obj.axes,
                     initialized: false
      };
      this.scene.objects[obj.ticks.id] = obj.ticks;
      obj.labels = {id: obj.id + 0.3,
                     type: "text",
                     flags: rglwidgetClass.f_has_fog + 
                            rglwidgetClass.f_fixed_size + 
                            rglwidgetClass.f_fixed_quads,
                     material: {lit: false},
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     cex: [[1]],
                     family: [["sans"]],
                     font: [[1]],
                     adj: [[0.5, 0.5, 0.5]],
                     ignoreExtent: true,
                     initialized: false
      };
      this.scene.objects[obj.labels.id] = obj.labels;
      obj.initialized = true;
    };
    
    rglwidgetClass.prototype.initBackground = function(obj) {
      var material, fl = obj.defFlags;
      if (typeof obj.ids !== "undefined")
        obj.quad = rglwidgetClass.flatten([].concat(obj.ids));
      else if (obj.sphere) {
        fl.has_normals = true;
        fl.needs_vnormal = true;
        obj.defFlags = fl;
        material = obj.material;
        material.front = "culled";
        obj.vertices = [[0,0,0]];
        obj.texcoords = [[0,0]];
      }  
    };

    /**
     * Initialize object for display
     * @param { number } id - id of object to initialize
     */
    rglwidgetClass.prototype.initObjId = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("initObj id is "+typeof id);
      }
      return this.initObj(this.getObj(id));
    };

    /**
     * Initialize object for display
     * @param { Object } obj - object to initialize
     */
    rglwidgetClass.prototype.initObj = function(obj) {
      var type = obj.type, 
          flags = obj.flags,
          normals = obj.normals,
          round_points = (typeof obj.material === "undefined") ?
            false : this.getMaterial(obj, "point_antialias"),
          has_indices = typeof obj.indices !== "undefined",
          has_spheres = type === "spheres" || 
                        (type === "background" && obj.sphere),
          sprites_3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          depth_sort = rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort),
          gl = this.gl || this.initGL(),
          fl, polygon_offset,
          texinfo, drawtype, nclipplanes, f, nrows, oldrows,
          i,j,v,v1,v2, mat, uri, matobj, pass, pmode,
          dim, nx, nz, nrow, shaders;

    obj.initialized = true;
    
    obj.someHidden = false; // used in selection
    
    this.expandBufferedFields(obj);
    
    if (type === "subscene")
      return;
      
    obj.defFlags = fl = rglwidgetClass.getDefFlags(flags, type, normals, round_points);
  
    obj.is_transparent = fl.is_transparent;
  
    if (type === "bboxdeco")
      return this.initBBox(obj);
      
    if (has_spheres && typeof this.sphere === "undefined")
      this.initSphere(16, 16);

    if (type === "light") {
      obj.ambient = new Float32Array(obj.colors[0].slice(0,3));
      obj.diffuse = new Float32Array(obj.colors[1].slice(0,3));
      obj.specular = new Float32Array(obj.colors[2].slice(0,3));
      obj.lightDir = new Float32Array(obj.vertices[0]);
      return;
    }

    if (type === "clipplanes") {
      obj.vClipplane = rglwidgetClass.flatten(rglwidgetClass.cbind(obj.normals, obj.offsets));
      return;
    }

    if (type === "background") {
      this.initBackground(obj);
      if (!obj.sphere)
        return;
    }

    polygon_offset = this.getMaterial(obj, "polygon_offset");
    if (polygon_offset[0] !== 0 || polygon_offset[1] !== 0)
      obj.polygon_offset = polygon_offset;

    if (fl.is_transparent) {
      depth_sort = ["triangles", "quads", "surface",
                    "spheres", "sprites", "text",
                    "planes"].indexOf(type) >= 0;
    }
    
    if (fl.is_brush)
      this.initSelection(obj.id);

    if (typeof obj.vertices === "undefined")
      obj.vertices = [];

    v = obj.vertices;
    if (has_indices)
      obj.vertexCount = obj.indices.length;
    else
      obj.vertexCount = v.length;
      
    if (!obj.vertexCount) return;

    if (fl.is_twosided && !fl.has_normals && type !== "background") {
      if (typeof obj.userAttributes === "undefined")
        obj.userAttributes = {};
      v1 = Array(v.length);
      v2 = Array(v.length);
      if (obj.type === "triangles" || obj.type === "quads") {
      	if (obj.type === "triangles")
      	  nrow = 3;
      	else
      	  nrow = 4;
        for (i=0; i<Math.floor(v.length/nrow); i++)
          for (j=0; j<nrow; j++) {
            v1[nrow*i + j] = v[nrow*i + ((j+1) % nrow)];
            v2[nrow*i + j] = v[nrow*i + ((j+2) % nrow)];
          }
      } else if (obj.type === "surface") {
        dim = obj.dim[0];
        nx = dim[0];
        nz = dim[1];
        for (j=0; j<nx; j++) {
          for (i=0; i<nz; i++) {
            if (i+1 < nz && j+1 < nx) {
              v2[j + nx*i] = v[j + nx*(i+1)];
              v1[j + nx*i] = v[j+1 + nx*(i+1)];
            } else if (i+1 < nz) {
              v2[j + nx*i] = v[j-1 + nx*i];
              v1[j + nx*i] = v[j + nx*(i+1)];
            } else {
              v2[j + nx*i] = v[j + nx*(i-1)];
              v1[j + nx*i] = v[j-1 + nx*(i-1)];
            }
          }
        }
      }
      obj.userAttributes.aPos1 = v1;
      obj.userAttributes.aPos2 = v2;
    }

    if (!sprites_3d) {
      if (gl.isContextLost()) return;
      if (typeof obj.prog !== "undefined") {
        gl.deleteProgram(obj.prog);
        obj.prog = undefined;
      }
      
      shaders = this.getShaders(obj);
      
      obj.prog = gl.createProgram();
      gl.attachShader(obj.prog, this.getShader( gl.VERTEX_SHADER,
                      shaders.vertex ));
      gl.attachShader(obj.prog, this.getShader( gl.FRAGMENT_SHADER,
                      shaders.fragment ));
      //  Force aPos to location 0, aCol to location 1
      gl.bindAttribLocation(obj.prog, 0, "aPos");
      gl.bindAttribLocation(obj.prog, 1, "aCol");
      gl.linkProgram(obj.prog);
      var linked = gl.getProgramParameter(obj.prog, gl.LINK_STATUS);
      if (!linked) {

        // An error occurred while linking
        var lastError = gl.getProgramInfoLog(obj.prog);
        console.warn("Error in program linking:" + lastError);

        gl.deleteProgram(obj.prog);
        return;
      }
    }

    if (type === "text") {
      texinfo = this.drawTextToCanvas(obj.texts,
                                      rglwidgetClass.flatten(obj.cex),
                                      rglwidgetClass.flatten(obj.family),
                                      rglwidgetClass.flatten(obj.family));
    }

    if (fl.fixed_quads && !sprites_3d) {
      obj.ofsLoc = gl.getAttribLocation(obj.prog, "aOfs");
    }

    if (fl.has_texture || type === "text") {
      if (!obj.texture) {
        obj.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
      }
      obj.texLoc = gl.getAttribLocation(obj.prog, "aTexcoord");
      obj.sampler = gl.getUniformLocation(obj.prog, "uSampler");
    }
    
    if (fl.has_fog && !sprites_3d) {
      obj.uFogMode = gl.getUniformLocation(obj.prog, "uFogMode");
      obj.uFogColor = gl.getUniformLocation(obj.prog, "uFogColor");
      obj.uFogParms = gl.getUniformLocation(obj.prog, "uFogParms");
    }

    if (fl.has_texture) {
      mat = obj.material;
      if (typeof mat.uri !== "undefined")
        uri = mat.uri;
      else if (typeof mat.uriElementId === "undefined") {
        matobj = this.getObj(mat.uriId);
        if (typeof matobj !== "undefined") {
          uri = matobj.material.uri;
        } else {
          uri = "";
        }
      } else
        uri = document.getElementById(mat.uriElementId).rglinstance.getObj(mat.uriId).material.uri;

      this.loadImageToTexture(uri, obj.texture);
    }

    if (type === "text") {
      this.handleLoadedTexture(obj.texture, this.textureCanvas);
    }

    var stride = 3, nc, cofs, nofs, radofs, oofs, tofs, vnew, fnew,
        nextofs = -1, pointofs = -1, alias, colors, key, selection,
        filter, adj, offset, attr, last, options;

    obj.alias = undefined;
    
    colors = obj.colors;

    j = this.scene.crosstalk.id.indexOf(obj.id);
    if (j >= 0) {
      key = this.scene.crosstalk.key[j];
      options = this.scene.crosstalk.options[j];
      colors = colors.slice(0); 
      for (i = 0; i < v.length; i++)
        colors[i] = obj.colors[i % obj.colors.length].slice(0);
      if ( (selection = this.scene.crosstalk.selection) &&
           (selection.length || !options.selectedIgnoreNone) )
        for (i = 0; i < v.length; i++) {
          if (!selection.includes(key[i])) {
            if (options.deselectedColor)
              colors[i] = options.deselectedColor.slice(0);
            colors[i][3] = colors[i][3]*options.deselectedFade;   /* default: mostly transparent if not selected */
          } else if (options.selectedColor)
            colors[i] = options.selectedColor.slice(0);
        }
      if ( (filter = this.scene.crosstalk.filter) )
        for (i = 0; i < v.length; i++) 
          if (!filter.includes(key[i])) {
            if (options.filteredColor)
              colors[i] = options.filteredColor.slice(0);
            colors[i][3] = colors[i][3]*options.filteredFade;   /* default: completely hidden if filtered */
          }
    }  
    
    nc = obj.colorCount = colors.length;
    if (nc > 1) {
      cofs = stride;
      stride = stride + 4;
      v = rglwidgetClass.cbind(v, colors);
    } else {
      cofs = -1;
      obj.onecolor = rglwidgetClass.flatten(colors);
    }

    if (fl.has_normals && !has_spheres) {
      nofs = stride;
      stride = stride + 3;
      v = rglwidgetClass.cbind(v, typeof obj.pnormals !== "undefined" ? obj.pnormals : obj.normals);
    } else
      nofs = -1;

    if (typeof obj.radii !== "undefined") {
      radofs = stride;
      stride = stride + 1;
      // FIXME:  always concat the radii?
      if (obj.radii.length === v.length) {
        v = rglwidgetClass.cbind(v, obj.radii);
      } else if (obj.radii.length === 1) {
        v = v.map(function(row) { return row.concat(obj.radii[0]);});
      }
    } else
      radofs = -1;
      
    // Add default indices
    if (has_indices) {
      f = Array(obj.indices.length);
      for (i = 0; i < f.length; i++)
        f[i] = obj.indices[i] - 1;
    } else {
      f = Array(v.length);
      for (i = 0; i < v.length; i++)
        f[i] = i;
    }
    obj.f = [f,f];

    if (type === "sprites" && !sprites_3d) {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      fnew = new Array(4*v.length);
      alias = new Array(v.length);
      var rescale = fl.fixed_size ? 72 : 1,
          size = obj.radii, s = rescale*size[0]/2;
      last = v.length;
      f = obj.f[0];
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = obj.adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset);
        if (size.length > 1)
          s = rescale*size[i]/2;
        adj[0] = 2*s*(adj[0] - 0.5);
        adj[1] = 2*s*(adj[1] - 0.5);
        adj[2] = 2*s*(adj[2] - 0.5);
        vnew[i]  = v[i].concat([0,0]).concat([-s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i] = f[i];
        vnew[last]= v[i].concat([1,0]).concat([s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i+1] = last++;
        vnew[last]= v[i].concat([1,1]).concat([s-adj[0],
                                               s-adj[1],
                                               -adj[2]]);
        fnew[4*i+2] = last++;
        vnew[last]= v[i].concat([0,1]).concat([-s-adj[0],
                                                s-adj[1],
                                                -adj[2]]);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (type === "text") {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      f = obj.f[0];
      fnew = new Array(4*f.length);
      alias = new Array(v.length);
      last = v.length;
      adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset, obj.texts[i]);
        vnew[i]  = v[i].concat([0,-0.5]).concat(adj);
        fnew[4*i] = f[i];
        vnew[last] = v[i].concat([1,-0.5]).concat(adj);
        fnew[4*i+1] = last++;
        vnew[last] = v[i].concat([1, 1.5]).concat(adj);
        fnew[4*i+2] = last++;
        vnew[last] = v[i].concat([0, 1.5]).concat(adj);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
        for (j=0; j < 4; j++) {
          v1 = vnew[fnew[4*i+j]];
          v1[oofs] = 2*(v1[tofs]-v1[oofs])*texinfo.widths[i];
          v1[oofs+1] = 2*(v1[tofs+1]-v1[oofs+1])*texinfo.textHeights[i];
          v1[oofs+2] = 2*(0.5-v1[oofs+2])*texinfo.textHeights[i]/1000.0;
          v1[tofs] = (texinfo.offsetsx[i] + v1[tofs]*texinfo.widths[i])/texinfo.canvasX;
          v1[tofs+1] = 1.0-(texinfo.offsetsy[i] -
              v1[tofs+1]*texinfo.textHeights[i])/texinfo.canvasY;
          vnew[fnew[4*i+j]] = v1;
        }
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (typeof obj.texcoords !== "undefined") {
      tofs = stride;
      stride += 2;
      oofs = -1;
      v = rglwidgetClass.cbind(v, obj.texcoords);
    } else {
      tofs = -1;
      oofs = -1;
    }
    
    obj.alias = alias;
                          
    if (typeof obj.userAttributes !== "undefined") {
      obj.userAttribOffsets = {};
      obj.userAttribLocations = {};
      obj.userAttribSizes = {};
      for (attr in obj.userAttributes) {
      	obj.userAttribLocations[attr] = gl.getAttribLocation(obj.prog, attr);
      	if (obj.userAttribLocations[attr] >= 0) { // Attribute may not have been used
      	  obj.userAttribOffsets[attr] = stride;
      	  v = rglwidgetClass.cbind(v, obj.userAttributes[attr]);
      	  stride = v[0].length;
      	  obj.userAttribSizes[attr] = stride - obj.userAttribOffsets[attr];
      	} else
      	  console.warn("attribute '"+attr+"' not found in object "+obj.id+".");
      }
    }

    if (typeof obj.userUniforms !== "undefined" ||
        typeof obj.userTextures !== "undefined") {
      obj.userUniformLocations = {};
      for (attr in obj.userUniforms) {
        obj.userUniformLocations[attr] = gl.getUniformLocation(obj.prog, attr);
        if (obj.userUniformLocations[attr] === null)
          console.warn("uniform '"+attr+"' not found in object "+obj.id+".");
      }
      for (attr in obj.userTextures) {
        var texture = obj.userTextures[attr];
        texture.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
        texture.sampler = gl.getUniformLocation(obj.prog, attr);
        if (texture.sampler === null)
          console.warn("sampler '"+attr+"' not found in object "+obj.id+".");
        uri = texture.uri;
        this.loadImageToTexture(uri, texture.texture);
      }
    }

    if (sprites_3d) {
      obj.userMatrix = new CanvasMatrix4();
      obj.userMatrix.load(rglwidgetClass.flatten(obj.usermatrix));
      obj.objects = rglwidgetClass.flatten([].concat(obj.ids));
      fl.is_lit = false;
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        obj.offset = obj.adj[0];
      } else
        obj.offset = 0;
        
      for (i=0; i < obj.objects.length; i++)
        this.initObjId(obj.objects[i]);
    }

    nclipplanes = this.countClipplanes();
    if (nclipplanes && !sprites_3d) {
      obj.clipLoc = gl.getUniformLocation(obj.prog,"vClipplane");
    }

    if (fl.is_lit) {
      obj.emissionLoc = gl.getUniformLocation(obj.prog, "emission");
      obj.emission = new Float32Array(this.stringToRgb(this.getMaterial(obj, "emission")));
      obj.shininessLoc = gl.getUniformLocation(obj.prog, "shininess");
      obj.shininess = this.getMaterial(obj, "shininess");
      obj.nlights = this.countLights();
      if (obj.nlights > 0) {
        obj.ambient = new Float32Array(this.stringToRgb(this.getMaterial(obj, "ambient")));
        obj.specular = new Float32Array(this.stringToRgb(this.getMaterial(obj, "specular")));
        obj.ambientLoc = gl.getUniformLocation(obj.prog, "ambient");
        obj.specularLoc = gl.getUniformLocation(obj.prog, "specular");
        obj.diffuseLoc = gl.getUniformLocation(obj.prog, "diffuse" );
        obj.lightDirLoc = gl.getUniformLocation(obj.prog, "lightDir");
        obj.viewpointLoc = gl.getUniformLocation(obj.prog, "viewpoint");
        obj.finiteLoc = gl.getUniformLocation(obj.prog, "finite" );
      }
    }
    
    obj.passes = fl.is_twosided + 1;
    obj.pmode = new Array(obj.passes);
    for (pass = 0; pass < obj.passes; pass++) {
      if (type === "triangles" || type === "quads" || type === "surface" || has_spheres)
      	pmode = this.getMaterial(obj, (pass === 0) ? "front" : "back");
      else pmode = "filled";
      obj.pmode[pass] = pmode;
    }
    if (!has_spheres) {
      obj.f.length = obj.passes;
      for (pass = 0; pass < obj.passes; pass++) {
      	f = fnew = obj.f[pass];
        pmode = obj.pmode[pass];
      	if (pmode === "culled")
      	  fnew = [];
        else if (pmode === "points") {
          // stay with default
        } else if ((type === "quads" || type === "text" ||
             type === "sprites") && !sprites_3d) {
          nrows = Math.floor(obj.vertexCount/4);
          if (pmode === "filled") {
            fnew = Array(6*nrows);
            for (i=0; i < nrows; i++) {
              fnew[6*i] = f[4*i];
              fnew[6*i+1] = f[4*i + 1];
              fnew[6*i+2] = f[4*i + 2];
              fnew[6*i+3] = f[4*i];
              fnew[6*i+4] = f[4*i + 2];
              fnew[6*i+5] = f[4*i + 3];
            }
          } else {
            fnew = Array(8*nrows);
            for (i=0; i < nrows; i++) {
              fnew[8*i] = f[4*i];
              fnew[8*i+1] = f[4*i + 1];
              fnew[8*i+2] = f[4*i + 1];
              fnew[8*i+3] = f[4*i + 2];
              fnew[8*i+4] = f[4*i + 2];
              fnew[8*i+5] = f[4*i + 3];
              fnew[8*i+6] = f[4*i + 3];
              fnew[8*i+7] = f[4*i];
            }
          }
        } else if (type === "triangles") {
          nrows = Math.floor(obj.vertexCount/3);
          if (pmode === "filled") {
            fnew = Array(3*nrows);
            for (i=0; i < fnew.length; i++) {
              fnew[i] = f[i];
            }
          } else if (pmode === "lines") {
            fnew = Array(6*nrows);
      	    for (i=0; i < nrows; i++) {
      	      fnew[6*i] = f[3*i];
      	      fnew[6*i + 1] = f[3*i + 1];
      	      fnew[6*i + 2] = f[3*i + 1];
      	      fnew[6*i + 3] = f[3*i + 2];
      	      fnew[6*i + 4] = f[3*i + 2];
      	      fnew[6*i + 5] = f[3*i];
      	    }
          }
        } else if (has_spheres) {
          // default
        } else if (type === "surface") {
          dim = obj.dim[0];
          nx = dim[0];
          nz = dim[1];
          if (pmode === "filled") {
            fnew = [];
            for (j=0; j<nx-1; j++) {
              for (i=0; i<nz-1; i++) {
                fnew.push(f[j + nx*i],
                       f[j + nx*(i+1)],
                       f[j + 1 + nx*(i+1)],
                       f[j + nx*i],
                       f[j + 1 + nx*(i+1)],
                       f[j + 1 + nx*i]);
              }
            }
          } else if (pmode === "lines") {
            fnew = [];
            for (j=0; j<nx; j++) {
              for (i=0; i<nz; i++) {
                if (i+1 < nz)
                  fnew.push(f[j + nx*i],
                         f[j + nx*(i+1)]);
                if (j+1 < nx)
                  fnew.push(f[j + nx*i],
                         f[j+1 + nx*i]);
              }
            }
          }
        }
        obj.f[pass] = fnew;
        if (depth_sort) {
          drawtype = "DYNAMIC_DRAW";
        } else {
          drawtype = "STATIC_DRAW";
        }
      }
    }
    
    if (fl.fat_lines) {
      alias = undefined;
      obj.nextLoc = gl.getAttribLocation(obj.prog, "aNext");
      obj.pointLoc = gl.getAttribLocation(obj.prog, "aPoint");
      obj.aspectLoc = gl.getUniformLocation(obj.prog, "uAspect");
      obj.lwdLoc = gl.getUniformLocation(obj.prog, "uLwd");
      // Expand vertices to turn each segment into a pair of triangles
        
      	for (pass = 0; pass < obj.passes; pass++) {
      	  f = obj.f[pass];	
          oldrows = f.length;
      	  if (obj.pmode[pass] === "lines") 
      	    break;
      	}
      
      if (type === "linestrip") 
        nrows = 4*(oldrows - 1); 
      else
        nrows = 2*oldrows;
      vnew = new Array(nrows);
      fnew = new Array(1.5*nrows);
      
      // We're going to turn each pair of vertices into 4 new ones, with the "next" and "pt" attributes
      // added.
      // We do this by copying the originals in the first pass, adding the new attributes, then in a 
      // second pass add new vertices at the end.

      for (i = 0; i < v.length; i++) {
        vnew[i] = v[i].concat([0,0,0,0,0]); 
      }

      nextofs = stride;
      pointofs = stride + 3;
      stride = stride + 5;
            
      // Now add the extras
      var ind, k;
      last = v.length - 1;
      ind = 0;
      alias = new Array(f.length);
      for (i = 0; i < f.length; i++)
        alias[i] = [];
      for (i = 0; i < f.length - 1; i++) {
      	if (type !== "linestrip" && i % 2 === 1)
      	  continue;
      	k = ++last;
      	vnew[k] = vnew[f[i]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i+1]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = -1;
      	fnew[ind] = k;
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+1] = last;
      	alias[f[i]].push(last-1, last);
      	last++;
      	k = last;
      	vnew[k] = vnew[f[i+1]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = 1;
      	fnew[ind+2] = k;
      	fnew[ind+3] = fnew[ind+1];
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+4] = last;
      	fnew[ind+5] = fnew[ind+2];
      	ind += 6;
      	alias[f[i+1]].push(last-1, last);
      }
      vnew.length = last+1;
      v = vnew;
      obj.vertexCount = v.length;
      if (typeof alias !== "undefined" && typeof obj.alias !== "undefined") {  // Already have aliases from previous section?
        var oldalias = obj.alias, newalias = Array(obj.alias.length);
        for (i = 0; i < newalias.length; i++) {
          newalias[i] = oldalias[i].slice();
          for (j = 0; j < oldalias[i].length; j++)
            Array.prototype.push.apply(newalias[i], alias[oldalias[j]]); // pushes each element 
        }
        obj.alias = newalias;
      } else
        obj.alias = alias;
      
      for (pass = 0; pass < obj.passes; pass++)
      	if (type === "lines" || type === "linestrip" || obj.pmode[pass] === "lines") {
          obj.f[pass] = fnew;
        }
      
      if (depth_sort) 
        drawtype = "DYNAMIC_DRAW";
      else
        drawtype = "STATIC_DRAW";
    }
    
      for (pass = 0; pass < obj.passes; pass++) {
        if (obj.vertexCount > 65535) {
          if (this.index_uint) {
            obj.f[pass] = new Uint32Array(obj.f[pass]);
            obj.index_uint = true;
          } else
            this.alertOnce("Object has "+obj.vertexCount+" vertices, not supported in this browser.");
        } else {
          obj.f[pass] = new Uint16Array(obj.f[pass]);
          obj.index_uint = false;
        }
      }
    
    if (stride !== v[0].length) {
      this.alertOnce("problem in stride calculation");
    }

    obj.vOffsets = {vofs:0, cofs:cofs, nofs:nofs, radofs:radofs, oofs:oofs, tofs:tofs,
                    nextofs:nextofs, pointofs:pointofs, stride:stride};

    obj.values = new Float32Array(rglwidgetClass.flatten(v));

    if (!has_spheres && !sprites_3d) {
      obj.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
      gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW); //
      obj.ibuf = Array(obj.passes);
      obj.ibuf[0] = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[0]);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[0], gl[drawtype]);
      if (fl.is_twosided) {
      	obj.ibuf[1] = gl.createBuffer();
      	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[1]);
      	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[1], gl[drawtype]);
      }
    }

    if (!sprites_3d) {
      obj.mvMatLoc = gl.getUniformLocation(obj.prog, "mvMatrix");
      obj.prMatLoc = gl.getUniformLocation(obj.prog, "prMatrix");

      if (fl.fixed_size) {
        obj.textScaleLoc = gl.getUniformLocation(obj.prog, "textScale");
      }
    }

    if (fl.needs_vnormal) {
      obj.normLoc = gl.getAttribLocation(obj.prog, "aNorm");
      obj.normMatLoc = gl.getUniformLocation(obj.prog, "normMatrix");
    }

    if (fl.is_twosided) {
      obj.frontLoc = gl.getUniformLocation(obj.prog, "front");
      if (fl.has_normals)
        obj.invPrMatLoc = gl.getUniformLocation(obj.prog, "invPrMatrix");
    }
  };
    
    /**
     * Initialize the DOM object
     * @param { Object } el - the DOM object
     * @param { Object } x - the scene data sent by JSON from R
     */
    rglwidgetClass.prototype.initialize = function(el, x) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.style.display = "block";
      this.scene = x;
      this.normMatrix = new CanvasMatrix4();
      this.invPrMatrix = new CanvasMatrix4();
      this.saveMat = {};
      this.distance = null;
      this.posLoc = 0;
      this.colLoc = 1;
      if (el) {
        el.rglinstance = this;
        this.el = el;
        this.webGLoptions = el.rglinstance.scene.webGLoptions;
        this.initCanvas();
      }
      if (typeof Shiny !== "undefined") {
        var self = this;
        Shiny.addCustomMessageHandler("shinyGetPar3d",
          function(message) {
            var i, param, 
                subscene = self.getObj(message.subscene),
                parameters = [].concat(message.parameters),
                result = {tag: message.tag, subscene: message.subscene};
            if (typeof subscene !== "undefined") {
              for (i = 0; i < parameters.length; i++) {
                param = parameters[i];
                result[param] = subscene.par3d[param];
              }
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
            Shiny.setInputValue("par3d:shinyPar3d", result, {priority: "event"});
          });
          
        Shiny.addCustomMessageHandler("shinySetPar3d",
          function(message) {
            var param = message.parameter, 
                subscene = self.getObj(message.subscene);
            if (typeof subscene !== "undefined") {
              subscene.par3d[param] = message.value;
              subscene.initialized = false;
              self.drawScene();
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
          });
          
        Shiny.addCustomMessageHandler("resetBrush",
          function(message) {
            if (message === self.scene.selectionInput) {
              self.clearBrush(null);
              self.recordSelection(0);
            }
          });
      }
    };
    
    /**
     * Restart the WebGL canvas
     */
    rglwidgetClass.prototype.restartCanvas = function() {
      var newcanvas = document.createElement("canvas"),
          self = this, 
          labelid = this.el.getAttribute("aria-labelledby");
      newcanvas.width = this.el.width;
      newcanvas.height = this.el.height;
      newcanvas.setAttribute("aria-labelledby", 
        labelid);
        
      if (typeof this.scene.altText !== "undefined")
        // We're in Shiny, so alter the label
        document.getElementById(labelid).innerHTML = this.scene.altText;

      newcanvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      newcanvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      while (this.el.firstChild) {
        this.el.removeChild(this.el.firstChild);
      }
      this.el.appendChild(newcanvas);
      this.canvas = newcanvas;
      if (this.scene.javascript) {
        /* jshint evil:true */
        Function('"use strict";' + this.scene.javascript)();
        /* jshint evil:false */
      }
      this.setMouseHandlers();
      if (this.gl) 
        Object.keys(this.scene.objects).forEach(function(key){
          self.getObj(parseInt(key, 10)).texture = undefined; 
          });
      this.gl = null;
    };

    /**
     * Initialize the WebGL canvas
     */
    rglwidgetClass.prototype.initCanvas = function() {
      this.restartCanvas();
      var objs = this.scene.objects,
          self = this;
          
      /* These hold context specific data.  In Shiny, they   
         need to be deleted.  Elsewhere, they don't exist
         and these are no-ops. */
         
      delete this.cube;
      delete this.sphere;
      
      Object.keys(objs).forEach(function(key){
        self.initSubscene(parseInt(key, 10));
      });

      this.onContextRestored = function() {
        self.initGL();
        self.drawScene();
      };

      this.onContextLost = function(event) {
        if (!self.drawing)
          this.gl = null;
        event.preventDefault();
      };

      this.initGL0();
      this.lazyLoadScene = function() {
      	if (typeof self.slide === "undefined")
      	  self.slide = self.getSlide();
      	if (self.isInBrowserViewport()) {
      	  if (!self.gl || self.gl.isContextLost())
      	    self.initGL();
      	  self.drawScene();
      	}
      };
      window.addEventListener("DOMContentLoaded", this.lazyLoadScene, false);
      window.addEventListener("load", this.lazyLoadScene, false);
      window.addEventListener("resize", this.lazyLoadScene, false);
      window.addEventListener("scroll", this.lazyLoadScene, false);
      this.slide = this.getSlide();
      if (this.slide) {
        if (typeof this.slide.rgl === "undefined")
          this.slide.rgl = [this];
        else
          this.slide.rgl.push(this);
        if (this.scene.context.rmarkdown) 
          if (this.scene.context.rmarkdown === "ioslides_presentation") {
            this.slide.setAttribute("slideenter", "this.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window);})");
          } else if (this.scene.context.rmarkdown === "slidy_presentation") {
            // This method would also work in ioslides, but it gets triggered
            // something like 5 times per slide for every slide change, so
            // you'd need a quicker function than lazyLoadScene.
            var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
            observer = new MutationObserver(function(mutations) {
              mutations.forEach(function() {
                self.slide.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window); });});});
            observer.observe(this.slide, { attributes: true, attributeFilter:["class"] });
          }
      }
    };
</script>
<script>/**
 * Methods related to drawing transparent objects
 * @name ___METHODS_FOR_TRANSPARENCY___
 * @memberof rglwidgetClass
 * @kind function
 * @instance

 * These functions order the centers of displayed objects so they
 * can be drawn using the painters algorithm, necessary to support
 * transparency.  

 * Note that objid is not obj.id when drawing spheres.
 */

/**
 * Break objects into pieces
 * @returns { array } Array of pieces
 */
    rglwidgetClass.prototype.getPieces = function(context, objid, subid, obj) {
      var n = obj.centers.length,
          depth,
          result = new Array(n),
          z, w, i;
      context = context.slice();
          
      for(i=0; i<n; i++) {
        z = this.prmvMatrix.m13*obj.centers[i][0] +
            this.prmvMatrix.m23*obj.centers[i][1] +
            this.prmvMatrix.m33*obj.centers[i][2] +
            this.prmvMatrix.m43;
        w = this.prmvMatrix.m14*obj.centers[i][0] +
            this.prmvMatrix.m24*obj.centers[i][1] +
            this.prmvMatrix.m34*obj.centers[i][2] +
            this.prmvMatrix.m44;
        depth = z/w;
        result[i] = {context: context, 
                     objid: objid,
                     subid: subid,
                     index: i, 
                     depth: depth};
      }
      return result;    
    };
    
    /**
     * Get pieces from sphere
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getSpherePieces = function(context, subid, obj)
    {
      if (obj.fastTransparency) 
        if (subid === 0) // Only compute pieces once
          return this.getPieces(context, obj.id, -1, obj);
        else
          return [];
      else
        return this.getPieces(context, obj.id, subid, this.sphere);
    };
    
   /**
     * Get pieces from cube
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getCubePieces = function(context, obj)
    {
      return this.getPieces(context, obj.id, 0, this.cube);
    };
    
    /**
     * Merge pieces that can be drawn in one call
     * @returns { object }
     * @param { array } pieces - The pieces to merge
     */
    rglwidgetClass.prototype.mergePieces = function(pieces) {
      var result = [];
      if (pieces.length > 0) {
        var i,
          thiscontext = pieces[0].context, 
          thisobjid = pieces[0].objid, 
          thissubid = pieces[0].subid,
          indices = [];
        for (i= 0; i < pieces.length; i++) {
          if (pieces[i].context !== thiscontext || 
              pieces[i].objid !== thisobjid ||
              pieces[i].subid !== thissubid) {
            result.push({context: thiscontext, objid: thisobjid,
                         subid: thissubid, indices: indices});
            thiscontext = pieces[i].context;
            thisobjid = pieces[i].objid;
            thissubid = pieces[i].subid;
            indices = [];
          }
          indices.push(pieces[i].index);
        }
        result.push({context: thiscontext, objid: thisobjid,
                                subid: thissubid,
                                indices: indices});
      }
      return result;
    };

    /**
     * Sort pieces by depth
     * @returns { array }
     * @param { array } pieces - array of pieces 
     */
    rglwidgetClass.prototype.sortPieces = function(pieces) {
      var compare = function(i,j) {
        var diff = j.depth - i.depth;
        // We want to avoid context or obj changes,
        // so sort on those next.
        if (diff === 0) {
          var c1 = j.context.slice(),
              c2 = i.context.slice();
          diff = c1.length - c2.length; 
          while (diff === 0 && c1.length > 0) {
            diff = c1.pop() - c2.pop();
          }
          if (diff === 0)
            diff = j.objid - i.objid;
          if (diff === 0)
            diff = j.subid - i.subid;
        }
        return diff;
      }, result = [];
      if (pieces.length) 
        result = pieces.sort(compare);
      return result;
    };
</script>
<script>    /**
     * Methods related to drawing
     * @name ___METHODS_FOR_DRAWING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start drawing
     * @returns { boolean } Previous state
     */
    rglwidgetClass.prototype.startDrawing = function() {
    	var value = this.drawing;
    	this.drawing = true;
    	return value;
    };

    /**
     * Stop drawing and check for context loss
     * @param { boolean } saved - Previous state
     */
    rglwidgetClass.prototype.stopDrawing = function(saved) {
      this.drawing = saved;
      if (!saved && this.gl && this.gl.isContextLost())
        this.restartCanvas();
    };

    /**
     * Update the triangles used to display a plane
     * @param { number } id - id of the plane
     * @param { Object } bbox - bounding box in which to display the plane
     */
    rglwidgetClass.prototype.planeUpdateTriangles = function(obj, bbox) {
      var perms = [[0,0,1], [1,2,2], [2,1,0]],
          x, xrow, elem, A, d, nhits, i, j, k, u, v, w, intersect, which, v0, v2, vx, reverse,
          face1 = [], face2 = [], normals = [],
          nPlanes = obj.normals.length, idx, center;
      obj.bbox = bbox;
      obj.vertices = [];
      obj.centers = [];
      obj.initialized = false;
      for (elem = 0; elem < nPlanes; elem++) {
//    Vertex Av = normal.getRecycled(elem);
        x = [];
        A = obj.normals[elem];
        d = obj.offsets[elem][0];
        nhits = 0;
        for (i=0; i<3; i++)
          for (j=0; j<2; j++)
            for (k=0; k<2; k++) {
              u = perms[0][i];
              v = perms[1][i];
              w = perms[2][i];
              if (A[w] !== 0.0) {
                intersect = -(d + A[u]*bbox[j+2*u] + A[v]*bbox[k+2*v])/A[w];
                if (bbox[2*w] < intersect && intersect < bbox[1+2*w]) {
                  xrow = [];
                  xrow[u] = bbox[j+2*u];
                  xrow[v] = bbox[k+2*v];
                  xrow[w] = intersect;
                  x.push(xrow);
                  face1[nhits] = j + 2*u;
                  face2[nhits] = k + 2*v;
                  nhits++;
                }
              }
            }

            if (nhits > 3) {
            /* Re-order the intersections so the triangles work */
              for (i=0; i<nhits-2; i++) {
                which = 0; /* initialize to suppress warning */
                for (j=i+1; j<nhits; j++) {
                  if (face1[i] === face1[j] || face1[i] === face2[j] ||
                      face2[i] === face1[j] || face2[i] === face2[j] ) {
                    which = j;
                    break;
                  }
                }
                if (which > i+1) {
                  rglwidgetClass.swap(x, i+1, which);
                  rglwidgetClass.swap(face1, i+1, which);
                  rglwidgetClass.swap(face2, i+1, which);
                }
              }
            }
            if (nhits >= 3) {
      /* Put in order so that the normal points out the FRONT of the faces */
              v0 = [x[0][0] - x[1][0] , x[0][1] - x[1][1], x[0][2] - x[1][2]];
              v2 = [x[2][0] - x[1][0] , x[2][1] - x[1][1], x[2][2] - x[1][2]];
              /* cross-product */
              vx = rglwidgetClass.xprod(v0, v2);
              reverse = rglwidgetClass.dotprod(vx, A) > 0;

              for (i=0; i<nhits-2; i++) {
                obj.vertices.push(x[0]);
                center = [];
                for (k = 0; k<3; k++)
                  center.push(x[0][k]/3);
                normals.push(A);
                for (j=1; j<3; j++) {
                  idx = i + (reverse ? 3-j : j);
                  obj.vertices.push(x[idx]);
                  for (k=0; k<3; k++)
                    center[k] += x[idx][k]/3;
                  normals.push(A);
                }
                obj.centers.push(center);
              }
            }
      }
      obj.pnormals = normals;
    };
    
    rglwidgetClass.prototype.mode4type = {points : "POINTS",
                     linestrip : "LINE_STRIP",
                     abclines : "LINES",
                     lines : "LINES",
                     sprites : "TRIANGLES",
                     planes : "TRIANGLES",
                     text : "TRIANGLES",
                     quads : "TRIANGLES",
                     surface : "TRIANGLES",
                     triangles : "TRIANGLES",
                     sphere : "TRIANGLES"
    };
    
    /**
     * Disable unused arrays
     * @param { Object } obj - Object to work with
     * @param { Array } enabled - Array indicating which are enabled
     */
    rglwidgetClass.prototype.disableArrays = function(obj, enabled) {
      var gl = this.gl || this.initGL(),
          objLocs = ["normLoc", "texLoc", "ofsLoc", "pointLoc", "nextLoc"],
          thisLocs = ["posLoc", "colLoc"], i, attr;
      for (i = 0; i < objLocs.length; i++) 
        if (enabled[objLocs[i]]) gl.disableVertexAttribArray(obj[objLocs[i]]);
      for (i = 0; i < thisLocs.length; i++)
        if (enabled[thisLocs[i]]) gl.disableVertexAttribArray(this[objLocs[i]]);
      if (typeof obj.userAttributes !== "undefined") {
      	for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.disableVertexAttribArray( obj.userAttribLocations[attr] );
      	}
      }
    };

    /**
     * Start drawing the scene
     */    
    rglwidgetClass.prototype.doStartScene = function() {
      var gl = this.gl || this.initGL();
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearDepth(1.0);
      gl.clearColor(1,1,1,1);
      gl.depthMask(true); // Must be true before clearing depth buffer
      /* jshint bitwise: false */
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      /* jshint bitwise: true */
    };
    
    /**
     * Set gl depth test based on object's material
     * @param { Object } obj - object to use
     */
    rglwidgetClass.prototype.doDepthTest = function(obj) {
      var gl = this.gl,
          tests = {never: gl.NEVER,
                   less:  gl.LESS,
                   equal: gl.EQUAL,
                   lequal:gl.LEQUAL,
                   greater: gl.GREATER,
                   notequal: gl.NOTEQUAL,
                   gequal: gl.GEQUAL,
                   always: gl.ALWAYS},
           test = tests[this.getMaterial(obj, "depth_test")];
      gl.depthFunc(test);
    };    
    
    /**
     * Set polygon offset for an obj
     * @param { object } obj - object to use
     */
    rglwidgetClass.prototype.doPolygonOffset = function(obj) { 
      var gl = this.gl;
      if (typeof obj.polygon_offset !== "undefined") {
        gl.polygonOffset(obj.polygon_offset[0],
                          obj.polygon_offset[1]);
        gl.enable(gl.POLYGON_OFFSET_FILL);
      } else
        gl.disable(gl.POLYGON_OFFSET_FILL);
    };
    
    /**
     * Do code for clipping
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doClipping = function(obj, subscene) {
      var gl = this.gl,
          clipcheck = 0,
          clipplaneids = subscene.clipplanes,
          clip, i,j, n = this.countClipplanes(),
          clipplanedata; 
          
      if (n > 0) {
        clipplanedata = new Float32Array(4*n);
        for (i=0; i < clipplaneids.length; i++) {
          clip = this.getObj(clipplaneids[i]);
          for (j=0; j < clip.offsets.length; j++) {
            clipplanedata.set(clip.IMVClip[j], clipcheck);
            clipcheck += 4;
          }
        }
      
        // Leftovers are initialized to zero, which is fine
        gl.uniform4fv(obj.clipLoc, clipplanedata);
      }
    };
    
    /**
     * Do code for lighting
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doLighting = function(obj, subscene) {
    var gl = this.gl, i, j, n, light,
      ambient, specular, diffuse, lightDir, viewpoint, finite,
      ambient0, specular0;

      gl.uniform3fv( obj.emissionLoc, obj.emission);
      gl.uniform1f( obj.shininessLoc, obj.shininess);
      while ((typeof subscene.lights === "undefined" ||
              subscene.lights.length === 0) && 
             typeof subscene.parent !== "undefined")
        subscene = this.getObj(subscene.parent);

      if (typeof subscene.lights === "undefined")
        return;
        
      n = subscene.lights.length;
        
      ambient = new Float32Array(3*n);
      specular = new Float32Array(3*n);
      diffuse = new Float32Array(3*n);
      lightDir = new Float32Array(3*n);
      viewpoint = new Int32Array(n);
      finite = new Int32Array(n);
          
      for (i=0; i < n; i++) {
        light = this.getObj(subscene.lights[i]);
        if (!light.initialized) this.initObj(light);
        ambient0 = this.componentProduct(light.ambient, obj.ambient);
        specular0 = this.componentProduct(light.specular, obj.specular);
        for (j=0; j < 3; j++) {
          ambient[3*i + j] = ambient0[j];
          specular[3*i + j] = specular0[j];
          diffuse[3*i + j] = light.diffuse[j];
          lightDir[3*i + j] = light.lightDir[j];
        }
        viewpoint[i] = light.viewpoint;
        finite[i] = light.finite;
      }
        
      for (i = n; i < obj.nlights; i++) {
        for (j = 0; j < 3; j++) {
          ambient[3*i + j] = 0.0;
          specular[3*i + j] = 0.0;
          diffuse[3*i + j] = 0.0;
        }
      }
        
      gl.uniform3fv( obj.ambientLoc, ambient);
      gl.uniform3fv( obj.specularLoc, specular);
      gl.uniform3fv( obj.diffuseLoc, diffuse);
      gl.uniform3fv( obj.lightDirLoc, lightDir);
      gl.uniform1iv( obj.viewpointLoc, viewpoint);
      gl.uniform1iv( obj.finiteLoc, finite);
    };
    
    /**
     * Do code for colors
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doColors = function(obj) {
      var gl = this.gl;
      if (obj.colorCount === 1) {
        gl.disableVertexAttribArray( this.colLoc );
        gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
        return false;
      } else {
        gl.enableVertexAttribArray( this.colLoc );
        gl.vertexAttribPointer(this.colLoc, 4, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.cofs);
        return true;
      }
    };
    
    /**
     * Do code for normals
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormals = function(obj) {
      var gl = this.gl;
      if (obj.vOffsets.nofs >= 0) {
        gl.enableVertexAttribArray( obj.normLoc );
        gl.vertexAttribPointer(obj.normLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nofs);
        return true;
      } else
        return false;
    };
    
    /**
     * Do code for vNormal
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormMat = function(obj) {
      var gl = this.gl;
        
      gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(this.normMatrix.getAsArray()) );
    };
    
    /**
     * Do code for textures
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doTexture = function(obj) {
      var gl = this.gl, 
          is_sphere = obj.type === "sphere";
        gl.enableVertexAttribArray( obj.texLoc );
        if (is_sphere)
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*this.sphere.vOffsets.stride, 4*this.sphere.vOffsets.tofs);
        else
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.tofs);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.uniform1i( obj.sampler, 0);
        return true;
    };
    
    /**
     * Do code for user attributes
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserAttributes = function(obj) {
      if (typeof obj.userAttributes !== "undefined") {
        var gl = this.gl;
      	for (var attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.enableVertexAttribArray( obj.userAttribLocations[attr] );
      	  gl.vertexAttribPointer( obj.userAttribLocations[attr], obj.userAttribSizes[attr],
      	  			  gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.userAttribOffsets[attr]);
      	}
      }
    };

    /**
     * Do code for user uniforms
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserUniforms = function(obj) {
      var gl = this.gl, attr;
      if (typeof obj.userUniforms !== "undefined") {
      	for (attr in obj.userUniformLocations) {
      	  var loc = obj.userUniformLocations[attr];
      	  if (loc !== null) {
      	    var uniform = obj.userUniforms[attr];
      	    if (typeof uniform !== "undefined") {
      	      var dim = rglwidgetClass.arrayDim(uniform);
      	      if (dim.length === 0)
      	        gl.uniform1f(loc, uniform);
      	      else if (dim.length === 1) {
      	        uniform = new Float32Array(uniform);
      	        switch(uniform.length) {
      	      	  case 2: gl.uniform2fv(loc, uniform); break;
      	      	  case 3: gl.uniform3fv(loc, uniform); break;
      	      	  case 4: gl.uniform4fv(loc, uniform); break;
      	      	  default: console.warn("bad uniform length");
      	        }
      	      } else if (dim.length === 2 && dim[0] === 4 && dim[1] === 4)
      	        gl.uniformMatrix4fv(loc, false, new Float32Array(rglwidgetClass.flatten(uniform)));
      	      else if (dim.length === 2) {
      	        uniform = new Float32Array(rglwidgetClass.flatten(uniform));
      	        switch(dim[[1]]) {
      	          case 1: gl.uniform1fv(loc, uniform); break;
      	          case 2: gl.uniform2fv(loc, uniform); break;
      	          case 3: gl.uniform3fv(loc, uniform); break;
      	          case 4: gl.uniform4fv(loc, uniform); break;
      	          default: console.warn("bad uniform column count");
      	        }
      	      } else
      	        console.warn("unsupported uniform shape");
      	    }
      	  }
      	}
      }
      if (typeof obj.userTextures !== "undefined") {
        var has_texture = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_has_texture),
              texnum = has_texture - 1;
        for (attr in obj.userTextures) {
      	  var texture = obj.userTextures[attr];
      	  if (texture.sampler !== null) {
      	    texnum += 1;
      	    gl.activeTexture(gl.TEXTURE0 + texnum);
            gl.bindTexture(gl.TEXTURE_2D, texture.texture);
            gl.uniform1i( texture.sampler, texnum);
      	  }
      	}
      }
    };

    /**
     * Load indices for complex drawing
     * @param { object } obj - Object to work with
     * @param { numeric } pass - Which pass of drawing?
     * @param { array } indices - Indices to draw
     */    
    rglwidgetClass.prototype.doLoadIndices = function(obj, pass, indices) {
      var gl = this.gl,
          f = obj.f[pass],
          type = obj.type,
          fat_lines = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_fat_lines),
          fnew, step;
      switch(type){
        case "points":
          step = 1;
          break;
        case "abclines":
        case "lines":
          if (fat_lines)
            step = 6;
          else
            step = 2;
          break;
        case "linestrip":
          if (fat_lines)
            step = 6;
          else
            step = 1;
          break;
        case "sphere":
        case "planes":
        case "triangles":
          step = 3;
          break;
        case "text":
        case "sprites":
        case "quads":
        case "surface":
          step = 6;
          break;
        default:
          console.error("loadIndices for "+type);
          return 0;
      }
      if (obj.index_uint)
        fnew = new Uint32Array(step * indices.length);
      else
        fnew = new Uint16Array(step * indices.length);
      for (var i = 0; i < indices.length; i++) {
        for (var j = 0; j < step; j++) {
          fnew[step*i + j] = f[step*indices[i] + j];
        }
      }
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fnew, gl.DYNAMIC_DRAW);
      return fnew.length;
    };

    /**
     * Do code for depth masking
     * @param { boolean } mask - whether to mask
     */
    rglwidgetClass.prototype.doMasking = function(mask) {
      var gl = this.gl;
      gl.depthMask(mask);
    };

    /**
     * Do code for alpha blending
     * @param { boolean }  blend - Whether to blend.
     * @param { integer }  objid - Object id
     */    
    rglwidgetClass.prototype.doBlending = function(blend, objid) {
      var gl = this.gl, blendfunc, obj, 
        blends =  {zero: gl.ZERO,
                   one:  gl.ONE,
                   src_color: gl.SRC_COLOR,
                   one_minus_src_color: gl.ONE_MINUS_SRC_COLOR,
                   dst_color: gl.DST_COLOR,
                   one_minus_dst_color: gl.ONE_MINUS_DST_COLOR,
                   src_alpha: gl.SRC_ALPHA,
                   one_minus_src_alpha: gl.ONE_MINUS_SRC_ALPHA,
                   dst_alpha: gl.DST_ALPHA,
                   one_minus_dst_alpha: gl.ONE_MINUS_DST_ALPHA,
                   constant_color: gl.CONSTANT_COLOR,
                   one_minus_constant_color: gl.ONE_MINUS_CONSTANT_COLOR,
                   constant_alpha: gl.CONSTANT_ALPHA,
                   one_minus_constant_alpha: gl.ONE_MINUS_CONSTANT_ALPHA,
                   src_alpha_saturate: gl.SRC_ALPHA_SATURATE};
      if (blend) {
        obj = this.getObj(objid);
        blendfunc = this.getMaterial(obj, "blend");
        gl.blendFuncSeparate(blends[blendfunc[0]],
                             blends[blendfunc[1]],
                             gl.ONE, gl.ONE);
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
    };
    
    /**
     * Set up for fog in the subscene
     * @param { object } obj - background object
     * @param { object } subscene - which subscene
     */
    rglwidgetClass.prototype.doFog = function(obj, subscene) {
      var gl = this.gl, fogmode, color, 
          observer = subscene.par3d.observer[2],
          sintheta = Math.sin(subscene.par3d.FOV*Math.PI/180/2),
          parms = [this.frustum.near - 2*observer,
                   this.frustum.far - 2*observer,
                   this.fogScale,
                   (1-sintheta)/(1+sintheta)];
      if (typeof this.fogType === "undefined")
        this.fogType = "none";
      if (typeof this.fogScale === "undefined")
        parms[2] = 1;
      if (sintheta === 0)
        parms[3] = 1/3;
      switch(this.fogType){
        case "none": fogmode = 0; break;
        case "linear": 
          fogmode = 1; break;
        case "exp":  
          fogmode = 2; break;
        case "exp2": 
          fogmode = 3;
          break;
        default: console.error("Unknown fogtype "+this.fogType);
      }
      gl.uniform1i(obj.uFogMode, fogmode);
      color = this.fogColor;
      gl.uniform3f(obj.uFogColor, color[0], color[1], color[2]);
      gl.uniform4f(obj.uFogParms, parms[0], parms[1], parms[2], parms[3]);
    };

    /* The draw methods are called twice.  When 
       this.opaquePass is true, they should draw opaque parts
       of the scene, and return the list of transparent
       pieces.  Here context is the context array on input,
       modified when the matrices are changed.
       When this.opaquePass is false, the context argument
       contains a "piece", i.e. an ordered list of parts
       of the object to draw. */

    /**
     * Draw simple object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */       
    rglwidgetClass.prototype.drawSimple = function(obj, subscene, context) {
      var 
          fl,
          is_transparent,
          type = obj.type,
          gl = this.gl || this.initGL(),
          count,
          pass, mode, pmode,
          enabled = {};
        
      if (!obj.initialized)
        this.initObj(obj);
        
      if (this.texturesLoading)
        return[];

      count = obj.vertexCount;
      if (!count)
        return [];
    
      fl = obj.defFlags;
      is_transparent = fl.is_transparent || obj.someHidden;
      
      if (is_transparent && this.opaquePass)
        return this.getPieces(context, obj.id, 0, obj);

      this.doDepthTest(obj);
      
      this.doMasking(this.getMaterial(obj, "depth_mask"));
            
      gl.useProgram(obj.prog);

      this.doPolygonOffset(obj);

      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);

      gl.uniformMatrix4fv( obj.prMatLoc, false, new Float32Array(this.prMatrix.getAsArray()) );
      gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(this.mvMatrix.getAsArray()) );

      this.doClipping(obj, subscene);

      if (fl.needs_vnormal)
        this.doNormMat(obj);
        
      if (fl.is_lit)
        this.doLighting(obj, subscene);

      if (fl.has_fog)
        this.doFog(obj, subscene);

      this.doUserAttributes(obj);

      this.doUserUniforms(obj);
 
      gl.enableVertexAttribArray( this.posLoc );
      enabled.posLoc = true;
        
      if (fl.has_texture || obj.type === "text")
        enabled.texLoc = this.doTexture(obj);

      enabled.colLoc = this.doColors(obj);
      enabled.normLoc = this.doNormals(obj);

      if (fl.fixed_size) {
        gl.uniform3f( obj.textScaleLoc, 0.75/this.vp.width, 0.75/this.vp.height, 1.0);
      }
      
      if (fl.fixed_quads) {
        gl.enableVertexAttribArray( obj.ofsLoc );
        enabled.ofsLoc = true;
        gl.vertexAttribPointer(obj.ofsLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.oofs);
      }

      for (pass = 0; pass < obj.passes; pass++) {
      	pmode = obj.pmode[pass];
        if (pmode === "culled")
          continue;

      	mode = fl.fat_lines && (fl.is_lines || pmode === "lines") ? "TRIANGLES" : this.mode4type[type];

      	if (fl.is_twosided) {
      	  gl.uniform1i(obj.frontLoc, pass !== 0);
      	  if (fl.has_normals) {
      	    gl.uniformMatrix4fv(obj.invPrMatLoc, false, new Float32Array(this.invPrMatrix.getAsArray()));
      	  }
      	}

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
        if (!this.opaquePass) {
          if (type === "sphere" && obj.fastTransparency)
            count = this.doLoadIndices(obj, pass, this.sphere.fastpieces[0].indices);
          else
            count = this.doLoadIndices(obj, pass, context.indices);
        } else {
          count = obj.f[pass].length;
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[pass], gl.STATIC_DRAW);
        }
      	if (!fl.is_lines && pmode === "lines" && !fl.fat_lines) {
          mode = "LINES";
        } else if (pmode === "points") {
          mode = "POINTS";
        }
                          
        if ((fl.is_lines || pmode === "lines") && fl.fat_lines) {
          gl.enableVertexAttribArray(obj.pointLoc);
          enabled.pointLoc = true;
          gl.vertexAttribPointer(obj.pointLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.pointofs);
          gl.enableVertexAttribArray(obj.nextLoc );
          enabled.nextLoc = true;
          gl.vertexAttribPointer(obj.nextLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nextofs);
          gl.uniform1f(obj.aspectLoc, this.vp.width/this.vp.height);
          gl.uniform1f(obj.lwdLoc, this.getMaterial(obj, "lwd")/this.vp.height);
        }

        gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*obj.vOffsets.stride,  4*obj.vOffsets.vofs);

        gl.drawElements(gl[mode], count, obj.index_uint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);
      }
      this.disableArrays(obj, enabled);
      return [];
    };

    /**
     * Draw planes object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */      
    rglwidgetClass.prototype.drawPlanes = function(obj, subscene, context) {
      if (this.opaquePass && (obj.bbox !== subscene.par3d.bbox || !obj.initialized)) {
          this.planeUpdateTriangles(obj, subscene.par3d.bbox);
      }
      return this.drawSimple(obj, subscene, context);
   };

    /**
     * @param { object } obj - object to draw
     * @param { object } subscene 
     * @param { array } context 
     * @description
     * Draw spheres in a subscene<br>
     * 
     * Drawing spheres happens in six ways:<br>
     * 1 opaquepass, not transparent:  transform and draw this.sphere count times<br>
     * 2 opaquepass, transparent, not fast: transform & collect sphere pieces count times<br>
     * 3 opaquepass, transparent, fast:  order the centres into separate pieces, order this.sphere once<br>
     * 4 not opaquepass, not transparent:  do nothing<br>
     * 5 not opaquepass, transparent, not fast:  transform for one sphere, draw one merged piece<br>
     * 6 not opaquepass, transparent, fast:  transform for one sphere, draw this.sphere in fixed order.<br>
     **/

    rglwidgetClass.prototype.drawSpheres = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sphereMV, baseofs, ofs, sscale, i,
          count, nc, scount, scale, indices, sphereNorm,
          enabled = {}, drawing,
          saveNorm = new CanvasMatrix4(this.normMatrix),
          saveMV = new CanvasMatrix4(this.mvMatrix),
          savePRMV = null,
          result = [], idx, margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!obj.initialized)
        this.initObj(obj);

      count = obj.vertexCount;
      if (!count) 
        return [];
        
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return [];
        
      if (this.prmvMatrix !== null)
        savePRMV = new CanvasMatrix4(this.prmvMatrix);
      
      scale = subscene.par3d.scale;        
      sphereNorm = new CanvasMatrix4();
      sphereNorm.scale(scale[0], scale[1], scale[2]);
      sphereNorm.multRight(saveNorm);
      this.normMatrix = sphereNorm;

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      if (drawing) {
        nc = obj.colorCount;
        if (nc === 1) {
          this.sphere.onecolor = obj.onecolor;
        }
      }
      
      this.initShapeFromObj(this.sphere, obj);

      if (!this.opaquePass && obj.fastTransparency && typeof this.sphere.fastpieces === "undefined") {
        this.sphere.fastpieces = this.getPieces(context.context, obj.id, 0, this.sphere);
        this.sphere.fastpieces = this.sortPieces(this.sphere.fastpieces);
        this.sphere.fastpieces = this.mergePieces(this.sphere.fastpieces);
      }

      if (this.opaquePass)
        scount = count;
      else {
        indices = context.indices;
        if (obj.fastTransparency)
          scount = indices.length;  /* Each item gives the center of a whole sphere */
        else
          scount = 1;               /* Each item is a fragment of the sphere, at location subid */
      }
      for (i = 0; i < scount; i++) {
        sphereMV = new CanvasMatrix4();
        if (this.opaquePass)
          idx = i;
        else if (obj.fastTransparency)
          idx = indices[i];
        else
          idx = context.subid;
        if (typeof idx === "undefined")
          console.error("idx is undefined");
        baseofs = idx*obj.vOffsets.stride;
        ofs = baseofs + obj.vOffsets.radofs;
        sscale = obj.values[ofs];

        sphereMV.scale(sscale/scale[0], sscale/scale[1], sscale/scale[2]);
        sphereMV.translate(obj.values[baseofs],
                             obj.values[baseofs+1],
                             obj.values[baseofs+2]);
        sphereMV.multRight(saveMV);
        this.mvMatrix = sphereMV;
        this.setnormMatrix2();
        this.setprmvMatrix();
        if (drawing) {
          if (nc > 1) {
            this.sphere.onecolor = obj.values.slice(baseofs + obj.vOffsets.cofs, baseofs + obj.vOffsets.cofs + 4);
          }
          this.drawSimple(this.sphere, subscene, context);
        } else 
          result = result.concat(this.getSpherePieces(context, i, obj));
      }
      if (drawing)
        this.disableArrays(obj, enabled);
      this.normMatrix = saveNorm;
      this.mvMatrix = saveMV;
      this.prmvMatrix = savePRMV;
        
      return result;
    };
    
    /**
     * Prepare clipplanes for drawing
     * @param { object } obj - clip planes object
     */
    rglwidgetClass.prototype.drawClipplanes = function(obj) {
      var count = obj.offsets.length,
        IMVClip = [];
      for (var i=0; i < count; i++) {
        IMVClip[i] = rglwidgetClass.multMV(this.invMatrix, obj.vClipplane.slice(4*i, 4*(i+1)));
      }
      obj.IMVClip = IMVClip;
      return [];
    };

    /**
     * Prepare linestrip for drawing
     * @param { object } obj - line strip object
     * @param { object } subscene 
     * @param { array } context 
     */    
    rglwidgetClass.prototype.drawLinestrip = function(obj, subscene, context) {
      var origIndices, i, j, margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      if (this.opaquePass)
        return this.drawSimple(obj, subscene, context);
      origIndices = context.indices.slice();
      for (i=0; i < origIndices.length; i++) {
        j = origIndices[i];
        if (j < obj.centers.length - 1) {
          context.indices = [j, j+1];
          this.drawSimple(obj, subscene, context);
        }
      }
      context.indices = origIndices;
      return [];
    };
          
    /**
     * Draw a sprites object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { object } context
     */
    rglwidgetClass.prototype.drawSprites = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sprites3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size),
          rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating),
          i,j,
          origMV = new CanvasMatrix4( this.mvMatrix ),
          origPRMV = null,
          origPR,
          pos, radius, userMatrix,
          result = [], margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!sprites3d) 
        return this.drawSimple(obj, subscene, context);
      
      if (!obj.initialized)
        this.initObj(obj);

      if (!obj.vertexCount)
        return [];
    
      is_transparent = is_transparent || obj.someHidden;
      
      var norigs = obj.vertices.length,
          savenorm = new CanvasMatrix4(this.normMatrix),
          iOrig, adj, offset;

      userMatrix = obj.userMatrix;
                   
      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } else
        norigs = 1;
          
      if (this.prmvMatrix !== null)
         origPRMV = new CanvasMatrix4( this.prmvMatrix );

      offset = obj.offset;
      
      if (fixed_size && !rotating) {
        origPR = this.prMatrix;
        this.prMatrix = new CanvasMatrix4();
      }
        
      for (iOrig=0; iOrig < norigs; iOrig++) {
        if (this.opaquePass)
          j = iOrig;
        else
          j = context.subid;
        pos = [].concat(obj.vertices[j]).concat(1.0);
        radius = obj.radii.length > 1 ? obj.radii[j][0] : obj.radii[0][0];
        this.mvMatrix = new CanvasMatrix4(userMatrix);
        adj = this.getAdj(obj, j, offset);
        this.mvMatrix.translate(1 - 2*adj[0], 1 - 2*adj[1], 1 - 2*adj[2]);
        this.mvMatrix.scale(radius, radius, radius);
        
        if (fixed_size) {
          var viewport = subscene.par3d.viewport,
            winwidth = viewport.width*this.canvas.width,
            winheight = viewport.height*this.canvas.height,
            scalex = 27/winwidth, scaley = 27/winheight,
              scale = Math.sqrt(scalex * scaley);
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            pos = rglwidgetClass.multVM(pos, origPR);
            this.mvMatrix.scale(scalex, scaley, scale);
          } else {
            scale = 4.0 * scale * subscene.par3d.zoom;
            this.mvMatrix.scale(scale, scale, scale);
          }
          this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          if (rotating)
            this.mvMatrix.multRight(origMV);
        } else {
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          } else {
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
            this.mvMatrix.multRight(origMV);
          }
        }
        this.setnormMatrix2();
        this.setprmvMatrix();
      
        for (i=0; i < obj.objects.length; i++)
          if (this.opaquePass)
            result = result.concat(this.drawObjId(obj.objects[i], subscene.id, context.concat(j)));
          else
            this.drawObjId(obj.objects[i], subscene.id, context);
      }
      this.normMatrix = savenorm;
      this.mvMatrix = origMV;
      if (fixed_size && !rotating)
        this.prMatrix = origPR;
      if (origPRMV !== null)
        this.prmvMatrix = origPRMV;
      return result;
    };
    
    /**
     * Draw object that might be in margin
     * @param { Object } obj - text object to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawMarginal = function(obj, subscene, context) {
      var margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      return this.drawSimple(obj, subscene, context);
    };
    
    /**
     * Draw bounding box and decorations
     * @param { Object } obj - bboxdeco to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawBBox = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          scale, bbox, indices,
          enabled = {}, drawing,
          result = [], idx, center, edges,
          saved;

      if (!obj.initialized)
        this.initBBox(obj);
      
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return result;
      
      this.setBbox(obj, subscene);
      
      saved = this.setBBoxMatrices(obj);
      
      bbox = obj.bbox;
      center = obj.center;

      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];

      if (!obj.cube.initialized) {
        this.initObj(obj.cube);
      }

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      this.cube.onecolor = obj.cube.onecolor;
      this.initShapeFromObj(this.cube, obj.cube);

      if (!this.opaquePass)
        indices = context.indices;

      if (this.opaquePass)
        idx = 0;
      else
        idx = context.subid;
      if (typeof idx === "undefined")
        console.error("idx is undefined");

      if (drawing) {
        this.drawSimple(this.cube, subscene, context);
      } else 
        result = result.concat(this.getCubePieces(context, obj));

      if (!obj.ticks.initialized) {
        obj.ticks.locations = this.getTickLocations(obj);
        obj.ticks.edges = undefined;
      }
      edges = this.getTickEdges(this.prmvMatrix);
      if (obj.needsAxisCallback) 
        this.doAxisCallback(obj, edges);
      if (!obj.ticks.edges || edges.toString() !== obj.ticks.edges.toString()) {
        obj.ticks.edges = edges;
        this.getTickVertices(obj.ticks);
        this.placeTickLabels(obj);
        this.setTickLabels(obj);
      }
      if (!obj.ticks.initialized) {
        this.initObj(obj.ticks);
        this.initObj(obj.labels);
      }
        
      if (drawing) {
        this.drawSimple(obj.ticks, subscene, context);
        this.drawSimple(obj.labels, subscene, context);

        this.disableArrays(obj, enabled);
      } else {
        result = result.concat(this.drawSimple(obj.ticks, subscene, context));
        result = result.concat(this.drawSimple(obj.labels, subscene, context));
      }

      this.restoreBBoxMatrices(saved);
        
      return result;
    };
    
    /**
     * Use ids to choose object to draw
     * @param { numeric } id - object to draw
     * @param { numeric } subscene
     * @param { array } context
     */   
    rglwidgetClass.prototype.drawObjId = function(id, subsceneid, context) {
      if (typeof id !== "number")
        this.alertOnce("drawObjId id is "+typeof id);

      return this.drawObj(this.getObj(id), this.getObj(subsceneid), context);
   };
   
    /**
     * Draw an object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { array } context
     */
    rglwidgetClass.prototype.drawObj = function(obj, subscene, context) {
      switch(obj.type) {
        case "abclines":
        case "surface":
          return this.drawSimple(obj, subscene, context);
        case "points":
        case "lines":  
        case "triangles":
        case "quads":
        case "text":
          return this.drawMarginal(obj, subscene, context);
        case "linestrip":
          return this.drawLinestrip(obj, subscene, context);
        case "planes":
          return this.drawPlanes(obj, subscene, context);
        case "spheres":
          return this.drawSpheres(obj, subscene, context);
        case "clipplanes":
          return this.drawClipplanes(obj);
        case "sprites":
          return this.drawSprites(obj, subscene, context);
        case "light":
          return [];
        case "bboxdeco":
          return this.drawBBox(obj, subscene, context);
      }
      
      console.error("drawObj for type = "+obj.type);
    };

    /**
     * Draw the background for a subscene
     * @param { number } id - id of background object
     * @param { number } subsceneid - id of subscene
     */
    rglwidgetClass.prototype.drawBackground = function(id, subsceneid, context) {
      var gl = this.gl || this.initGL(),
          obj = this.getObj(id),
          subscene,
          bg, i, savepr, saveinvpr, savemv, savenorm, m, bbox, result = [], 
          savedm = gl.getParameter(gl.DEPTH_WRITEMASK),
          savedt = gl.isEnabled(gl.DEPTH_TEST),
          saveblend = gl.isEnabled(gl.BLEND);

      if (!obj.initialized)
        this.initObj(obj);

      if (obj.colors.length) {
        bg = obj.colors[0];
        gl.depthMask(true);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.fogColor = bg;
      } else {
        this.fogColor = [0,0,0,0];
        obj.colors = [[0,0,0,0]];
      }
  
      this.fogType = obj.fogtype;
      this.fogScale = obj.fogscale;
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      if (typeof obj.quad !== "undefined") {
        savepr = this.prMatrix;
        saveinvpr = this.invPrMatrix;
        savemv = this.mvMatrix;
        this.prMatrix = new CanvasMatrix4();
        this.invPrMatrix = new CanvasMatrix4();
        this.mvMatrix = new CanvasMatrix4();
        for (i=0; i < obj.quad.length; i++)
          result = result.concat(this.drawObjId(obj.quad[i], subsceneid));
        this.prMatrix = savepr;
        this.invPrMatrix = saveinvpr;
        this.mvMatrix = savemv;

      } else if (obj.sphere) {
        subscene = this.getObj(subsceneid);
        savemv = this.mvMatrix;
        savenorm = this.normMatrix;
        bbox = subscene.par3d.bbox;
        var center = [(bbox[0] + bbox[1])/2, 
                  (bbox[2] + bbox[3])/2, 
                  (bbox[4] + bbox[5])/2, 1],
            scale = subscene.par3d.scale,
            ranges = [bbox[1] - bbox[0], 
                  bbox[3] - bbox[2],
                  bbox[5] - bbox[4]],
            avgscale = rglwidgetClass.vlen(ranges)/Math.sqrt(3),
            aspect = [ranges[0]*scale[0]/avgscale,
                      ranges[1]*scale[1]/avgscale,
                      ranges[2]*scale[2]/avgscale],
            maxaspect = Math.max(aspect[0], aspect[1], aspect[2]),
            zoom = subscene.par3d.zoom;
        m = new CanvasMatrix4();
        m.rotate(90, 1, 0, 0);
        m.scale(zoom*2.0*maxaspect*ranges[0]/aspect[0], 
                zoom*2.0*maxaspect*ranges[1]/aspect[1],
                zoom*2.0*maxaspect*ranges[2]/aspect[2]);
        m.translate(center[0], center[1], center[2]);
        m.multRight(savemv);
        center = rglwidgetClass.multVM(center, savemv);
        m.translate(-center[0], -center[1], -center[2]);
        m.scale(1, 1, 0.25/zoom);
        m.translate(center[0], center[1], center[2]);
        this.mvMatrix = m;
        this.initShapeFromObj(this.sphere, obj);
        this.sphere.onecolor = obj.colors.length > 1 ? obj.colors[1] : obj.colors[0];
        
        this.normMatrix = new CanvasMatrix4();
        
        this.setnormMatrix2();
        this.setprmvMatrix();
        
        result = result.concat(this.drawSimple(this.sphere, subscene, context));
        this.mvMatrix = savemv;
        this.normMatrix = savenorm;
      }
      gl.depthMask(savedm);
      if (savedt)
        gl.enable(gl.DEPTH_TEST);
      if (saveblend)
        gl.enable(gl.BLEND);
      return result;
    };

    /**
     * Draw a subscene
     * @param { number } subsceneid - id of subscene
     * @param { array } context 
     */
    rglwidgetClass.prototype.drawSubscene = function(subsceneid, context) {
      var sub = this.getObj(subsceneid),
          objects = this.scene.objects,
          clipids = sub.clipplanes,
          subids = sub.objects,
          subscene_has_faces = false,
          subscene_needs_sorting = false,
          flags, i, obj, result = [];
          
      if (sub.par3d.skipRedraw)
        return result;
      
      if (this.opaquePass) {
        for (i=0; i < subids.length; i++) {
      	  obj = objects[subids[i]];
          flags = obj.flags;
          if (typeof flags !== "undefined") {
            subscene_has_faces = subscene_has_faces || 
                            (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit) &&
                            !rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads));
            obj.is_transparent = obj.someHidden || 
              rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
            subscene_needs_sorting = subscene_needs_sorting || 
              obj.is_transparent ||
              rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort);
          }
        }
      }

      this.setViewport(subsceneid);

      this.setprMatrix(subsceneid);
      this.setInvPrMatrix();
      this.setmvMatrix(subsceneid);
      this.setnormMatrix2();
      this.setprmvMatrix();
      this.invMatrix = new CanvasMatrix4(this.mvMatrix);
      this.invMatrix.invert();
      
      if (this.opaquePass) {
        context = context.slice();
        context.push(subsceneid);
        
        this.doBlending(false);
        this.subsceneid = subsceneid;
        if (typeof this.sphere !== "undefined") // reset this.sphere.fastpieces; it will be recreated if needed
          this.sphere.fastpieces = undefined;
        if (typeof sub.backgroundId !== "undefined")
          result = result.concat(this.drawBackground(sub.backgroundId, subsceneid, context));
      }

      if (subids.length) {
            
        if (clipids.length > 0) {
          for (i = 0; i < clipids.length; i++)
            this.drawObjId(clipids[i], subsceneid);
        }
        
        subids = sub.opaque.concat(sub.transparent);
        if (this.opaquePass) {
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawObjId(subids[i], subsceneid, context));
          subids = sub.subscenes;
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawSubscene(subids[i], context));
        }
      }
      return result;
    };
    
    /**
     * Set the context for drawing transparently
     * @param { array } context
     */
    rglwidgetClass.prototype.setContext = function(context) {
      var result = [], objid, obj, type;
      context = context.slice();
      context.reverse();
      while (context.length > 0) {
        objid = context.pop();
        obj = this.getObj(objid);
        type = obj.type;
        switch (type) {
          case "subscene":
            this.drawSubscene(objid, false);
            break;
          case "sprites":
            result = result.concat(context.pop());
            break;
          case "spheres":
            // this.initSphereFromObj(obj);  // FIXME:  not needed?
            break;
          case "bboxdeco":
            result = result.concat(context.pop());
            break;
          default:
            console.error("bad type '", type, "' in setContext");
        }
      }
      return result;
    };
    
    /**
     * Draw the transparent pieces of a scene
     * @param {object} pieces
     */
    rglwidgetClass.prototype.drawPieces = function(pieces) {
      var i, prevcontext = [], context;
      for (i = 0; i < pieces.length; i++) {
        context = pieces[i].context.slice();
        if (context !== prevcontext) {
          prevcontext = context.slice();
          context = this.setContext(context);
          this.doBlending(true, pieces[i].objid);
        }
        this.drawObjId(pieces[i].objid, this.subsceneid, 
                       pieces[i]);
      }
    };
 
    /**
     * Draw the whole scene
     */
    rglwidgetClass.prototype.drawScene = function() {
      var wasDrawing = this.startDrawing(),
          pieces;
      if (!wasDrawing) {
        if (this.select.state !== "inactive")
          this.selectionChanged();

        this.doStartScene();
        this.opaquePass = true;
        pieces = this.drawSubscene(this.scene.rootSubscene, []);
        this.opaquePass = false;
        pieces = this.sortPieces(pieces);
        pieces = this.mergePieces(pieces);
        this.drawPieces(pieces);
      }
      this.stopDrawing(wasDrawing);
    };
</script>
<script>
    /**
     * Change the displayed subset
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The subset control data.
     */
    rglwidgetClass.prototype.subsetSetter = function(el, control) {
      if (typeof control.subscenes === "undefined" ||
          control.subscenes === null)
        control.subscenes = this.scene.rootSubscene;
      var value = Math.round(control.value),
          subscenes = [].concat(control.subscenes),
          fullset = [].concat(control.fullset),
          i, j, subsceneid,
          adds = [], deletes = [];
      if (rglwidgetClass.missing(value))
        value = control.value = 0;
      if (control.accumulate)
        for (i=0; i <= value; i++)
          adds = adds.concat(control.subsets[i]);
      else
        adds = adds.concat(control.subsets[value]);
      deletes = fullset.filter(function(x) { return adds.indexOf(x) < 0; });
      for (i = 0; i < subscenes.length; i++) {
        subsceneid = subscenes[i];
        if (typeof this.getObj(subsceneid) === "undefined")
          this.alertOnce("typeof object is undefined");
        for (j = 0; j < adds.length; j++)
          this.addToSubscene(adds[j], subsceneid);
        for (j = 0; j < deletes.length; j++)
          this.delFromSubscene(deletes[j], subsceneid);
      }
    };

    /**
     * Change the requested property
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The property setter control data.
     */
    rglwidgetClass.prototype.propertySetter = function(el, control)  {
      var value = control.value,
          values = [].concat(control.values),
          svals = [].concat(control.param),
          direct = values[0] === null,
          entries = [].concat(control.entries),
          ncol = entries.length,
          nrow = values.length/ncol,
          properties = rglwidgetClass.repeatToLen(control.properties, ncol),
          objids = rglwidgetClass.repeatToLen(control.objids, ncol),
          property, objid = objids[0],
          obj = this.getObj(objid),
          propvals, i, j, v1, v2, p, entry, gl, needsBinding,
          newprop, newid,

          getPropvals = function() {
            if (property === "userMatrix")
              return obj.par3d.userMatrix.getAsArray();
            else if (property === "scale" || property === "FOV" || property === "zoom")
              return [].concat(obj.par3d[property]);
            else
              return [].concat(obj[property]);
          },

          putPropvals = function(newvals) {
            if (newvals.length === 1)
              newvals = newvals[0];
            if (property === "userMatrix")
              obj.par3d.userMatrix.load(newvals);
            else if (property === "scale" || property === "FOV" || property === "zoom")
              obj.par3d[property] = newvals;
            else
              obj[property] = newvals;
          };

      if (direct && typeof value === "undefined")
        return;

      if (control.interp) {
        values = values.slice(0, ncol).concat(values).
                 concat(values.slice(ncol*(nrow-1), ncol*nrow));
        svals = [-Infinity].concat(svals).concat(Infinity);
        for (i = 1; i < svals.length; i++) {
          if (value <= svals[i]) {
            if (svals[i] === Infinity)
              p = 1;
            else
              p = (svals[i] - value)/(svals[i] - svals[i-1]);
            break;
          }
        }
      } else if (!direct) {
        value = Math.round(value);
      }

      for (j=0; j<entries.length; j++) {
        entry = entries[j];
        newprop = properties[j];
        newid = objids[j];

        if (newprop !== property || newid !== objid) {
          if (typeof property !== "undefined")
            putPropvals(propvals);
          property = newprop;
          objid = newid;
          obj = this.getObj(objid);
          propvals = getPropvals();
        }
        if (control.interp) {
          v1 = values[ncol*(i-1) + j];
          v2 = values[ncol*i + j];
          this.setElement(propvals, entry, p*v1 + (1-p)*v2);
        } else if (!direct) {
          this.setElement(propvals, entry, values[ncol*value + j]);
        } else {
          this.setElement(propvals, entry, value[j]);
        }
      }
      putPropvals(propvals);

      needsBinding = [];
      for (j=0; j < entries.length; j++) {
        if (properties[j] === "values" &&
            needsBinding.indexOf(objids[j]) === -1) {
          needsBinding.push(objids[j]);
        }
      }
      for (j=0; j < needsBinding.length; j++) {
        gl = this.gl || this.initGL();
        obj = this.getObj(needsBinding[j]);
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertices
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The vertext setter control data.
     */
    rglwidgetClass.prototype.vertexSetter = function(el, control)  {
      var svals = [].concat(control.param),
          j, k, p, a, propvals, stride, ofs, obj, entry,
          attrib, vertex, varies,
          ofss    = {x:"vofs", y:"vofs", z:"vofs",
                     red:"cofs", green:"cofs", blue:"cofs",
                     alpha:"cofs", radii:"radofs",
                     nx:"nofs", ny:"nofs", nz:"nofs",
                     ox:"oofs", oy:"oofs", oz:"oofs",
                     ts:"tofs", tt:"tofs"},
          pos     = {x:0, y:1, z:2,
                     red:0, green:1, blue:2,
                     alpha:3,radii:0,
                     nx:0, ny:1, nz:2,
                     ox:0, oy:1, oz:2,
                     ts:0, tt:1},
        values = control.values,
        direct = values === null,
        ncol,
        interp = control.interp,
        vertices = [].concat(control.vertices),
        attributes = [].concat(control.attributes),
        value = control.value, newval, aliases, alias;

      ncol = Math.max(vertices.length, attributes.length);

      if (!ncol)
        return;

      vertices = rglwidgetClass.repeatToLen(vertices, ncol);
      attributes = rglwidgetClass.repeatToLen(attributes, ncol);

      if (direct)
        interp = false;

      /* JSON doesn't pass Infinity */
      svals[0] = -Infinity;
      svals[svals.length - 1] = Infinity;

      for (j = 1; j < svals.length; j++) {
        if (value <= svals[j]) {
          if (interp) {
            if (svals[j] === Infinity)
              p = 1;
            else
              p = (svals[j] - value)/(svals[j] - svals[j-1]);
          } else {
            if (svals[j] - value > value - svals[j-1])
              j = j - 1;
          }
          break;
        }
      }

      obj = this.getObj(control.objid);
      // First, make sure color attributes vary in original
      if (typeof obj.vOffsets !== "undefined") {
      	varies = true;
        for (k = 0; k < ncol; k++) {
          attrib = attributes[k];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[attrib]];
            if (ofs < 0) {
              switch(attrib) {
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(control.objid);
      }
      propvals = obj.values;
      aliases = obj.alias;
      if (typeof aliases === "undefined")
        aliases = [];
      for (k=0; k<ncol; k++) {
        if (direct) {
          newval = value;
        } else if (interp) {
          newval = p*values[j-1][k] + (1-p)*values[j][k];
        } else {
          newval = values[j][k];
        }      	
        attrib = attributes[k];
        vertex = vertices[k];
        alias = aliases[vertex];
        if (obj.type === "planes" || obj.type === "clipplanes") {
          ofs = ["nx", "ny", "nz", "offset"].indexOf(attrib);
          if (ofs >= 0) {
            if (ofs < 3) {
              if (obj.normals[vertex][ofs] !== newval) {  // Assume no aliases here...
              	obj.normals[vertex][ofs] = newval;
              	obj.initialized = false;
              }
            } else {
              if (obj.offsets[vertex][0] !== newval) {
              	obj.offsets[vertex][0] = newval;
              	obj.initialized = false;
              }
            }
            continue;
          }
        }
        // Not a plane setting...
        ofs = obj.vOffsets[ofss[attrib]];
        if (ofs < 0)
          this.alertOnce("Attribute '"+attrib+"' not found in object "+control.objid);
        else {
          stride = obj.vOffsets.stride;
          ofs = ofs + pos[attrib];
          entry = vertex*stride + ofs;
          propvals[entry] = newval;
          if (typeof alias !== "undefined")
            for (a = 0; a < alias.length; a++)
              propvals[alias[a]*stride + ofs] = newval;
        }
      }
      if (typeof obj.buf !== "undefined") {
        var gl = this.gl || this.initGL();
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, propvals, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertex properties by age
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The age setter control data.
     */
    rglwidgetClass.prototype.ageSetter = function(el, control) {
      var objids = [].concat(control.objids),
          nobjs = objids.length,
          time = control.value,
          births = [].concat(control.births),
          ages = [].concat(control.ages),
          steps = births.length,
          j = Array(steps),
          p = Array(steps),
          i, k, l, age, j0, propvals, stride, ofs, objid, obj,
          attrib, dim, varies, alias, aliases, a, d,
          attribs = ["colors", "alpha", "radii", "vertices",
                     "normals", "origins", "texcoords",
                     "x", "y", "z",
                     "red", "green", "blue"],
          ofss    = ["cofs", "cofs", "radofs", "vofs",
                     "nofs", "oofs", "tofs",
                     "vofs", "vofs", "vofs",
                     "cofs", "cofs", "cofs"],
          dims    = [3,1,1,3,
                     3,2,2,
                     1,1,1,
                     1,1,1],
          pos     = [0,3,0,0,
                     0,0,0,
                     0,1,2,
                     0,1,2];
      /* Infinity doesn't make it through JSON */
      ages[0] = -Infinity;
      ages[ages.length-1] = Infinity;
      for (i = 0; i < steps; i++) {
        if (births[i] !== null) {  // NA in R becomes null
          age = time - births[i];
          for (j0 = 1; age > ages[j0]; j0++);
          if (ages[j0] === Infinity)
            p[i] = 1;
          else if (ages[j0] > ages[j0-1])
            p[i] = (ages[j0] - age)/(ages[j0] - ages[j0-1]);
          else
            p[i] = 0;
          j[i] = j0;
        }
      }
      // First, make sure color attributes vary in original
      for (l = 0; l < nobjs; l++) {
      	objid = objids[l];
      	obj = this.getObj(objid);
      	varies = true;
        if (typeof obj.vOffsets === "undefined")
          continue;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs < 0) {
              switch(attribs[k]) {
              	case "colors":
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(objid);
      }
      for (l = 0; l < nobjs; l++) {
        objid = objids[l];
        obj = this.getObj(objid);
        if (typeof obj.vOffsets === "undefined")
          continue;
        aliases = obj.alias;
        if (typeof aliases === "undefined")
          aliases = [];
        propvals = obj.values;
        stride = obj.vOffsets.stride;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs >= 0) {
              dim = dims[k];
              ofs = ofs + pos[k];
              for (i = 0; i < steps; i++) {
              	alias = aliases[i];
                if (births[i] !== null) {
                  for (d=0; d < dim; d++) {
                    propvals[i*stride + ofs + d] = p[i]*attrib[dim*(j[i]-1) + d] + (1-p[i])*attrib[dim*j[i] + d];
                    if (typeof alias !== "undefined")
                      for (a=0; a < alias.length; a++)
                        propvals[alias[a]*stride + ofs + d] = propvals[i*stride + ofs + d];
                  }
                }
              }
            } else
              this.alertOnce("\'"+attribs[k]+"\' property not found in object "+objid);
          }
        }
        obj.values = propvals;
        if (typeof obj.buf !== "undefined") {
          var gl = this.gl || this.initGL();
          gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
          gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
        }
      }
    };

    /**
     * Bridge to old style control
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The bridge control data.
     */
    rglwidgetClass.prototype.oldBridge = function(el, control) {
      var attrname, global = window[control.prefix + "rgl"];
      if (global)
        for (attrname in global)
          this[attrname] = global[attrname];
      window[control.prefix + "rgl"] = this;
    };

    /**
     * Set up a player control
     * @param { Object } el - The player control element
     * @param { Object } control - The player data.
     */
    rglwidgetClass.prototype.Player = function(el, control) {
      var
        self = this,
        components = [].concat(control.components),
        buttonLabels = [].concat(control.buttonLabels),

        Tick = function() { /* "this" will be a timer */
          var i,
              nominal = this.value,
              slider = this.Slider,
              labels = this.outputLabels,
              output = this.Output,
              step;
          if (typeof slider !== "undefined" && nominal !== slider.value)
            slider.value = nominal;
          if (typeof output !== "undefined") {
            step = Math.round((nominal - output.sliderMin)/output.sliderStep);
            if (labels !== null) {
              output.innerHTML = labels[step];
            } else {
              step = step*output.sliderStep + output.sliderMin;
              output.innerHTML = step.toPrecision(output.outputPrecision);
            }
          }
          for (i=0; i < this.actions.length; i++) {
            this.actions[i].value = nominal;
          }
          self.applyControls(el, this.actions, false);
          self.drawScene();
        },

        OnSliderInput = function() { /* "this" will be the slider */
          this.rgltimer.value = Number(this.value);
          this.rgltimer.Tick();
        },

        addSlider = function(min, max, step, value) {
          var slider = document.createElement("input");
          slider.type = "range";
          slider.min = min;
          slider.max = max;
          slider.step = step;
          slider.value = value;
          slider.oninput = OnSliderInput;
          slider.sliderActions = control.actions;
          slider.sliderScene = this;
          slider.className = "rgl-slider";
          slider.id = el.id + "-slider";
          el.rgltimer.Slider = slider;
          slider.rgltimer = el.rgltimer;
          el.appendChild(slider);
        },

        addLabel = function(labels, min, step, precision) {
          var output = document.createElement("output");
          output.sliderMin = min;
          output.sliderStep = step;
          output.outputPrecision = precision;
          output.className = "rgl-label";
          output.id = el.id + "-label";
          el.rgltimer.Output = output;
          el.rgltimer.outputLabels = labels;
          el.appendChild(output);
        },

        addButton = function(which, label, active) {
          var button = document.createElement("input"),
              onclicks = {Reverse: function() { this.rgltimer.reverse();},
                    Play: function() { this.rgltimer.play();
                                       this.value = this.rgltimer.enabled ? this.inactiveValue : this.activeValue; },
                   Slower: function() { this.rgltimer.slower(); },
                   Faster: function() { this.rgltimer.faster(); },
                   Reset: function() { this.rgltimer.reset(); },
              	   Step:  function() { this.rgltimer.step(); }
              };
          button.rgltimer = el.rgltimer;
          button.type = "button";
          button.value = label;
          button.activeValue = label;
          button.inactiveValue = active;
          if (which === "Play")
            button.rgltimer.PlayButton = button;
          button.onclick = onclicks[which];
          button.className = "rgl-button";
          button.id = el.id + "-" + which;
          el.appendChild(button);
        };

        if (typeof control.reinit !== "undefined" && control.reinit !== null) {
          control.actions.reinit = control.reinit;
        }
        el.rgltimer = new rgltimerClass(Tick, control.start, control.interval, control.stop,
                                        control.step, control.value, control.rate, control.loop, control.actions);
        for (var i=0; i < components.length; i++) {
          switch(components[i]) {
            case "Slider": addSlider(control.start, control.stop,
                                   control.step, control.value);
              break;
            case "Label": addLabel(control.labels, control.start,
                                   control.step, control.precision);
              break;
            default:
              addButton(components[i], buttonLabels[i], control.pause);
          }
        }
        el.rgltimer.Tick();
    };

    /**
     * Apply all registered controls
     * @param { Object } el - DOM element of the control
     * @param { Object } x - List of actions to apply
     * @param { boolean } [draw=true] - Whether to redraw after applying
     */
    rglwidgetClass.prototype.applyControls = function(el, x, draw) {
      var self = this, reinit = x.reinit, i, control, type;
      for (i = 0; i < x.length; i++) {
        control = x[i];
        type = control.type;
        self[type](el, control);
      }
      if (typeof reinit !== "undefined" && reinit !== null) {
        reinit = [].concat(reinit);
        for (i = 0; i < reinit.length; i++)
          self.getObj(reinit[i]).initialized = false;
      }
      if (typeof draw === "undefined" || draw)
        self.drawScene();
    };

    /**
     * Handler for scene change
     * @param { Object } message - What sort of scene change to do?
     */
    rglwidgetClass.prototype.sceneChangeHandler = function(message) {
      var self = document.getElementById(message.elementId).rglinstance,
          objs = message.objects, mat = message.material,
          root = message.rootSubscene,
          initSubs = message.initSubscenes,
          redraw = message.redrawScene,
          skipRedraw = message.skipRedraw,
          deletes, subs, allsubs = [], i,j;
      if (typeof message.delete !== "undefined") {
        deletes = [].concat(message.delete);
        if (typeof message.delfromSubscenes !== "undefined")
          subs = [].concat(message.delfromSubscenes);
        else
          subs = [];
        for (i = 0; i < deletes.length; i++) {
          for (j = 0; j < subs.length; j++) {
            self.delFromSubscene(deletes[i], subs[j]);
          }
          delete self.scene.objects[deletes[i]];
        }
      }
      if (typeof objs !== "undefined") {
        Object.keys(objs).forEach(function(key){
          key = parseInt(key, 10);
          self.scene.objects[key] = objs[key];
          self.initObjId(key);
          var obj = self.getObj(key),
              subs = [].concat(obj.inSubscenes), k;
          allsubs = allsubs.concat(subs);
          for (k = 0; k < subs.length; k++)
            self.addToSubscene(key, subs[k]);
        });
      }
      if (typeof mat !== "undefined") {
        self.scene.material = mat;
      }
      if (typeof root !== "undefined") {
        self.scene.rootSubscene = root;
      }
      if (typeof initSubs !== "undefined")
        allsubs = allsubs.concat(initSubs);
      allsubs = self.unique(allsubs);
      for (i = 0; i < allsubs.length; i++) {
        self.initSubscene(allsubs[i]);
      }
      if (typeof skipRedraw !== "undefined") {
        root = self.getObj(self.scene.rootSubscene);
        root.par3d.skipRedraw = skipRedraw;
      }
      if (redraw)
        self.drawScene();
    };
</script>
<script>    /**
     * Methods related to selection
     * @name ___METHODS_FOR_SELECTION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Respond to brush change
     */
    rglwidgetClass.prototype.selectionChanged = function() {
      var i, j, k, id, subid = this.select.subscene, subscene,
          objids, obj,
          p1 = this.select.region.p1, p2 = this.select.region.p2,
          filter, selection = [], handle, keys, xmin, x, xmax, ymin, y, ymax, z, v,
          someHidden;
      if (!subid)
        return;
      subscene = this.getObj(subid);
      objids = subscene.objects;
      filter = this.scene.crosstalk.filter;
      this.setmvMatrix(subid);
      this.setprMatrix(subid);
      this.setprmvMatrix();
      xmin = Math.min(p1.x, p2.x);
      xmax = Math.max(p1.x, p2.x);
      ymin = Math.min(p1.y, p2.y);
      ymax = Math.max(p1.y, p2.y);
      for (i = 0; i < objids.length; i++) {
      	id = objids[i];
      	j = this.scene.crosstalk.id.indexOf(id);
      	if (j >= 0) {
      	  keys = this.scene.crosstalk.key[j];
      	  obj = this.getObj(id);
      	  someHidden = false;
      	  for (k = 0; k < keys.length; k++) {
      	    if (filter && filter.indexOf(keys[k]) < 0) {
      	      someHidden = true;
      	      continue;
      	    }
      	    v = [].concat(obj.vertices[k]).concat(1.0);
            v = rglwidgetClass.multVM(v, this.prmvMatrix);
            x = v[0]/v[3];
            y = v[1]/v[3];
            z = v[2]/v[3];
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax && -1.0 <= z && z <= 1.0) {
              selection.push(keys[k]);
            } else
              someHidden = true;
      	  }
      	  obj.someHidden = someHidden && (filter || selection.length);
      	  obj.initialized = false;
      	  /* Who should we notify?  Only shared data in the current subscene, or everyone? */
      	  if (!this.equalArrays(selection, this.scene.crosstalk.selection)) {
      	    handle = this.scene.crosstalk.sel_handle[j];
      	    handle.set(selection, {rglSubsceneId: this.select.subscene});
      	  }
      	}
      }
    };
    
    /**
     * Respond to selection or filter change from crosstalk
     * @param { Object } event - crosstalk event
     * @param { boolean } filter - filter or selection?
     */
    rglwidgetClass.prototype.selection = function(event, filter) {
      	var i, j, ids, obj, keys, crosstalk = this.scene.crosstalk,
      	    selection, someHidden;

      	// Record the message and find out if this event makes some objects have mixed values:
      	
      	crosstalk = this.scene.crosstalk;
      	
      	if (filter) {
      	  filter = crosstalk.filter = event.value;
      	  selection = crosstalk.selection;
      	} else {  
          selection = crosstalk.selection = event.value;
          filter = crosstalk.filter;
      	}
        ids = crosstalk.id;
        for (i = 0; i < ids.length ; i++) {
          obj = this.getObj(ids[i]);
          obj.initialized = false;
          keys = crosstalk.key[i];
          someHidden = false;
          for (j = 0; j < keys.length && !someHidden; j++) {
            if ((filter && filter.indexOf(keys[j]) < 0) ||
                (selection.length && selection.indexOf(keys[j]) < 0))
                someHidden = true;
          }
          obj.someHidden = someHidden;
        }
        this.drawScene();
    };
    
    /**
     * Clear the selection brush
     * @param { number } except - Subscene that should ignore this request
     */
    rglwidgetClass.prototype.clearBrush = function(except) {
      if (this.select.subscene !== except) {
        this.select.region = {p1: {x:Infinity, y:Infinity}, 
                              p2: {x:Infinity, y:Infinity}};
        this.selectionChanged();
        this.select.state = "inactive";
        this.delFromSubscene(this.scene.brushId, this.select.subscene);
      }
      this.drawScene();
    };
    
    /**
     * Set the vertices in the selection box object
     */
    rglwidgetClass.prototype.initSelection = function(id) {
      if (typeof this.select.region === "undefined")
        return;
      var obj = this.getObj(id),
          p1 = this.select.region.p1,
          p2 = this.select.region.p2;
          
      obj.vertices = [[p1.x, p1.y, 0.0],
                      [p2.x, p1.y, 0.0],
                      [p2.x, p2.y, 0.0],
                      [p1.x, p2.y, 0.0],
                      [p1.x, p1.y, 0.0]];
    };
</script>
<script>
/* globals rgltimerClass: true */

/**
 * The class of an rgl timer object
 * @class
*/

/**
 * Construct an rgltimerClass object
 * @constructor
 * @param { function } Tick - action when timer fires
 * @param { number } startTime - nominal start time in seconds
 * @param { number } interval - seconds between updates
 * @param { number } stopTime - nominal stop time in seconds
 * @param { number } stepSize - nominal step size
 * @param { number } value - current nominal time
 * @param { number } rate - nominal units per second
 * @param { string } loop - "none", "cycle" or "oscillate"
 * @param { Object } actions - list of actions
 */
rgltimerClass = function(Tick, startTime, interval, stopTime, stepSize, value, rate, loop, actions) {
  this.enabled = false;
  this.timerId = 0;
  /** nominal start time in seconds */
  this.startTime = startTime;   
  /** current nominal time */      
  this.value = value;
  /** seconds between updates */                 
  this.interval = interval;
  /** nominal stop time */           
  this.stopTime = stopTime;
  /** nominal step size */           
  this.stepSize = stepSize;
  /** nominal units per second */           
  this.rate = rate;
  /** "none", "cycle", or "oscillate" */                   
  this.loop = loop;
  /** real world start time */                   
  this.realStart = undefined;
  /** multiplier for fast-forward or reverse */         
  this.multiplier = 1;                
  this.actions = actions;
  this.Tick = Tick;
};


    /**
     * Methods related to players
     * @name ___METHODS_FOR_PLAYERS___
     * @memberof rgltimerClass
     * @kind function
     * @instance
     */

  /**
   * Start playing
   * @memberof rgltimerClass
   */
  rgltimerClass.prototype.play = function() {
    if (this.enabled) {
      this.enabled = false;
      window.clearInterval(this.timerId);
      this.timerId = 0;
      return;
    }
    var tick = function(self) {
      var now = new Date();
      self.value = self.multiplier*self.rate*(now - self.realStart)/1000 + self.startTime;
      self.forceToRange();
      if (typeof self.Tick !== "undefined") {
        self.Tick(self.value);
      }

    };
    this.realStart = new Date() - 1000*(this.value - this.startTime)/this.rate/this.multiplier;
    this.timerId = window.setInterval(tick, 1000*this.interval, this);
    this.enabled = true;
  };

  /**
   * Force value into legal range
   */
  rgltimerClass.prototype.forceToRange = function() {
    if (this.value > this.stopTime + this.stepSize/2 || this.value < this.startTime - this.stepSize/2) {
      if (!this.loop) {
        this.reset();
      } else {
        var cycle = this.stopTime - this.startTime + this.stepSize,
            newval = (this.value - this.startTime) % cycle + this.startTime;
        if (newval < this.startTime) {
          newval += cycle;
        }
        this.realStart += (this.value - newval)*1000/this.multiplier/this.rate;
        this.value = newval;
      }
    }
  };

  /**
   * Reset to start values
   */
  rgltimerClass.prototype.reset = function() {
    this.value = this.startTime;
    this.newmultiplier(1);
    if (typeof this.Tick !== "undefined") {
        this.Tick(this.value);
    }
    if (this.enabled)
      this.play();  /* really pause... */
    if (typeof this.PlayButton !== "undefined")
      this.PlayButton.value = "Play";
  };

  /**
   * Increase the multiplier to play faster
   */
  rgltimerClass.prototype.faster = function() {
    this.newmultiplier(Math.SQRT2*this.multiplier);
  };

  /**
   * Decrease the multiplier to play slower
   */
  rgltimerClass.prototype.slower = function() {
    this.newmultiplier(this.multiplier/Math.SQRT2);
  };

  /**
   * Change sign of multiplier to reverse direction
   */
  rgltimerClass.prototype.reverse = function() {
    this.newmultiplier(-this.multiplier);
  };

  /**
   * Set multiplier for play speed
   * @param { number } newmult - new value
   */
  rgltimerClass.prototype.newmultiplier = function(newmult) {
    if (newmult !== this.multiplier) {
      this.realStart += 1000*(this.value - this.startTime)/this.rate*(1/this.multiplier - 1/newmult);
      this.multiplier = newmult;
    }
  };

  /**
   * Take one step
   */
  rgltimerClass.prototype.step = function() {
    this.value += this.rate*this.multiplier;
    this.forceToRange();
    if (typeof this.Tick !== "undefined")
      this.Tick(this.value);
  };
</script>
<script>/**
 * Pretty function from R
 * @name ___PRETTY_FROM_R___
 * @memberof rglwidgetClass
 * @kind function
 * @instance
 */


/* This file is translated from pretty.c, which was
 taken from the R sources, r61744 of src/appl/pretty.c,
 with minimal changes */

/*
 *  R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995-2012  The R Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

/**     
 * Construct pretty values to cover an interval
 * @param { number } lo - lower end of interval
 * @param { number } up - upper end of interval
 * @param { number } ndiv - requested number of divisions
 * @param { number } min_n - minimum divisions
 * @param { number } shrink_sml - if too many cells, amount to shrink by
 * @param { number } high_u_fact - bias in favour of larger units
 * @param { number } eps_correction - correction to bounds
 * @param { Boolean } return_bounds - whether to return bounds
 * @description
 * Pretty Intervals

 * Constructs m "pretty" values which cover the given interval	*lo <= *up
 *	m ~= *ndiv + 1	(i.e., ndiv := approximate number of INTERVALS)
 *
 * It is not quite clear what should happen for	 *lo = *up;
 * S itself behaves quite funilly, then.
 *
 * In my opinion, a proper 'pretty' should always ensure
 * *lo < *up, and hence *ndiv >=1 in the result.
 * However, in S and here, we allow  *lo == *up, and *ndiv = 0.
 * Note however, that we are NOT COMPATIBLE to S. [Martin M.]
 *
 * NEW (0.63.2): ns, nu are double (==> no danger of integer overflow)
 *
 * We determine
 * if the interval (up - lo) is ``small'' [<==>	 i_small == TRUE, below].
 * For the ``i_small'' situation, there is a parameter  shrink_sml,
 * the factor by which the "scale" is shrunk.		~~~~~~~~~~
 * It is advisable to set it to some (smaller) integer power of 2,
 * since this enables exact floating point division.
 */
rglwidgetClass.prototype.R_pretty = function(
  lo, up, ndiv, min_n, shrink_sml, high_u_fact,
  eps_correction, return_bounds) {
  /* From version 0.65 on, we had rounding_eps := 1e-5, before, r..eps = 0
   * 1e-7 is consistent with seq.default() */
  var rounding_eps = 1e-7,  h = high_u_fact[0],
                                           h5 = high_u_fact[1], 
                                                           dx, cell, unit, base, U, ns, nu, k, i_small,
                                                           DBL_EPSILON = Number.EPSILON,
                                                           DBL_MIN = Number.MIN_VALUE,
                                                           DBL_MAX = Number.MAX_VALUE;
  
  dx = up - lo;
  /* cell := "scale"	here */
  if (dx === 0 && up === 0) { /*  up == lo == 0	 */
  cell = 1;
    i_small = true;
  } else {
    cell = Math.max(Math.abs(lo), Math.abs(up));
    /* U = upper bound on cell/unit */
    U = (1 + (h5 >= 1.5*h+0.5)) ? 1/(1+h) : 1.5/(1+h5);
    /* added times 3, as several calculations here */
    i_small = dx < cell * U * Math.max(1,ndiv) * DBL_EPSILON *3;
  }
  
  /*OLD: cell = FLT_EPSILON+ dx / *ndiv; FLT_EPSILON = 1.192e-07 */
  if(i_small) {
    if(cell > 10)
      cell = 9 + cell/10;
    cell *= shrink_sml;
    if(min_n > 1) cell /= min_n;
  } else {
    cell = dx;
    if(ndiv > 1) cell /= ndiv;
  }
  
  if(cell < 20*DBL_MIN) {
    /* warning(_("Internal(pretty()): very small range.. corrected")); */
    cell = 20*DBL_MIN;
  } else if(cell * 10 > DBL_MAX) {
    /* warning(_("Internal(pretty()): very large range.. corrected")); */
    cell = 0.1*DBL_MAX;
  }
  base = Math.pow(10, Math.floor(Math.log10(cell))); /* base <= cell < 10*base */
    
    /* unit : from { 1,2,5,10 } * base
     *	 such that |u - cell| is small,
     * favoring larger (if h > 1, else smaller)  u  values;
     * favor '5' more than '2'  if h5 > h  (default h5 = .5 + 1.5 h) */
    unit = base;
    if((U = 2*base)-cell <  h*(cell-unit)) { unit = U;
      if((U = 5*base)-cell < h5*(cell-unit)) { unit = U;
        if((U =10*base)-cell <  h*(cell-unit)) unit = U; }}
    /* Result: c := cell,  u := unit,  b := base
     *	c in [	1,	      (2+ h) /(1+h) ] b ==> u=  b
     *	c in ( (2+ h)/(1+h),  (5+2h5)/(1+h5)] b ==> u= 2b
     *	c in ( (5+2h)/(1+h), (10+5h) /(1+h) ] b ==> u= 5b
     *	c in ((10+5h)/(1+h),	         10 ) b ==> u=10b
     *
     *	===>	2/5 *(2+h)/(1+h)  <=  c/u  <=  (2+h)/(1+h)	*/
    
    ns = Math.floor(lo/unit+rounding_eps);
    nu = Math.ceil (up/unit-rounding_eps);
    
    if(eps_correction && (eps_correction > 1 || !i_small)) {
      if(lo !== 0.0) lo *= (1- DBL_EPSILON); else lo = -DBL_MIN;
      if(up !== 0.0) up *= (1+ DBL_EPSILON); else up = +DBL_MIN;
    }
    
    while(ns*unit > lo + rounding_eps*unit) ns--;
    
    while(nu*unit < up - rounding_eps*unit) nu++;
    
    k = Math.floor(0.5 + nu - ns);
    if(k < min_n) {
      /* ensure that	nu - ns	 == min_n */
      
      k = min_n - k;
      if(ns >= 0) {
        nu += k/2;
        ns -= k/2 + k%2;/* ==> nu-ns = old(nu-ns) + min_n -k = min_n */
      } else {
        ns -= k/2;
        nu += k/2 + k%2;
      }
      ndiv = min_n;
    } else {
      ndiv = k;
    }
    if(return_bounds) { /* if()'s to ensure that result covers original range */
      if(ns * unit < lo) lo = ns * unit;
      if(nu * unit > up) up = nu * unit;
    } else {
      lo = ns;
      up = nu;
    }
    return {lo:lo, up:up, ndiv:ndiv, unit:unit};
};
</script>
<script>    /**
     * Methods related to axes
     * @name ___METHODS_FOR_AXES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Choose edges for ticks
     * @param { Matrix } prmv - projection-model-view matrix
     */
    rglwidgetClass.prototype.getTickEdges = function(prmv){
      var vertices = [[0,0,0,1], [0,0,1,1],
                      [0,1,0,1], [0,1,1,1],
                      [1,0,0,1], [1,0,1,1],
                      [1,1,0,1], [1,1,1,1]], 
           dim, i, j, k, edges, hull, step, result = [], proj = [],

        // Filter to edges that are on sides that would
        // be shown with a filled backing.
        
      has_back = function(edge) {
          var normals = [[], []],
              verts = [vertices[edge[0]], 
                       vertices[edge[1]]], 
              normal, m, n;
          n = 0;
          for (m=0; m<3; m++) {
            if (verts[0][m] === verts[1][m]) {
              normals[n] = [0,0,0,1];
              normals[n][m] = 2*verts[0][m] - 1;
              n++;
            }
          }
          for (n=0; n<2; n++) {
            normal = rglwidgetClass.multVM(normals[n], self.normMatrix);
            if (normal[2] < 0 ||
                (normal[2] === 0 && normal[0] < 0))
              return true;
          }
          return false;
        }, self = this;
        
      for (i = 0; i < vertices.length; i++) {
        proj[i] = rglwidgetClass.multVM(vertices[i], prmv);
        proj[i][0] = proj[i][0]/proj[i][3];
        proj[i][1] = proj[i][1]/proj[i][3];
        proj[i][2] = i;
      }
      hull = rglwidgetClass.chull(proj.slice());  
      for (i = 0; i < hull.length; i++)
        hull[i] = hull[i][2];
      hull.push(hull[0]);
      for (dim = 0; dim < 3; dim++) { 
        edges = [];
        step = Math.pow(2, 2-dim);
        for (i = 0; i < 4; i++) {
          j = (dim === 0) ? i : (dim === 1) ? i + 2*(i>1) : 2*i;
          for (k = 0; k < hull.length - 1; k++) {
            if ((hull[k] === j && hull[k+1] === j + step) ||
                (hull[k] === j+step && hull[k+1] === j))
          
              edges.push([j, j+step], [j+step, j]);
          }
        }

        edges = edges.filter(has_back);
        
        // Find the edge with a vertex closest
        // to the bottom left corner
        if (edges.length) {
          var best, best2, val = Infinity, newval;
          for (i = 0; i < edges.length; i++) {
            j = edges[i][0];
            newval = proj[j][0] + proj[j][1];
            if (newval < val) {
              best = j;
              best2 = edges[i][1];
              val = newval;
            }
          }
          if (typeof best !== "undefined") {
            result[dim] = vertices[best].slice(0,3);
            result[dim][dim] = undefined;
          } else
            result[dim] = undefined;
        }
      }
      return result;
    };
    
    /**
     * Choose tick locations
     * @param { Object } obj - The bboxdeco
    */
    rglwidgetClass.prototype.getTickLocations = function(obj){
      var dim, i, limits, locations = [], result = [[],[],[]], value,
          len, delta, range, bbox = obj.bbox;
      obj.needsAxisCallback = false;
      for (dim = 0; dim < 3; dim++) {
        limits = bbox.slice(2*dim, 2*dim + 2);
        range = limits[1] - limits[0];
        switch(obj.axes.mode[dim]) {
        case "custom":
          for (i=0; i < obj.vertices.length; i++) {
            value = (obj.vertices[i][dim] - limits[0])/range;
            if (typeof value !== "undefined" &&
                !isNaN(value))
              result[dim].push(value);
          }
          break;
        case "fixedstep":
          len = Math.floor(range/obj.axes.step[dim]);
          delta = obj.axes.step[dim];
          for (i = 0; i < len; i++)
            result[dim].push(i*delta);          
          break;
        case "fixednum":
          len = obj.axes.nticks[dim];
          delta = (len > 1) ? range/(len-1) : 0;
          for (i = 0; i < len; i++)
            result[dim].push(i*delta/range);
          break;
        case "pretty":
          locations = this.R_pretty(limits[0], limits[1], 5,
                                  2, // min_n
                                  0.75, // shrink_sml
                                  [1.5, 2.75], // high_u_fact
                                  0, // eps_correction
                                  0); // return_bounds)  
          for (i = locations.lo; i <= locations.up; i++) {
            value = (i*locations.unit - limits[0])/range;
            if (0 < value && value < 1)
              result[dim].push(value);
          }
          break;
        case "user":
          obj.needsAxisCallback = true;
          break;
        }
      }
      return result;
    };
    
    /**
     * Set tick vertices
     * @param { Object } ticks - the tick object
     * @param { Array }  edges - Which edges get the ticks?
    */
    rglwidgetClass.prototype.getTickVertices = function(ticks) {
      var dim, i, j, vertices = [], locations, 
          edges = ticks.edges, edge;
      for (dim = 0; dim < 3; dim++) {
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) 
            if (typeof edges[dim] !== "undefined") {
              edge = edges[dim].slice();
              edge[dim] = locations[i];
              vertices.push(edge);
              edge = edge.slice();
              for (j = 0; j < 3; j++)       
                if ((dim < 2 && j === 1 - dim) || 
                    (dim === 2 && j === 0))
                  edge[j] += 2*(edge[j] - 0.5)/ticks.axes.marklen[dim];
              vertices.push(edge);
            }
        }
      ticks.vertices = vertices;
      ticks.vertexCount = vertices.length;
      ticks.values = new Float32Array(rglwidgetClass.flatten(vertices));
      ticks.initialized = false;
    };
    
    /**
     * Set tick label positions
     * @param { Object } obj - the bbox object
    */
    rglwidgetClass.prototype.placeTickLabels = function(obj) {
      var ticks = obj.ticks, labels = obj.labels, i,j,k,
          vertices = [], tickvertices = ticks.vertices, 
          vertex, locations, dim, edges = obj.ticks.edges;
      j = 0;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) {
            if (isNaN(locations[i]))
              continue;
            while (j < tickvertices.length && 
                   tickvertices[j][dim] !== locations[i]) j++;
            if (j >= tickvertices.length)
              break;
            vertex = tickvertices[j].slice();
            for (k = 0; k < 3; k++)
              vertex[k] += 2*(tickvertices[j+1][k] - vertex[k]);
            vertices.push(vertex);
            j += 2;
          }
        }
      labels.vertices = vertices;
      labels.centers = labels.vertices;
      labels.initialized = false;
    };  
     
    /**
     * Set tick labels
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setTickLabels = function(obj) {
      var ticks = obj.ticks, mode, locations, labels = [],
      start = 0, nticks, dim, i, limits, range, values, max,
      edges = obj.ticks.edges;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        mode = obj.axes.mode[dim];
        nticks = obj.axes.nticks[dim]; // used on input only for custom!
        if (mode === "custom") 
          labels = labels.concat(obj.texts.slice(start, start + nticks));
        else {
          limits = obj.bbox.slice(2*dim, 2*(dim+1));
          range = limits[1] - limits[0];
          locations = ticks.locations[dim];
          max = -Infinity;
          values = [];
          for (i = 0; i < locations.length; i++) {
            values.push(limits[0] + range*locations[i]);
            max = Math.max(max, Math.abs(values[i]));
          }
          for (i = 0; i < locations.length; i++) {
            if (Math.abs(values[i])/max < Math.pow(10, -5))
              values[i] = 0;
            labels.push(rglwidgetClass.signif(values[i], 4).toString());
          }
          obj.axes.nticks[dim] = locations.length;  
        }
        start += nticks;
      }
      obj.labels.texts = labels;
    };

    /**
     * Set bboxdeco bbox and center vector 
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setBbox = function(obj, subscene) {
      var i, expand, center = [], bbox;
      if (!obj.initialized)
        this.initBBox(obj);
        
      bbox = [].concat(subscene.par3d.bbox);
      for (i = 0; i < 3; i++) {
        expand = obj.axes.expand[i];
        center[i] = (bbox[2*i] + bbox[2*i + 1])/2;
        bbox[2*i] = center[i] - expand*(bbox[2*i + 1] - center[i]);
        bbox[2*i+1] = center[i] + expand*(bbox[2*i + 1] - center[i]);
      }
      obj.bbox = bbox;
      obj.center = center;
    };

    rglwidgetClass.prototype.setBBoxMatrices = function(obj) {
      var saved = {normMatrix: new CanvasMatrix4(this.normMatrix),
                   mvMatrix: new CanvasMatrix4(this.mvMatrix)},
          bboxNorm, bboxMV, bbox = obj.bbox, scale;
          
      bboxNorm = new CanvasMatrix4();
      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];
      bboxNorm.scale(1/scale[0], 1/scale[1], 1/scale[2]);
      bboxNorm.multRight(saved.normMatrix);
      this.normMatrix = bboxNorm;

      bboxMV = new CanvasMatrix4();
      bboxMV.scale(scale[0], scale[1], scale[2]);
      bboxMV.translate(bbox[0], bbox[2], bbox[4]);
      bboxMV.multRight(saved.mvMatrix);
      this.mvMatrix = obj.mvMatrix = bboxMV;
      
      if (this.prmvMatrix === null)
        saved.prmvMatrix = null;
      else
        saved.prmvMatrix = new CanvasMatrix4(this.prmvMatrix);
        
      this.setprmvMatrix();
      obj.prmvMatrix = this.prmvMatrix;
      
      return saved;
    };
    
    rglwidgetClass.prototype.restoreBBoxMatrices = function(saved) {
      this.normMatrix = saved.normMatrix;
      this.mvMatrix   = saved.mvMatrix;
      this.prmvMatrix = saved.prmvMatrix;
    };
    
    rglwidgetClass.prototype.getMarginParameters = function(bboxdeco, material) {
      // Assume we've run this.setBbox(bboxdeco, subscene);
      var bbox = bboxdeco.bbox,
          edge = [].concat(material.edge),
          saved, edges, i, 
          at = material.margin, line, level, trans, scale;

      if (material.floating) {
        saved = this.setBBoxMatrices(bboxdeco);
        edges = this.getTickEdges(this.prmvMatrix)[at];
        this.restoreBBoxMatrices(saved);
        if (typeof edges !== "undefined")
          for (i = 0; i < 3; i++) {
            if (edges[i] < 1) edges[i] = -1;
              edge[i] = edge[i]*edges[i];
        } else
          return undefined;
      }
      switch(at) {
      case 0: line = 1;
              level = 2;
              break;
      case 1: line = 0;
              level = 2;
              break;
      case 2: line = 0;
              level = 1;
              break;
      }
      scale = [edge[0]*(bbox[1]-bbox[0])/bboxdeco.axes.marklen[0], 
               edge[1]*(bbox[3]-bbox[2])/bboxdeco.axes.marklen[1], 
               edge[2]*(bbox[5]-bbox[4])/bboxdeco.axes.marklen[2]];
      trans = [edge[0] === 1 ? bbox[1] : bbox[0],
               edge[1] === 1 ? bbox[3] : bbox[2],
               edge[2] === 1 ? bbox[5] : bbox[4]];
      return {at: at, line: line, level: level, trans: trans, scale: scale};        
    };
    
    rglwidgetClass.prototype.fixVertex = function(orig, parms, center, bbox) {
      var vertex = [0,0,0];
      if (rglwidgetClass.missing(orig[0]))
        vertex[parms.at] = center[parms.at];
      else if (orig[0] === "-Inf")
        vertex[parms.at] = bbox[2*parms.at];
      else if (orig[0] === "Inf")
        vertex[parms.at] = bbox[2*parms.at + 1];
      else
        vertex[parms.at] = orig[0];
      vertex[parms.line] = parms.scale[parms.line]*orig[1] + 
          parms.trans[parms.line];
      vertex[parms.level] = parms.scale[parms.level]*orig[2] + 
          parms.trans[parms.level];
      return vertex;
    };
    
    rglwidgetClass.prototype.fixNormal = function(orig, parms) {
      var vertex = [0,0,0];
      vertex[parms.at] = orig[0];
      vertex[parms.line] = orig[1]/parms.scale[parms.line];
      vertex[parms.level] = orig[2]/parms.scale[parms.level];
      return vertex;
    };

    rglwidgetClass.prototype.marginVecToDataVec = function(obj, subscene) {
      var bboxdeco = this.getBBoxDeco(subscene),
          center, bbox, parms, parmsjson,
          orig = obj.orig, 
          vertices = [], normals = [],
          centers = [], i, vertex;
      if (typeof orig === "undefined") {
        orig = {vert: obj.vertices,
                norm: obj.normals,
                cent: obj.centers,
                doNormals: typeof obj.normals !== "undefined",
                doCenters: typeof obj.centers !== "undefined",
                parms: ""
               };
        obj.orig = orig;
      }

      if (typeof bboxdeco !== "undefined") {
        this.setBbox(bboxdeco, subscene);
        center = bboxdeco.center;
        bbox = bboxdeco.bbox;
        parms = this.getMarginParameters(bboxdeco, obj.material);
        if (typeof parms === "undefined")
          return false;  /* axis is not currently shown */
        
        parmsjson = JSON.stringify(parms);
        if (parmsjson === orig.parms)
          return true;  /* nothing has changed */
    
        orig.parms = parmsjson;
        
        for (i=0; i < orig.vert.length; i++) {
          vertex = this.fixVertex(orig.vert[i], parms, center, bbox);
          vertices.push(vertex);
        }
        obj.vertices = vertices;
        if (orig.doNormals) {
          for (i=0; i < orig.norm.length; i++) {
            vertex = this.fixNormal(orig.norm[i], parms);
            normals.push(vertex);
          }
          obj.normals = normals;
        }
        if (orig.doCenters) {
          for (i=0; i < orig.cent.length; i++) {
            vertex = this.fixVertex(orig.cent[i], parms, center, bbox);
            centers.push(vertex);
          }
          obj.centers = centers;
        }
        
        obj.initialized = false;
        return true;
      } else {
        console.warn("bboxdeco not found");
        return false;
      }
    };

    rglwidgetClass.prototype.doAxisCallback = function(obj, edges) {
      var i, j, code, axis, fn;
      for (i = 0; i < 3; i++) {
        if (obj.axes.mode[i] === "user") {
          axis = ["x", "y", "z"][i];
          if (typeof obj.callbacks !== "undefined" &&
              typeof (code = obj.callbacks[axis]) !== "undefined") {
            if (typeof edges[i] !== "undefined")
              for (j = 0; j < 3; j++)
                if (typeof edges[i][j] !== "undefined")
                  axis = axis + (edges[i][j] > 0 ? "+" : "-");
            
          /* jshint evil:true */
            fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
            fn.call(this, axis);
          }
        }
      }
    };
</script>
<script>/**
     * Methods related to animations
     * @name ___METHODS_FOR_ANIMATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Binary search
     * @param x - x coordinates in increasing order
     * @param newx - value to find, assumed to be in the range of x
     * @result index of largest x value below newx
     */
    rglwidgetClass.bisect = function(x, newx) {
      var lo = 0, hi = x.length - 1, mid;
      while (lo < hi - 1) {
        mid = Math.round((lo + hi)/2);
        if (x[mid] < newx)
          lo = mid;
        else
          hi = mid;
      }
      return lo;
    };
    
    /**
     * Step interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.step = function(x, v, newx) {
      var n, lo;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      return v[lo];
    };
    
    /**
     * Linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.lerp = function(x, v, newx) {
      var i, n, lo, hi, alpha, result;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      alpha = (newx - x[lo])/(x[hi] - x[lo]);
      result = v[lo];
      n = result.length;
      if (typeof n !== "undefined") {
        for (i = 0; i < n; i++)
          result[i] = (1 - alpha)*result[i] + alpha*v[hi][i];
      } else
        result = (1 - alpha)*result + alpha*v[hi];
      return result;
    };
    
    /**
     * Spherical linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - a matrix of unit quaternions
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.slerp = function(x, v, newx) {
      var n, lo, hi, alpha, result,
          p0, p1, dot, Omega, alpha0, alpha1, len;
      if (newx <= x[0])
        return v[0];    
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      p0 = v[lo];
      p1 = v[hi];
      dot = p0[0]*p1[0] + 
            p0[1]*p1[1] +
            p0[2]*p1[2] +
            p0[3]*p1[3];
      if (dot < 0) {
        p1 = [-p1[0], -p1[1], -p1[2], -p1[3]];
        dot = -dot;
      }
      if (dot >= 1)
        result = p1;
      else {
        alpha = (newx - x[lo])/(x[hi] - x[lo]);
        Omega = Math.acos(dot);
        alpha0 = Math.sin((1 - alpha)*Omega);
        alpha1 = Math.sin(alpha*Omega);
        result = [alpha0*p0[0] + alpha1*p1[0],
                  alpha0*p0[1] + alpha1*p1[1],
                  alpha0*p0[2] + alpha1*p1[2],
                  alpha0*p0[3] + alpha1*p1[3]];
      }
      len = Math.sqrt(result[0]*result[0] +
                      result[1]*result[1] +
                      result[2]*result[2] +
                      result[3]*result[3]);
      return [result[0]/len,
              result[1]/len,
              result[2]/len,
              result[3]/len];
    };

    /**
     * Rotate using unit quaternion
     * @param q - a single unit quaternion
     */
    rglwidgetClass.rotateByQuaternion = function(M, q) {

    var xx = q[0]*q[0],
        xy = q[0]*q[1],
        xz = q[0]*q[2],
        xw = q[0]*q[3],
        yy = q[1]*q[1],
        yz = q[1]*q[2],
        yw = q[1]*q[3],
        zz = q[2]*q[2],
        zw = q[2]*q[3],
        matrix = new CanvasMatrix4();
      matrix.m11 = 1 - 2*(yy + zz);
      matrix.m12 = 2*(xy + zw);
      matrix.m13 = 2*(xz - yw);
        
      matrix.m21 = 2*(xy - zw);
      matrix.m22 = 1 - 2*(xx + zz);
      matrix.m23 = 2*(yz + xw);

      matrix.m31 = 2*(xz + yw);
      matrix.m32 = 2*(yz - xw);
      matrix.m33 = 1 - 2*(xx + yy);

      M.multRight(matrix);      
    };
</script>
<script>/* globals CanvasMatrix4: true */
/* globals WebGLFloatArray */
/* jshint eqeqeq: false */
/*
 * Copyright (C) 2009 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Copyright (2016) Duncan Murdoch - fixed CanvasMatrix4.ortho,
 * cleaned up.
 */
/*
    CanvasMatrix4 class

    This class implements a 4x4 matrix. It has functions which
    duplicate the functionality of the OpenGL matrix stack and
    glut functions.

    IDL:

    [
        Constructor(in CanvasMatrix4 matrix),           // copy passed matrix into new CanvasMatrix4
        Constructor(in sequence<float> array)           // create new CanvasMatrix4 with 16 floats (row major)
        Constructor()                                   // create new CanvasMatrix4 with identity matrix
    ]
    interface CanvasMatrix4 {
        attribute float m11;
        attribute float m12;
        attribute float m13;
        attribute float m14;
        attribute float m21;
        attribute float m22;
        attribute float m23;
        attribute float m24;
        attribute float m31;
        attribute float m32;
        attribute float m33;
        attribute float m34;
        attribute float m41;
        attribute float m42;
        attribute float m43;
        attribute float m44;

        void load(in CanvasMatrix4 matrix);                 // copy the values from the passed matrix
        void load(in sequence<float> array);                // copy 16 floats into the matrix
        sequence<float> getAsArray();                       // return the matrix as an array of 16 floats
        WebGLFloatArray getAsCanvasFloatArray();           // return the matrix as a WebGLFloatArray with 16 values
        void makeIdentity();                                // replace the matrix with identity
        void transpose();                                   // replace the matrix with its transpose
        void invert();                                      // replace the matrix with its inverse

        void translate(in float x, in float y, in float z); // multiply the matrix by passed translation values on the right
        void scale(in float x, in float y, in float z);     // multiply the matrix by passed scale values on the right
        void rotate(in float angle,                         // multiply the matrix by passed rotation values on the right
                    in float x, in float y, in float z);    // (angle is in degrees)
        void multRight(in CanvasMatrix matrix);             // multiply the matrix by the passed matrix on the right
        void multLeft(in CanvasMatrix matrix);              // multiply the matrix by the passed matrix on the left
        void ortho(in float left, in float right,           // multiply the matrix by the passed ortho values on the right
                   in float bottom, in float top,
                   in float near, in float far);
        void frustum(in float left, in float right,         // multiply the matrix by the passed frustum values on the right
                     in float bottom, in float top,
                     in float near, in float far);
        void perspective(in float fovy, in float aspect,    // multiply the matrix by the passed perspective values on the right
                         in float zNear, in float zFar);
        void lookat(in float eyex, in float eyey, in float eyez,    // multiply the matrix by the passed lookat
                    in float ctrx, in float ctry, in float ctrz,    // values on the right
                    in float upx, in float upy, in float upz);
    }
*/

CanvasMatrix4 = function(m)
{
    if (typeof m == 'object') {
        if ("length" in m && m.length >= 16) {
            this.load(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
            return;
        }
        else if (m instanceof CanvasMatrix4) {
            this.load(m);
            return;
        }
    }
    this.makeIdentity();
};

CanvasMatrix4.prototype.load = function()
{
    if (arguments.length == 1 && typeof arguments[0] == 'object') {
        var matrix = arguments[0];

        if ("length" in matrix && matrix.length == 16) {
            this.m11 = matrix[0];
            this.m12 = matrix[1];
            this.m13 = matrix[2];
            this.m14 = matrix[3];

            this.m21 = matrix[4];
            this.m22 = matrix[5];
            this.m23 = matrix[6];
            this.m24 = matrix[7];

            this.m31 = matrix[8];
            this.m32 = matrix[9];
            this.m33 = matrix[10];
            this.m34 = matrix[11];

            this.m41 = matrix[12];
            this.m42 = matrix[13];
            this.m43 = matrix[14];
            this.m44 = matrix[15];
            return;
        }

        if (arguments[0] instanceof CanvasMatrix4) {

            this.m11 = matrix.m11;
            this.m12 = matrix.m12;
            this.m13 = matrix.m13;
            this.m14 = matrix.m14;

            this.m21 = matrix.m21;
            this.m22 = matrix.m22;
            this.m23 = matrix.m23;
            this.m24 = matrix.m24;

            this.m31 = matrix.m31;
            this.m32 = matrix.m32;
            this.m33 = matrix.m33;
            this.m34 = matrix.m34;

            this.m41 = matrix.m41;
            this.m42 = matrix.m42;
            this.m43 = matrix.m43;
            this.m44 = matrix.m44;
            return;
        }
    }

    this.makeIdentity();
};

CanvasMatrix4.prototype.getAsArray = function()
{
    return [
        this.m11, this.m12, this.m13, this.m14,
        this.m21, this.m22, this.m23, this.m24,
        this.m31, this.m32, this.m33, this.m34,
        this.m41, this.m42, this.m43, this.m44
    ];
};

CanvasMatrix4.prototype.getAsWebGLFloatArray = function()
{
    return new WebGLFloatArray(this.getAsArray());
};

CanvasMatrix4.prototype.makeIdentity = function()
{
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;

    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;

    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;

    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
};

CanvasMatrix4.prototype.transpose = function()
{
    var tmp = this.m12;
    this.m12 = this.m21;
    this.m21 = tmp;

    tmp = this.m13;
    this.m13 = this.m31;
    this.m31 = tmp;

    tmp = this.m14;
    this.m14 = this.m41;
    this.m41 = tmp;

    tmp = this.m23;
    this.m23 = this.m32;
    this.m32 = tmp;

    tmp = this.m24;
    this.m24 = this.m42;
    this.m42 = tmp;

    tmp = this.m34;
    this.m34 = this.m43;
    this.m43 = tmp;
};

CanvasMatrix4.prototype.invert = function()
{
    // Calculate the 4x4 determinant
    // If the determinant is zero,
    // then the inverse matrix is not unique.
    var det = this._determinant4x4();

    if (Math.abs(det) < 1e-8)
        return null;

    this._makeAdjoint();

    // Scale the adjoint matrix to get the inverse
    this.m11 /= det;
    this.m12 /= det;
    this.m13 /= det;
    this.m14 /= det;

    this.m21 /= det;
    this.m22 /= det;
    this.m23 /= det;
    this.m24 /= det;

    this.m31 /= det;
    this.m32 /= det;
    this.m33 /= det;
    this.m34 /= det;

    this.m41 /= det;
    this.m42 /= det;
    this.m43 /= det;
    this.m44 /= det;
};

CanvasMatrix4.prototype.translate = function(x,y,z)
{
    if (x === undefined)
        x = 0;
    if (y === undefined)
        y = 0;
    if (z === undefined)
        z = 0;

    var matrix = new CanvasMatrix4();
    matrix.m41 = x;
    matrix.m42 = y;
    matrix.m43 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.scale = function(x,y,z)
{
    if (x === undefined)
        x = 1;
    if (z === undefined) {
        if (y === undefined) {
            y = x;
            z = x;
        }
        else
            z = 1;
    }
    else if (y === undefined)
        y = x;

    var matrix = new CanvasMatrix4();
    matrix.m11 = x;
    matrix.m22 = y;
    matrix.m33 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.rotate = function(angle,x,y,z)
{
    // angles are in degrees. Switch to radians
    angle = angle / 180 * Math.PI;

    angle /= 2;
    var sinA = Math.sin(angle);
    var cosA = Math.cos(angle);
    var sinA2 = sinA * sinA;

    // normalize
    var length = Math.sqrt(x * x + y * y + z * z);
    if (length === 0) {
        // bad vector, just use something reasonable
        x = 0;
        y = 0;
        z = 1;
    } else if (length != 1) {
        x /= length;
        y /= length;
        z /= length;
    }

    var mat = new CanvasMatrix4();

    // optimize case where axis is along major axis
    if (x == 1 && y === 0 && z === 0) {
        mat.m11 = 1;
        mat.m12 = 0;
        mat.m13 = 0;
        mat.m21 = 0;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 2 * sinA * cosA;
        mat.m31 = 0;
        mat.m32 = -2 * sinA * cosA;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y == 1 && z === 0) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 0;
        mat.m13 = -2 * sinA * cosA;
        mat.m21 = 0;
        mat.m22 = 1;
        mat.m23 = 0;
        mat.m31 = 2 * sinA * cosA;
        mat.m32 = 0;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y === 0 && z == 1) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 2 * sinA * cosA;
        mat.m13 = 0;
        mat.m21 = -2 * sinA * cosA;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 0;
        mat.m31 = 0;
        mat.m32 = 0;
        mat.m33 = 1;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else {
        var x2 = x*x;
        var y2 = y*y;
        var z2 = z*z;

        mat.m11 = 1 - 2 * (y2 + z2) * sinA2;
        mat.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
        mat.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
        mat.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
        mat.m22 = 1 - 2 * (z2 + x2) * sinA2;
        mat.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
        mat.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
        mat.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
        mat.m33 = 1 - 2 * (x2 + y2) * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    }
    this.multRight(mat);
};

CanvasMatrix4.prototype.multRight = function(mat)
{
    var m11 = (this.m11 * mat.m11 + this.m12 * mat.m21 +
               this.m13 * mat.m31 + this.m14 * mat.m41);
    var m12 = (this.m11 * mat.m12 + this.m12 * mat.m22 +
               this.m13 * mat.m32 + this.m14 * mat.m42);
    var m13 = (this.m11 * mat.m13 + this.m12 * mat.m23 +
               this.m13 * mat.m33 + this.m14 * mat.m43);
    var m14 = (this.m11 * mat.m14 + this.m12 * mat.m24 +
               this.m13 * mat.m34 + this.m14 * mat.m44);

    var m21 = (this.m21 * mat.m11 + this.m22 * mat.m21 +
               this.m23 * mat.m31 + this.m24 * mat.m41);
    var m22 = (this.m21 * mat.m12 + this.m22 * mat.m22 +
               this.m23 * mat.m32 + this.m24 * mat.m42);
    var m23 = (this.m21 * mat.m13 + this.m22 * mat.m23 +
               this.m23 * mat.m33 + this.m24 * mat.m43);
    var m24 = (this.m21 * mat.m14 + this.m22 * mat.m24 +
               this.m23 * mat.m34 + this.m24 * mat.m44);

    var m31 = (this.m31 * mat.m11 + this.m32 * mat.m21 +
               this.m33 * mat.m31 + this.m34 * mat.m41);
    var m32 = (this.m31 * mat.m12 + this.m32 * mat.m22 +
               this.m33 * mat.m32 + this.m34 * mat.m42);
    var m33 = (this.m31 * mat.m13 + this.m32 * mat.m23 +
               this.m33 * mat.m33 + this.m34 * mat.m43);
    var m34 = (this.m31 * mat.m14 + this.m32 * mat.m24 +
               this.m33 * mat.m34 + this.m34 * mat.m44);

    var m41 = (this.m41 * mat.m11 + this.m42 * mat.m21 +
               this.m43 * mat.m31 + this.m44 * mat.m41);
    var m42 = (this.m41 * mat.m12 + this.m42 * mat.m22 +
               this.m43 * mat.m32 + this.m44 * mat.m42);
    var m43 = (this.m41 * mat.m13 + this.m42 * mat.m23 +
               this.m43 * mat.m33 + this.m44 * mat.m43);
    var m44 = (this.m41 * mat.m14 + this.m42 * mat.m24 +
               this.m43 * mat.m34 + this.m44 * mat.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.multLeft = function(mat)
{
    var m11 = (mat.m11 * this.m11 + mat.m12 * this.m21 +
               mat.m13 * this.m31 + mat.m14 * this.m41);
    var m12 = (mat.m11 * this.m12 + mat.m12 * this.m22 +
               mat.m13 * this.m32 + mat.m14 * this.m42);
    var m13 = (mat.m11 * this.m13 + mat.m12 * this.m23 +
               mat.m13 * this.m33 + mat.m14 * this.m43);
    var m14 = (mat.m11 * this.m14 + mat.m12 * this.m24 +
               mat.m13 * this.m34 + mat.m14 * this.m44);

    var m21 = (mat.m21 * this.m11 + mat.m22 * this.m21 +
               mat.m23 * this.m31 + mat.m24 * this.m41);
    var m22 = (mat.m21 * this.m12 + mat.m22 * this.m22 +
               mat.m23 * this.m32 + mat.m24 * this.m42);
    var m23 = (mat.m21 * this.m13 + mat.m22 * this.m23 +
               mat.m23 * this.m33 + mat.m24 * this.m43);
    var m24 = (mat.m21 * this.m14 + mat.m22 * this.m24 +
               mat.m23 * this.m34 + mat.m24 * this.m44);

    var m31 = (mat.m31 * this.m11 + mat.m32 * this.m21 +
               mat.m33 * this.m31 + mat.m34 * this.m41);
    var m32 = (mat.m31 * this.m12 + mat.m32 * this.m22 +
               mat.m33 * this.m32 + mat.m34 * this.m42);
    var m33 = (mat.m31 * this.m13 + mat.m32 * this.m23 +
               mat.m33 * this.m33 + mat.m34 * this.m43);
    var m34 = (mat.m31 * this.m14 + mat.m32 * this.m24 +
               mat.m33 * this.m34 + mat.m34 * this.m44);

    var m41 = (mat.m41 * this.m11 + mat.m42 * this.m21 +
               mat.m43 * this.m31 + mat.m44 * this.m41);
    var m42 = (mat.m41 * this.m12 + mat.m42 * this.m22 +
               mat.m43 * this.m32 + mat.m44 * this.m42);
    var m43 = (mat.m41 * this.m13 + mat.m42 * this.m23 +
               mat.m43 * this.m33 + mat.m44 * this.m43);
    var m44 = (mat.m41 * this.m14 + mat.m42 * this.m24 +
               mat.m43 * this.m34 + mat.m44 * this.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.ortho = function(left, right, bottom, top, near, far)
{
    var tx = (left + right) / (left - right);
    var ty = (top + bottom) / (bottom - top);
    var tz = (far + near) / (near - far);

    var matrix = new CanvasMatrix4();
    matrix.m11 = 2 / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;
    matrix.m21 = 0;
    matrix.m22 = 2 / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;
    matrix.m31 = 0;
    matrix.m32 = 0;
    matrix.m33 = -2 / (far - near);
    matrix.m34 = 0;
    matrix.m41 = tx;
    matrix.m42 = ty;
    matrix.m43 = tz;
    matrix.m44 = 1;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.frustum = function(left, right, bottom, top, near, far)
{
    var matrix = new CanvasMatrix4();
    var A = (right + left) / (right - left);
    var B = (top + bottom) / (top - bottom);
    var C = -(far + near) / (far - near);
    var D = -(2 * far * near) / (far - near);

    matrix.m11 = (2 * near) / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;

    matrix.m21 = 0;
    matrix.m22 = 2 * near / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;

    matrix.m31 = A;
    matrix.m32 = B;
    matrix.m33 = C;
    matrix.m34 = -1;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = D;
    matrix.m44 = 0;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.perspective = function(fovy, aspect, zNear, zFar)
{
    var top = Math.tan(fovy * Math.PI / 360) * zNear;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    this.frustum(left, right, bottom, top, zNear, zFar);
};

CanvasMatrix4.prototype.lookat = function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)
{
    var matrix = new CanvasMatrix4(),
        xx, xy, xz;

    // Make rotation matrix

    // Z vector
    var zx = eyex - centerx;
    var zy = eyey - centery;
    var zz = eyez - centerz;
    var mag = Math.sqrt(zx * zx + zy * zy + zz * zz);
    if (mag) {
        zx /= mag;
        zy /= mag;
        zz /= mag;
    }

    // Y vector
    var yx = upx;
    var yy = upy;
    var yz = upz;

    // X vector = Y cross Z
    xx =  yy * zz - yz * zy;
    xy = -yx * zz + yz * zx;
    xz =  yx * zy - yy * zx;

    // Recompute Y = Z cross X
    yx = zy * xz - zz * xy;
    yy = -zx * xz + zz * xx;
    yx = zx * xy - zy * xx;

    // cross product gives area of parallelogram, which is < 1.0 for
    // non-perpendicular unit-length vectors; so normalize x, y here

    mag = Math.sqrt(xx * xx + xy * xy + xz * xz);
    if (mag) {
        xx /= mag;
        xy /= mag;
        xz /= mag;
    }

    mag = Math.sqrt(yx * yx + yy * yy + yz * yz);
    if (mag) {
        yx /= mag;
        yy /= mag;
        yz /= mag;
    }

    matrix.m11 = xx;
    matrix.m12 = xy;
    matrix.m13 = xz;
    matrix.m14 = 0;

    matrix.m21 = yx;
    matrix.m22 = yy;
    matrix.m23 = yz;
    matrix.m24 = 0;

    matrix.m31 = zx;
    matrix.m32 = zy;
    matrix.m33 = zz;
    matrix.m34 = 0;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = 0;
    matrix.m44 = 1;
    matrix.translate(-eyex, -eyey, -eyez);

    this.multRight(matrix);
};

// Support functions
CanvasMatrix4.prototype._determinant2x2 = function(a, b, c, d)
{
    return a * d - b * c;
};

CanvasMatrix4.prototype._determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3)
{
    return a1 * this._determinant2x2(b2, b3, c2, c3) -
         b1 * this._determinant2x2(a2, a3, c2, c3) +
         c1 * this._determinant2x2(a2, a3, b2, b3);
};

CanvasMatrix4.prototype._determinant4x4 = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    return a1 * this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
         b1 * this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
         c1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
         d1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

CanvasMatrix4.prototype._makeAdjoint = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    // Row column labeling reversed since we transpose rows & columns
    this.m11  =   this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    this.m21  = - this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    this.m31  =   this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    this.m41  = - this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    this.m12  = - this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    this.m22  =   this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    this.m32  = - this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    this.m42  =   this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    this.m13  =   this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    this.m23  = - this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    this.m33  =   this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    this.m43  = - this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    this.m14  = - this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    this.m24  =   this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    this.m34  = - this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    this.m44  =   this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
};
</script>

</head>
<body style="background-color: white;">
<div id="htmlwidget_container">
  <p id="rgl91980-aria" hidden>3D plot</p>
  <div aria-labelledby="rgl91980-aria" class="rglWebGL html-widget html-fill-item-overflow-hidden html-fill-item" id="rgl91980" style="width:960px;height:500px;"></div>
</div>
<script type="application/json" data-for="rgl91980">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#000000","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":49,"objects":{"56":{"id":56,"type":"points","material":{"lit":false,"size":4},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"57":{"id":57,"type":"lines","material":{"lit":false},"vertices":"3","colors":"4","centers":"5","ignoreExtent":true,"flags":32832},"58":{"id":58,"type":"text","material":{"lit":false},"vertices":"6","colors":"7","texts":[["0"],["1"],["2"],["3"],["4"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"59":{"id":59,"type":"lines","material":{"lit":false},"vertices":"9","colors":"10","centers":"11","ignoreExtent":true,"flags":32832},"60":{"id":60,"type":"text","material":{"lit":false},"vertices":"12","colors":"13","texts":[["0"],["1"],["2"],["3"],["4"],["5"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"14","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"61":{"id":61,"type":"lines","material":{"lit":false},"vertices":"15","colors":"16","centers":"17","ignoreExtent":true,"flags":32832},"62":{"id":62,"type":"text","material":{"lit":false},"vertices":"18","colors":"19","texts":[[" 5"],["10"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"20","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"64":{"id":64,"type":"quads","material":{"lit":false,"back":"lines","uri":"data:image/png;base64,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A0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA8DNbRfDMD+t1x+HYbh7uRyPBBgAbm27mO0296cCr2Zvj0cCDAC3tv70uA/uadpdPuzeHI8EGABubWzv+vPTYb39/mXceT4fT/7lve7b/iABBuBX9zwG+DAG745b0euvL+fj6RQBBoBbuw7waHP/8OYowABwe9db0KPt4uHNUYAB4PbG9p4uwlp92K833x7Px9MpAgwAt3Z9G9I49O5jfD6eThFgALi584M4lvPD777Hq5/PxyMBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoDJbBfDMD+t1x+HYbh7Ob0SYACYynYx223uTwVeza4/EmAAmMr60+M+vKepd/lw/ZEAA8BUxvauPz8d1tvvX652oAUYACbzPAb4MAbvjlvR66/nAv/re+HX/DECDMDv4jrAo839eR9agAFgKtdb0KPtQoABYGpje08XYa0+7Nebb+dpWIABYCrXtyGNw+/qzm/AADC584M4lvPD77/XV0ELMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAbm67GIb568v1p8f9n4/DMNy9nN4SYAC4te1ittvcz19f/rEP8Gp2fYoAA8CtjRPv6jLtPv/p4fXy4foUAQaAWxvbu/78dHy1/vq3+wBvv3+52oHe/dt71Xf9YQIMwK/ueQzwYezd235/PCzHLen113OBBRgAbu1NgJ/nl+W+wud9aAEGgFu73oI+DL2XAG8XAgwAUxnbe7oI63kYPaw+7N/bfDuVWIAB4Obe3YY0TsDj8Pt6ZbQAA8DNnR/EsTxGeNyC3ty7ChoAYgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAJrNdDMP89eX60+N5KcAAMJXtYrbb3M9fX/4hwAAwuXHiXd29nF4+/6kJGACmN7Z3/fnp+Gr99W9fA/zv71Xf8YcJMAC/i+cxwKfqbr8/rgUYAKb3JsDP850AA8BPcL0Fvf76IsAA8DOM7T1dhPU8jB5OHwkwAEzl3W1IJmAA+CnOD+JYHiMswADQEmAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwABwc9vFMMyv1rP9cf1xGIa7l9O7AgwAt7ZdzHab+1OBl7P96/16Nbs+RYAB4NbWnx73wT1Ou+P6eb9ePlyfIsAAcGtje9efn86vDxPw9vuXqx1oAQaAm3seA3wYfQ+2i0N4xy3p9ddzgf/jvezL/igBBuBX9zbAe6sPx2l4c3/ehxZgALi191vQ+yH44c1RgAHg9sb2ni7CGoff/eR7PH47T8UCDAC3dn0b0jj07mN8Pp5OEWAAuLnzgziW8+P60N3N/fVV0AIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoDJbBfDML9azy6fCDAATGW7mO0296cCL2f71+caCzAATGb96XG3W929XNbPx/VOgAFgOmN715+fzq+vJuD/fK/5hv8LAgzA72IceMfR92C7GC4DsAADwGTeBnhv9eE8DQswAEzl/Rb0fgh+OK0EGACmMrb3dBHWOPxu7gUYAKZ2fRvSOPyuLj8CCzAATOb8II7l/Lh2ERYApAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAA3Nx2MQzz03pzPwwfnna79cdhGO5eTu8KMADc2nYx23f3WODx+Lwv8Gp2fYoAA8CtrT897nar47S7Oky/m2+Pu+XD9SkCDAC3NrZ3/fnp8sa+yNvvX652oAUYAG7ueQzwYQw+umxJr7++/E//75cmwAD86t4F+NDfo839w3/3f355AgzAr+7tFvT64/mC6H2KBRgApjK293QR1m71xzgJXy7G+l0JMAC/uuvbkM470ePwu7rzGzAATOb8II7lfPc8jB7GB3L8xv0VYAAoCDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASDwXx72r7L4P8P1AAAAAElFTkSuQmCC"},"vertices":"21","colors":"24","texcoords":"23","centers":"25","normals":"22","ignoreExtent":true,"flags":36870},"53":{"id":53,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"52":{"id":52,"type":"background","material":{"specular":"#FFFFFF"},"colors":"26","centers":"27","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"54":{"id":54,"type":"background","material":{"lit":false,"specular":"#FFFFFF","back":"lines"},"colors":"28","centers":"29","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"55":{"id":55,"type":"background","material":{"lit":false,"specular":"#FFFFFF","back":"lines"},"colors":"30","centers":"31","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"63":{"id":63,"type":"background","material":{"lit":false,"back":"lines","uri":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAQ4CAMAAADfDTFxAAAAkFBMVEUAAAAAADoAAGYAOmYAOpAAZrY6AAA6ADo6AGY6OgA6OpA6ZmY6kNtmAABmADpmOgBmtttmtv+QOgCQOjqQ2/+zAAC2ZgC2kDq2///AFQ7OKh3bkDrbkJDb25Db///cPyvmUzjtZkP0eU78jVn8n2f8sXX8w4P90ZX926v95cL+8Nn/tmb/25D//7b//9v///9ADmS2AAAY0klEQVR4nO3caW8bXViA4XlL3A2nEDeYQCDsq7f//++wx0ucSKAiPL1bcV1SM8f2VPK3W8/xzAw7AOCnG+ovAAD/HwkwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAAv6nt4qH+Cv8HAgzA72m7GAQYAH6y5+FP/kyAAeAn+5snW9AAELgO8F+8F36vHyPAAPymBBgAAgIMAAEBBoCAAANAQIABICbAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAAHBz28UwzE/rzf0wzPbH9cdhGO5eTu8KMADc2nYx23d3flkf/u1Ws+tTBBgAbm396XEf3OO0u/rwdHxj+XB9igADwK2N7V1/fjqsnw/rzf3D9vuXqx3o3V+9133bHyTAAPzqxuiOY/B5Av74MG5Jr7+eCyzAAHBr1wHe3M92u+Vw3H/eT8KnUwQYAG7tegt6vAr6zxfH8G4XAgwAUxnbu3r9wffwxrgVvfn2eHpHgAHg1q5vQzrsRG8X8+Pw+xplAQaAmzs/iGO5/7MajuvDVrSroAEgJcAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAFgMtvFMMxP6839MMwunwgwAExlu5jtuzu/rA//TgQYAKay/vS4263uXg7r1Yen0xsjAQaAqYztXX9+OqyfD+vN/cPpIwEGgKmM0T1NvccJ+OM5wH/9Xvg1f4wAA/C7uA7w5n622y0HAQaAqV1vQY9XQf/5QoABYGpje08XYb2+MRJgAJjK9W1Ih53o7eJ8U7AAA8B0zg/iWO7/rIbXh3IIMAAkBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAbm67GIb5ab25H4bZ/rj+OAzD3cvpXQEGgFvbLmb77s4v6+1iv17Nrk8RYAC4tfWnx31wj9Pu5v5ht3vex3f5cH2KAAPArY3tXX9+OqzPE/D2+5erHejd373XfdsfJMAA/OqexwAfxuCD5TA87I5b0uuv5wILMADc2nWAx/AuT7//jvvRIwEGgFu73oJeXU/D24UAA8BUxvaeLsI6B3j1Yf/e5ttpW1qAAeDmrm9DOm5B372Mw+/qzm/AADCZ84M4lvPjgzgO3T0fjwQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYACazXQzD/LTe3A/D7PKJAAPAVLaL2b6788t6uzjXWIABYDLrT4+73eru5bDe3D/sds+XEViAAWAqY3vXn58OaxMwAPwkz2OAD2PwwXIYHi4f/f170Vf8cQIMwO/iOsDjb8HLyxa0AAPAVK63oFdvpmEBBoDJjO09XYQlwADwk1zfhnTcgj7GeCfAADCh84M4lvPjgzgu/RVgACgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMADc3HYxDPPjcjWMHnbrj/vD3cvpDAEGgFvbLma7zf389Y3lPryr2fUpAgwAt7b+9LgffS/T7m714Wkf4YfrUwQYAG5tbO/689Pp5XaxH4a3379c7UDv/uG96Kv+OAEG4Ff3PAb4MAaPxgF43JJefz0XWIAB4NbeBngcgI829+d9aAEGgFt7uwX9OgrvWyzAADCVsb2Xi7COi+M+9LdziwUYAG7t7W1Iy9nxvYfrK6MFGABu7vwgjuXlz+H3X1dBA0BMgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA8BktothmB+Xq2H0cPpEgAFgKtvFbLe5n7++sbx7Oa0EGACmsv70uB99L9HdrT48nZcCDABTGdu7/nyu7nbxOgwLMABM5XkM8GEMHl0NwLt/fK/5hv8LAgzA7+JtgK8HYAEGgMm83YJ+HYV3AgwA0xnbe7kI6+pqLAEGgOm8vQ1pObv6SIABYDLnB3EsL3/OBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMADe3XQzD/PxiOQx/PO5264/DMNy9nN4UYAC4te1ittvcnwq83B9XH552q9n1KQIMALe2/rSfeFfHaXdcHywfrk8RYAC4tbG9689Pl/Xe9vuXqx3o3T+9F33VHyfAAPzqnscAH0ff57u/HIYPT8ct6fXXc4EFGABu7U2Ah9NvwAeb+/M+tAADwK1db0GPMd4ujuE9HwUYAG5vbO/px9/VKcDjELz5droiS4AB4Oaub0Mah959fY/HO78BA8Bkzg/iONwDfFiP0++9q6ABICbAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABYDLbxTDMzy+Ww/DH4/mFAAPAVLaL2W5zfyrwcn9cfXg6fSTAADCV9af9xLu6e7msXwkwAExlbO/689Nl/UqAAWAqz2OAj6Pv891fDsNlB3r3z+913/IHCTAAv4s3AR7e/AYswAAwlest6DHG28XD6SMBBoCpjO09/fi7EmAA+Dmub0Ma22sLGgB+gvODOA73AB/WLsICgJQAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA8DNbRfDMD+t1x+HYbh7uRyPBBgAbm27mO0296cCr2Zvj0cCDAC3tv70uA/uadpdPuzeHI8EGABubWzv+vPTYb39/mXceT4fT/7lve7b/iABBuBX9zwG+DAG745b0euvL+fj6RQBBoBbuw7waHP/8OYowABwe9db0KPt4uHNUYAB4PbG9p4uwlp92K833x7Px9MpAgwAt3Z9G9I49O5jfD6eThFgALi584M4lvPD777Hq5/PxyMBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoDJbBfDMD+t1x+HYbh7Ob0SYACYynYx223uTwVeza4/EmAAmMr60+M+vKepd/lw/ZEAA8BUxvauPz8d1tvvX652oAUYACbzPAb4MAbvjlvR66/nAv/re+HX/DECDMDv4jrAo839eR9agAFgKtdb0KPtQoABYGpje08XYa0+7Nebb+dpWIABYCrXtyGNw+/qzm/AADC584M4lvPD77/XV0ELMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAbm67GIb568v1p8f9n4/DMNy9nN4SYAC4te1ittvcz19f/rEP8Gp2fYoAA8CtjRPv6jLtPv/p4fXy4foUAQaAWxvbu/78dHy1/vq3+wBvv3+52oHe/dt71Xf9YQIMwK/ueQzwYezd235/PCzHLen113OBBRgAbu1NgJ/nl+W+wud9aAEGgFu73oI+DL2XAG8XAgwAUxnbe7oI63kYPaw+7N/bfDuVWIAB4Obe3YY0TsDj8Pt6ZbQAA8DNnR/EsTxGeNyC3ty7ChoAYgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAJrNdDMP89eX60+N5KcAAMJXtYrbb3M9fX/4hwAAwuXHiXd29nF4+/6kJGACmN7Z3/fnp+Gr99W9fA/zv71Xf8YcJMAC/i+cxwKfqbr8/rgUYAKb3JsDP850AA8BPcL0Fvf76IsAA8DOM7T1dhPU8jB5OHwkwAEzl3W1IJmAA+CnOD+JYHiMswADQEmAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwABwc9vFMMyv1rP9cf1xGIa7l9O7AgwAt7ZdzHab+1OBl7P96/16Nbs+RYAB4NbWnx73wT1Ou+P6eb9ePlyfIsAAcGtje9efn86vDxPw9vuXqx1oAQaAm3seA3wYfQ+2i0N4xy3p9ddzgf/jvezL/igBBuBX9zbAe6sPx2l4c3/ehxZgALi191vQ+yH44c1RgAHg9sb2ni7CGoff/eR7PH47T8UCDAC3dn0b0jj07mN8Pp5OEWAAuLnzgziW8+P60N3N/fVV0AIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoDJbBfDML9azy6fCDAATGW7mO0296cCL2f71+caCzAATGb96XG3W929XNbPx/VOgAFgOmN715+fzq+vJuD/fK/5hv8LAgzA72IceMfR92C7GC4DsAADwGTeBnhv9eE8DQswAEzl/Rb0fgh+OK0EGACmMrb3dBHWOPxu7gUYAKZ2fRvSOPyuLj8CCzAATOb8II7l/Lh2ERYApAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAA3Nx2MQzz03pzPwwfnna79cdhGO5eTu8KMADc2nYx23f3WODx+Lwv8Gp2fYoAA8CtrT897nar47S7Oky/m2+Pu+XD9SkCDAC3NrZ3/fnp8sa+yNvvX652oAUYAG7ueQzwYQw+umxJr7++/E//75cmwAD86t4F+NDfo839w3/3f355AgzAr+7tFvT64/mC6H2KBRgApjK293QR1m71xzgJXy7G+l0JMAC/uuvbkM470ePwu7rzGzAATOb8II7lfPc8jB7GB3L8xv0VYAAoCDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASAgwAAQEGAACAgwAAQEGAACAgwAAQEGgIAAA0BAgAEgIMAAEBBgAAgIMAAEBBgAAgIMAAEBBoCAAANAQIABICDAABAQYAAICDAABAQYAAICDAABAQaAgAADQECAASDwXx72r7L4P8P1AAAAAElFTkSuQmCC"},"colors":"32","ids":[[64]],"types":[["quads"]],"centers":"33","objects":[{"id":{"id":64},"type":{"type":"quads"},"material":{"color":"#FFFFFF","lit":false,"texture":"C:\\Users\\shre9292\\AppData\\Local\\Temp\\Rtmps1vtXP\\file41541d4d26a5.png","back":"lines"},"vertices":[[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]],"colors":[[1,1,1,1]],"texcoords":[[0,0],[1,0],[1,1],[0,1]],"centers":[[0,0,1]],"normals":[[0,-0,1],[0,-0,1],[0,-0,1],[0,-0,1]],"ignoreExtent":true}],"sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"49":{"id":49,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":49,"mouseMode":{"none":"none","left":"trackball","right":"user","middle":"fov","wheel":"pull"},"observer":[0,0,31.17403030395508],"modelMatrix":[[1,0,0,-2.332000017166138],[0,0.3420201539993286,0.9396926164627075,-7.723519802093506],[0,-0.9396926164627075,0.3420201539993286,-31.30077934265137],[0,0,0,1]],"projMatrix":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.863703727722168,-112.3787841796875],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[0,4.664000034332275,0,5.044990062713623,0.0005099999834783375,14.60165977478027],"windowRect":[112,135,368,391],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[63,56,57,58,59,60,61,62,53],"subscenes":[],"flags":36176}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":257,"height":257,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":6913,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":6913,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":6913,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":12,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":6,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":5,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":5,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":14,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":7,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":6,"type":"VEC3"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":14,"componentType":5126,"count":6,"type":"VEC3"},{"bufferView":15,"componentType":5126,"count":6,"type":"VEC3"},{"bufferView":16,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":17,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":18,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":19,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":20,"componentType":5126,"count":2,"type":"VEC3"},{"bufferView":21,"componentType":5120,"count":4,"type":"VEC3"},{"bufferView":22,"componentType":5121,"count":4,"type":"VEC3"},{"bufferView":23,"componentType":5121,"count":4,"type":"VEC2","normalized":true},{"bufferView":24,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":25,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":26,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":27,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":28,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":29,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":30,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":31,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":32,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":33,"componentType":5121,"count":1,"type":"VEC3"}],"bufferViews":[{"buffer":0,"byteLength":82956,"byteOffset":0},{"buffer":0,"byteLength":27652,"byteOffset":82956},{"buffer":0,"byteLength":82956,"byteOffset":110608},{"buffer":0,"byteLength":144,"byteOffset":193564},{"buffer":0,"byteLength":4,"byteOffset":193708},{"buffer":0,"byteLength":72,"byteOffset":193712},{"buffer":0,"byteLength":60,"byteOffset":193784},{"buffer":0,"byteLength":4,"byteOffset":193844},{"buffer":0,"byteLength":60,"byteOffset":193848},{"buffer":0,"byteLength":168,"byteOffset":193908},{"buffer":0,"byteLength":4,"byteOffset":194076},{"buffer":0,"byteLength":84,"byteOffset":194080},{"buffer":0,"byteLength":72,"byteOffset":194164},{"buffer":0,"byteLength":4,"byteOffset":194236},{"buffer":0,"byteLength":72,"byteOffset":194240},{"buffer":0,"byteLength":72,"byteOffset":194312},{"buffer":0,"byteLength":4,"byteOffset":194384},{"buffer":0,"byteLength":36,"byteOffset":194388},{"buffer":0,"byteLength":24,"byteOffset":194424},{"buffer":0,"byteLength":4,"byteOffset":194448},{"buffer":0,"byteLength":24,"byteOffset":194452},{"buffer":0,"byteLength":12,"byteOffset":194476},{"buffer":0,"byteLength":12,"byteOffset":194488},{"buffer":0,"byteLength":8,"byteOffset":194500},{"buffer":0,"byteLength":4,"byteOffset":194508},{"buffer":0,"byteLength":3,"byteOffset":194512},{"buffer":0,"byteLength":16,"byteOffset":194516},{"buffer":0,"byteLength":3,"byteOffset":194532},{"buffer":0,"byteLength":4,"byteOffset":194535},{"buffer":0,"byteLength":3,"byteOffset":194539},{"buffer":0,"byteLength":4,"byteOffset":194542},{"buffer":0,"byteLength":3,"byteOffset":194546},{"buffer":0,"byteLength":4,"byteOffset":194549},{"buffer":0,"byteLength":3,"byteOffset":194553}],"buffers":[{"byteLength":194556,"bytes":"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\nDv+zAAD/wBUO//R5Tv/OKh3/swAA/7MAAP/8sXX/swAA/7MAAP/AFQ7/swAA/7MAAP+zAAD/\n/LF1/84qHf/mUzj/3D8r/9w/K//0eU7/wBUO/+ZTOP+zAAD/wBUO/84qHf+zAAD/ziod//R5\nTv/OKh3/ziod/7MAAP+zAAD/wBUO//yxdf+zAAD/swAA/7MAAP+zAAD/wBUO/8AVDv+zAAD/\n/LF1/8AVDv/tZkP/3D8r/7MAAP+zAAD/5lM4/84qHf+zAAD/7WZD/7MAAP/mUzj/ziod/7MA\nAP/8sXX//LF1/7MAAP/mUzj/wBUO/84qHf/AFQ7/ziod/7MAAP/AFQ7//I1Z/7MAAP/0eU7/\nwBUO/8AVDv+zAAD/wBUO/84qHf/mUzj/swAA/9w/K//AFQ7/swAA/84qHf+zAAD/wBUO/7MA\nAP+zAAD/wBUO/7MAAP/8w4P/3D8r/7MAAP+zAAD/3D8r/84qHf/mUzj//LF1/84qHf/AFQ7/\nswAA/7MAAP/cPyv/3D8r//yxdf/cPyv/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/84q\nHf/OKh3/swAA/8AVDv/AFQ7//MOD/+ZTOP/AFQ7/3D8r/9w/K//AFQ7/wBUO/7MAAP/cPyv/\nziod/7MAAP/mUzj//MOD/7MAAP+zAAD/7WZD/8AVDv+zAAD/swAA/7MAAP/mUzj/swAA/8AV\nDv+zAAD/swAA/8AVDv/cPyv/ziod/8AVDv/cPyv/wBUO/+1mQ//tZkP/7WZD/9w/K//8w4P/\n3D8r//zDg//OKh3/9HlO//yNWf+zAAD/3D8r//yNWf/OKh3/9HlO//R5Tv+zAAD/ziod/+1m\nQ/+zAAD/swAA//3Rlf+zAAD/ziod/7MAAP+zAAD/swAA//3Rlf+zAAD//dGV/7MAAP/tZkP/\n5lM4/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA//yfZ//AFQ7//J9n/84qHf+zAAD/swAA/7MA\nAP/90ZX/swAA/9w/K//AFQ7/3D8r/7MAAP+zAAD/swAA/7MAAP/926v//LF1//3Rlf/90ZX/\n/dGV/7MAAP+zAAD/3D8r/7MAAP/mUzj/swAA/+ZTOP/OKh3//LF1/+ZTOP+zAAD/swAA//3R\nlf/8n2f/ziod/7MAAP+zAAD/swAA/+ZTOP+zAAD//I1Z/7MAAP+zAAD//dGV/7MAAP+zAAD/\n/J9n/+1mQ//AFQ7/swAA/7MAAP+zAAD/7WZD//yfZ//cPyv/wBUO/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA/7MAAP+zAAD//eXC/7MAAP+zAAD//LF1/7MAAP/AFQ7/wBUO//yfZ/+zAAD/\nziod//3lwv+zAAD/5lM4/7MAAP/90ZX/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MA\nAP/AFQ7/swAA/7MAAP/OKh3/swAA/7MAAP+zAAD//dGV//yfZ//0eU7//dGV/7MAAP+zAAD/\nziod/7MAAP/0eU7/swAA/+ZTOP/8n2f/swAA/7MAAP/8w4P/swAA/9w/K//cPyv//MOD//3R\nlf/0eU7/wBUO/7MAAP+zAAD/9HlO//3Rlf/90ZX/ziod/7MAAP/AFQ7/9HlO/8AVDv+zAAD/\nswAA/+1mQ/+zAAD/swAA//3bq//AFQ7/swAA//R5Tv/0eU7/swAA//3Rlf+zAAD/swAA/7MA\nAP+zAAD/swAA/7MAAP/8w4P/swAA/84qHf/tZkP/swAA/7MAAP/mUzj/wBUO/7MAAP+zAAD/\nwBUO//R5Tv+zAAD/swAA/8AVDv/8jVn/7WZD/7MAAP+zAAD/wBUO/+1mQ/+zAAD//dGV/+ZT\nOP/cPyv//I1Z/7MAAP/OKh3//dGV//yNWf+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/\n5lM4/7MAAP/0eU7/7WZD/7MAAP+zAAD/wBUO/7MAAP/AFQ7//LF1//yxdf/90ZX/7WZD/7MA\nAP+zAAD/ziod/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/AFQ7/wBUO/9w/K/+zAAD/\nswAA/7MAAP/mUzj/swAA//3Rlf+zAAD/ziod//yfZ/+zAAD//MOD/7MAAP/8w4P/swAA//3R\nlf+zAAD/swAA/7MAAP/mUzj/swAA//yNWf+zAAD//dGV//yfZ//8w4P//dGV/7MAAP+zAAD/\nswAA//3bq/+zAAD/swAA/7MAAP/tZkP/swAA/+ZTOP+zAAD/swAA/8AVDv/AFQ7//LF1//3b\nq/+zAAD/ziod/8AVDv/OKh3//MOD//yxdf/AFQ7//MOD/7MAAP/8sXX//dGV/7MAAP+zAAD/\nswAA/8AVDv+zAAD/wBUO/7MAAP+zAAD/wBUO//yNWf+zAAD/9HlO/9w/K//0eU7/swAA/84q\nHf/cPyv/swAA//3bq/+zAAD/swAA//yNWf+zAAD/ziod/+1mQ//mUzj/swAA//zDg/+zAAD/\nswAA/7MAAP/8w4P/swAA//yxdf+zAAD//J9n//yfZ//90ZX//J9n//yxdf+zAAD/5lM4/7MA\nAP+zAAD/wBUO/7MAAP+zAAD/swAA/7MAAP/OKh3/swAA/84qHf/90ZX/wBUO//zDg//926v/\n5lM4/7MAAP+zAAD/swAA/9w/K/+zAAD/swAA//yfZ//8jVn/wBUO/7MAAP+zAAD/3D8r/7MA\nAP+zAAD//J9n/7MAAP+zAAD//I1Z/7MAAP+zAAD/swAA//3Rlf+zAAD/swAA/7MAAP/mUzj/\nswAA/+ZTOP+zAAD/swAA/7MAAP+zAAD/ziod/7MAAP/OKh3/wBUO/84qHf+zAAD/3D8r/7MA\nAP/mUzj/wBUO/7MAAP+zAAD/swAA/7MAAP+zAAD/wBUO/7MAAP+zAAD/3D8r//R5Tv+zAAD/\n/LF1/7MAAP/AFQ7//dGV/7MAAP+zAAD//J9n/7MAAP+zAAD/swAA/7MAAP/AFQ7/swAA/7MA\nAP+zAAD/5lM4/9w/K//8jVn/3D8r/7MAAP/mUzj/swAA//yNWf/AFQ7/5lM4/7MAAP/926v/\nswAA/7MAAP+zAAD/swAA/9w/K//mUzj/wBUO/7MAAP+zAAD/ziod/8AVDv/tZkP/swAA/9w/\nK/+zAAD/swAA/8AVDv+zAAD/wBUO//3Rlf/tZkP//dGV/7MAAP/AFQ7/swAA/7MAAP+zAAD/\nswAA//3Rlf/cPyv/7WZD/7MAAP+zAAD//J9n/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA//yN\nWf/tZkP/swAA/8AVDv+zAAD/swAA/7MAAP/cPyv/swAA/7MAAP+zAAD/swAA/7MAAP/tZkP/\nswAA/7MAAP+zAAD//dur/9w/K/+zAAD//dGV//R5Tv/tZkP/7WZD/7MAAP/AFQ7/swAA/7MA\nAP+zAAD//dGV//3Rlf+zAAD/3D8r/8AVDv/AFQ7/9HlO/8AVDv/AFQ7/swAA/7MAAP+zAAD/\n/dGV//zDg/+zAAD/swAA//yNWf+zAAD/swAA/7MAAP+zAAD/swAA/+1mQ/+zAAD/swAA/8AV\nDv/AFQ7/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA//R5Tv+zAAD/swAA/7MAAP+zAAD/\n7WZD/8AVDv+zAAD/swAA/+ZTOP/8n2f/swAA/8AVDv+zAAD/swAA/+ZTOP/AFQ7//dGV/7MA\nAP/OKh3/3D8r/7MAAP+zAAD/swAA/7MAAP/mUzj/swAA/8AVDv+zAAD/swAA//3Rlf+zAAD/\nswAA/7MAAP/90ZX/7WZD//R5Tv/OKh3/wBUO/7MAAP+zAAD/swAA/8AVDv+zAAD/5lM4/7MA\nAP/tZkP/swAA/9w/K/+zAAD/wBUO/7MAAP/AFQ7/3D8r/7MAAP+zAAD/swAA/7MAAP+zAAD/\nswAA/7MAAP/mUzj/swAA/7MAAP/8sXX/swAA/7MAAP/AFQ7/5lM4/7MAAP+zAAD/7WZD//zD\ng//90ZX/9HlO//R5Tv+zAAD/swAA/7MAAP/90ZX/swAA/7MAAP/mUzj/swAA/7MAAP+zAAD/\nziod/7MAAP/8sXX/swAA/9w/K//AFQ7//MOD/9w/K/+zAAD//dur/9w/K/+zAAD/swAA/7MA\nAP/AFQ7/swAA/7MAAP+zAAD/9HlO//yfZ//cPyv/swAA//R5Tv/mUzj/swAA/+1mQ//mUzj/\n/J9n/7MAAP/OKh3/swAA//yxdf+zAAD/swAA//3Rlf/0eU7/3D8r/+ZTOP/8jVn/swAA/84q\nHf+zAAD/wBUO/7MAAP+zAAD/wBUO/7MAAP+zAAD/swAA/8AVDv/AFQ7/swAA/7MAAP+zAAD/\nswAA//3Rlf/tZkP/3D8r/9w/K/+zAAD/swAA/84qHf/8sXX//J9n/9w/K/+zAAD/swAA/7MA\nAP+zAAD/swAA/8AVDv+zAAD/wBUO/7MAAP+zAAD/swAA//zDg/+zAAD//J9n/9w/K/+zAAD/\nswAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/0eU7/wBUO/7MA\nAP+zAAD/swAA/8AVDv+zAAD/swAA//3bq//8sXX/3D8r/7MAAP/8n2f//J9n/7MAAP+zAAD/\n3D8r/+ZTOP+zAAD//J9n/7MAAP+zAAD//I1Z/+1mQ//0eU7/3D8r/7MAAP/8w4P/swAA/84q\nHf+zAAD/swAA/84qHf/OKh3/swAA/84qHf+zAAD/swAA/+1mQ/+zAAD/swAA//yxdf+zAAD/\nziod/7MAAP/926v/swAA/7MAAP+zAAD/swAA/7MAAP/mUzj/swAA/84qHf+zAAD/swAA/8AV\nDv/8sXX/swAA/7MAAP+zAAD/wBUO/7MAAP+zAAD//dGV/7MAAP/mUzj/swAA/7MAAP/OKh3/\nswAA/7MAAP+zAAD/swAA/8AVDv/90ZX/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/7WZD/7MA\nAP/0eU7/swAA/7MAAP+zAAD//J9n/8AVDv+zAAD//LF1/7MAAP/8jVn/ziod/7MAAP/8w4P/\nziod/7MAAP/AFQ7/9HlO//zDg//0eU7/3D8r//3Rlf+zAAD/swAA/+1mQ//8jVn/9HlO//R5\nTv+zAAD/swAA/7MAAP+zAAD//dGV/7MAAP+zAAD/swAA/+1mQ//0eU7/wBUO/7MAAP/AFQ7/\nwBUO/7MAAP/926v/7WZD/7MAAP/8sXX/swAA/7MAAP/tZkP/9HlO/+1mQ/+zAAD/swAA/7MA\nAP+zAAD/swAA/7MAAP/AFQ7/swAA//3Rlf+zAAD/swAA/7MAAP/0eU7/swAA/9w/K/+zAAD/\nswAA/8AVDv+zAAD//dGV/+ZTOP/8n2f/9HlO/84qHf+zAAD/swAA/+1mQ//926v/wBUO/7MA\nAP+zAAD/swAA/7MAAP/90ZX/swAA/7MAAP/8n2f/swAA/7MAAP+zAAD/swAA//yxdf/8jVn/\n/J9n/7MAAP+zAAD/swAA/7MAAP/AFQ7/swAA/7MAAP+zAAD//MOD/7MAAP/cPyv/swAA/8AV\nDv+zAAD/swAA/7MAAP+zAAD/wBUO/+ZTOP+zAAD/swAA//yNWf/8jVn/5lM4//yNWf+zAAD/\nswAA//yNWf+zAAD/swAA/7MAAP/mUzj/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/9HlO/8AV\nDv/0eU7/swAA/84qHf+zAAD/swAA/7MAAP/OKh3/swAA/8AVDv/90ZX/swAA/7MAAP+zAAD/\nwBUO/7MAAP+zAAD/swAA/7MAAP/OKh3/swAA//zDg//OKh3/7WZD/7MAAP+zAAD/wBUO/7MA\nAP+zAAD/3D8r/7MAAP/8w4P/wBUO/8AVDv/OKh3/swAA/+1mQ//90ZX/7WZD/9w/K//AFQ7/\nswAA/8AVDv+zAAD/9HlO/8AVDv/AFQ7/wBUO/7MAAP/8jVn/ziod/7MAAP+zAAD/swAA/7MA\nAP/OKh3/3D8r/8AVDv+zAAD/5lM4/7MAAP/OKh3/ziod//yNWf/0eU7//J9n/7MAAP/8sXX/\nswAA/7MAAP+zAAD/swAA/7MAAP/90ZX/3D8r/8AVDv+zAAD/swAA//3bq//AFQ7/swAA/84q\nHf+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/0eU7//LF1/7MAAP+zAAD/\nziod//zDg/+zAAD/swAA/7MAAP/AFQ7/swAA//3Rlf+zAAD//LF1/8AVDv+zAAD/wBUO/9w/\nK//90ZX/wBUO/7MAAP/AFQ7/swAA/9w/K//8jVn//dGV/+ZTOP+zAAD/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/swAA//3Rlf+zAAD/wBUO//3Rlf+zAAD/wBUO//3Rlf/mUzj/swAA/7MA\nAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/AFQ7/swAA/7MAAP/OKh3//J9n/7MAAP+zAAD/\nswAA/7MAAP/OKh3/swAA//yfZ/+zAAD//MOD/7MAAP+zAAD/swAA/7MAAP/AFQ7/swAA/7MA\nAP+zAAD/5lM4//zDg/+zAAD/swAA//zDg/+zAAD/swAA/7MAAP/8sXX/wBUO/7MAAP+zAAD/\n7WZD/7MAAP+zAAD/wBUO/9w/K//mUzj/3D8r/8AVDv+zAAD/swAA//yfZ/+zAAD/3D8r/7MA\nAP/tZkP/ziod//yxdf/8sXX/swAA/84qHf/OKh3/3D8r/7MAAP+zAAD/swAA//yfZ/+zAAD/\nswAA/7MAAP+zAAD/swAA/7MAAP/AFQ7/swAA/8AVDv/8n2f/swAA/7MAAP+zAAD/swAA//yN\nWf/cPyv/swAA/+1mQ//OKh3/wBUO//zDg//cPyv/swAA/7MAAP+zAAD//dGV/8AVDv+zAAD/\n/J9n/7MAAP+zAAD/swAA/+1mQ/+zAAD/swAA/7MAAP/tZkP/3D8r/7MAAP/AFQ7/3D8r//R5\nTv+zAAD/swAA/8AVDv+zAAD//dGV//R5Tv/AFQ7/3D8r/7MAAP+zAAD/swAA/7MAAP+zAAD/\n3D8r/7MAAP/mUzj/swAA/8AVDv+zAAD/wBUO//3Rlf+zAAD/swAA/8AVDv+zAAD/swAA//yN\nWf/tZkP/wBUO/7MAAP/mUzj/ziod/84qHf+zAAD/swAA/7MAAP+zAAD/9HlO/7MAAP+zAAD/\n/I1Z/7MAAP/AFQ7/9HlO/7MAAP/AFQ7/wBUO/84qHf/AFQ7/wBUO//3Rlf+zAAD//MOD/7MA\nAP/926v/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD//dur/7MAAP/0eU7/3D8r/7MAAP/8jVn/\n3D8r//R5Tv/90ZX/swAA/7MAAP+zAAD/swAA/8AVDv+zAAD/swAA/84qHf+zAAD//dGV/+ZT\nOP/cPyv/7WZD/7MAAP/OKh3//dur/7MAAP/8w4P/wBUO//yNWf+zAAD/swAA//3bq//tZkP/\nswAA/7MAAP+zAAD/swAA/+ZTOP+zAAD/swAA//zDg/+zAAD/7WZD/9w/K/+zAAD/swAA/8AV\nDv+zAAD/swAA/8AVDv/0eU7//I1Z/84qHf/cPyv/5lM4/8AVDv/8w4P/swAA/7MAAP+zAAD/\n/LF1//yNWf/OKh3//J9n/9w/K/+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MA\nAP/8sXX/swAA/+ZTOP/tZkP/wBUO/7MAAP/cPyv/swAA/7MAAP/AFQ7//J9n/84qHf+zAAD/\nswAA/7MAAP+zAAD//LF1/7MAAP/OKh3//I1Z/7MAAP+zAAD/3D8r/8AVDv/AFQ7/swAA//3R\nlf+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/AFQ7/swAA/7MAAP+zAAD/swAA//yxdf+zAAD/\n/I1Z//3Rlf/OKh3//J9n//zDg//90ZX/ziod/7MAAP+zAAD/5lM4/7MAAP+zAAD/swAA/7MA\nAP/90ZX/swAA/7MAAP/tZkP//dGV/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/8AVDv/8jVn/\nswAA/8AVDv/OKh3/swAA//3Rlf+zAAD/swAA//R5Tv+zAAD//I1Z/7MAAP/OKh3/3D8r/+ZT\nOP/OKh3/swAA/7MAAP/OKh3/3D8r/9w/K//8sXX/swAA/+1mQ/+zAAD/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/5lM4//3bq//cPyv/swAA/7MAAP/AFQ7/7WZD/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA/7MAAP/0eU7/wBUO/7MAAP/AFQ7/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD//J9n/7MAAP/90ZX/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA//zDg/+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/tZkP/\nswAA//yNWf/mUzj/swAA/7MAAP+zAAD/5lM4//yxdf+zAAD/swAA/7MAAP/OKh3/swAA/7MA\nAP+zAAD/swAA/7MAAP/8w4P//MOD/7MAAP+zAAD/ziod/7MAAP+zAAD/swAA//yfZ//AFQ7/\nswAA/7MAAP+zAAD/swAA/84qHf+zAAD//J9n/7MAAP+zAAD/swAA/84qHf/OKh3//LF1/84q\nHf/AFQ7/ziod//yNWf/8n2f//dur/7MAAP/8sXX/swAA/7MAAP+zAAD/swAA/7MAAP/cPyv/\n/MOD/7MAAP/OKh3/swAA/7MAAP/8n2f/swAA/+ZTOP/mUzj//LF1/+1mQ/+zAAD/5lM4/8AV\nDv/0eU7/3D8r/+ZTOP+zAAD/swAA/7MAAP/90ZX/ziod//yNWf/8sXX/wBUO/7MAAP/AFQ7/\nswAA/7MAAP+zAAD/swAA//3Rlf/0eU7/swAA//yfZ/+zAAD/wBUO/7MAAP+zAAD/wBUO/7MA\nAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/wBUO/7MAAP+zAAD/\nwBUO//zDg/+zAAD/swAA/7MAAP+zAAD/swAA/9w/K/+zAAD/swAA/84qHf/tZkP/3D8r/8AV\nDv/AFQ7/swAA//yNWf/8w4P//dGV/7MAAP/0eU7/swAA/9w/K//0eU7//dGV//R5Tv/AFQ7/\nswAA/7MAAP+zAAD/swAA/7MAAP/8n2f/wBUO/+ZTOP+zAAD/swAA//3Rlf+zAAD//MOD/8AV\nDv+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/8jVn//LF1/7MAAP+zAAD/swAA/7MAAP+zAAD/\nziod/+1mQ//8n2f/swAA/8AVDv/AFQ7/swAA/7MAAP/926v//dGV/7MAAP+zAAD/swAA/7MA\nAP+zAAD/3D8r/7MAAP+zAAD/swAA/84qHf+zAAD/swAA/+1mQ/+zAAD/swAA/8AVDv+zAAD/\nswAA/7MAAP/cPyv/7WZD/7MAAP/90ZX/swAA/7MAAP+zAAD/swAA/84qHf/90ZX/3D8r/7MA\nAP+zAAD/swAA/8AVDv+zAAD//dGV/7MAAP/90ZX//I1Z//3bq//AFQ7//dGV/+1mQ//90ZX/\nswAA/8AVDv/AFQ7//dGV/8AVDv/0eU7/swAA/7MAAP/AFQ7/swAA/7MAAP/mUzj//MOD//yf\nZ//AFQ7//dGV/7MAAP+zAAD//LF1/7MAAP/mUzj//MOD/7MAAP/AFQ7/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/wBUO/7MAAP+zAAD/wBUO//yNWf/8w4P//dGV/9w/K/+zAAD//dur/+ZT\nOP/8jVn/swAA/8AVDv+zAAD/ziod//zDg/+zAAD/swAA/84qHf/OKh3/ziod/7MAAP+zAAD/\nswAA/7MAAP/AFQ7/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/mUzj/swAA/7MA\nAP+zAAD/wBUO/7MAAP+zAAD/3D8r//yfZ//0eU7/swAA/7MAAP/8sXX/swAA/7MAAP/cPyv/\nswAA//R5Tv+zAAD/swAA/7MAAP/OKh3//dur/84qHf+zAAD/5lM4/+1mQ//8jVn//I1Z/8AV\nDv/8jVn/swAA/7MAAP+zAAD/swAA/+ZTOP/90ZX/swAA//R5Tv/tZkP/swAA/7MAAP/cPyv/\n3D8r//3bq/+zAAD/swAA/7MAAP/8n2f/5lM4//zDg/+zAAD/swAA/7MAAP/AFQ7/swAA/7MA\nAP/90ZX/swAA/7MAAP+zAAD/swAA/8AVDv+zAAD//LF1/7MAAP/8n2f/swAA//3Rlf/AFQ7/\nswAA/+ZTOP/8w4P/swAA//3Rlf+zAAD//MOD//R5Tv+zAAD//LF1//zDg/+zAAD/wBUO/84q\nHf/cPyv/swAA/+ZTOP/90ZX/swAA/7MAAP/8sXX/3D8r//zDg//tZkP/ziod/8AVDv/OKh3/\nswAA//zDg/+zAAD//MOD/7MAAP/8w4P/swAA/9w/K//AFQ7/swAA/9w/K//8jVn/swAA/9w/\nK//OKh3/3D8r//yxdf/8w4P/swAA//yxdf+zAAD//dur/7MAAP/cPyv//J9n//yxdf+zAAD/\nswAA//zDg/+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/AFQ7/swAA/7MAAP/8jVn/5lM4/7MA\nAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/cPyv/swAA/7MAAP+zAAD/5lM4//R5Tv/926v/\nswAA//3Rlf/926v/swAA/9w/K//8jVn/ziod//3Rlf+zAAD/swAA/7MAAP/8sXX//I1Z/7MA\nAP/cPyv/swAA/7MAAP+zAAD/3D8r//yNWf/8w4P/swAA//yxdf/8sXX/swAA//yfZ//8w4P/\nswAA/9w/K/+zAAD/3D8r/7MAAP/0eU7/3D8r/9w/K//90ZX/5lM4//3bq//8jVn/9HlO/7MA\nAP/8jVn/swAA//zDg//8sXX/swAA//yNWf+zAAD/swAA/7MAAP/8w4P/swAA/9w/K//OKh3/\nswAA//yxdf+zAAD/swAA/8AVDv/AFQ7//LF1//3Rlf/8jVn/swAA/7MAAP+zAAD/swAA/7MA\nAP/0eU7/9HlO/7MAAP/926v/5lM4//R5Tv/0eU7/5lM4//zDg//8sXX/7WZD/9w/K//8sXX/\n7WZD/+1mQ/+zAAD/swAA//yxdf/8n2f/swAA//yxdf/8jVn/ziod/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA//3bq/+zAAD/swAA/7MAAP/cPyv/wBUO/7MAAP+zAAD/swAA//3bq//mUzj/\n/MOD/+1mQ//8sXX/swAA//3Rlf+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/8AV\nDv+zAAD//dGV/7MAAP/cPyv/swAA/9w/K//tZkP//dGV//3Rlf/0eU7/9HlO//yfZ//mUzj/\nswAA/8AVDv+zAAD/swAA/8AVDv/AFQ7/swAA//3bq//cPyv/swAA/84qHf/AFQ7/9HlO/+ZT\nOP+zAAD/swAA/7MAAP+zAAD/swAA//R5Tv/8jVn/7WZD/+1mQ/+zAAD/swAA/9w/K/+zAAD/\nswAA//yfZ/+zAAD/swAA/9w/K/+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD//MOD//3b\nq/+zAAD/swAA//yNWf/tZkP/wBUO/7MAAP/AFQ7/wBUO/7MAAP/926v/swAA/7MAAP/90ZX/\nswAA/7MAAP/90ZX/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD//dGV/+ZTOP/AFQ7//MOD/9w/\nK//926v/ziod/7MAAP+zAAD//I1Z/7MAAP+zAAD//dGV/9w/K//8jVn//LF1//R5Tv+zAAD/\nswAA/7MAAP/90ZX/swAA/+ZTOP/8n2f/9HlO//zDg//8w4P/ziod/7MAAP/90ZX//dGV/7MA\nAP/90ZX/swAA/7MAAP+zAAD/swAA//yxdf/8n2f/3D8r/84qHf/tZkP/7WZD/7MAAP/OKh3/\nswAA/7MAAP+zAAD/swAA/8AVDv/cPyv/ziod//yNWf/tZkP/ziod/7MAAP/AFQ7/swAA/7MA\nAP+zAAD/swAA/7MAAP+zAAD//MOD/7MAAP+zAAD//LF1//yfZ//8w4P/wBUO//yxdf/95cL/\nziod/7MAAP/926v/3D8r/7MAAP+zAAD/3D8r/7MAAP/cPyv/swAA/7MAAP+zAAD/3D8r/7MA\nAP+zAAD/swAA/7MAAP+zAAD/wBUO/7MAAP+zAAD/swAA/7MAAP/cPyv/swAA/7MAAP+zAAD/\nswAA//yxdf/8w4P/swAA/7MAAP+zAAD/wBUO/7MAAP/cPyv//I1Z/7MAAP/8w4P/wBUO/8AV\nDv/926v/5lM4/9w/K//AFQ7//dur/7MAAP/8jVn/7WZD/9w/K/+zAAD/5lM4//3bq//0eU7/\nswAA//yxdf+zAAD/7WZD//3Rlf/OKh3/wBUO/+1mQ//8w4P/swAA/8AVDv/mUzj/swAA//R5\nTv/OKh3/swAA/7MAAP+zAAD/3D8r/7MAAP+zAAD/swAA/8AVDv/8n2f/7WZD/7MAAP/AFQ7/\n/I1Z/7MAAP/OKh3//LF1/7MAAP+zAAD/5lM4//3Rlf+zAAD//MOD/7MAAP/AFQ7//I1Z/8AV\nDv/8n2f/swAA/84qHf+zAAD/swAA/7MAAP/AFQ7/swAA/7MAAP/AFQ7/swAA/7MAAP+zAAD/\nswAA/7MAAP/0eU7/3D8r/9w/K//tZkP//LF1/7MAAP/cPyv/5lM4/84qHf/cPyv/ziod//3R\nlf/8n2f/swAA//yfZ//0eU7/3D8r/7MAAP/0eU7/swAA/84qHf/AFQ7/ziod//R5Tv/8w4P/\nswAA/7MAAP+zAAD/swAA//yfZ/+zAAD//J9n/7MAAP+zAAD/7WZD//R5Tv/AFQ7/swAA//3b\nq//8w4P//dGV//yfZ//8sXX/3D8r/7MAAP/cPyv//LF1//R5Tv/8n2f//I1Z//yNWf+zAAD/\n/I1Z/7MAAP/OKh3/swAA/7MAAP+zAAD/swAA/+1mQ//AFQ7//dGV//yxdf/8n2f/swAA/7MA\nAP+zAAD/3D8r//zDg//0eU7//dGV/+ZTOP/cPyv//dur/7MAAP/8n2f//eXC/9w/K/+zAAD/\n3D8r/+1mQ//cPyv/3D8r/7MAAP/AFQ7/swAA//yxdf/0eU7/swAA/7MAAP+zAAD/3D8r/7MA\nAP+zAAD/ziod/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA//3bq//cPyv/swAA/84qHf+zAAD/\nwBUO/7MAAP+zAAD/wBUO//yxdf+zAAD//LF1/9w/K//8w4P/swAA/7MAAP/8w4P/5lM4/9w/\nK//OKh3/ziod/84qHf/926v//I1Z//zDg/+zAAD/swAA/+ZTOP/mUzj/swAA/8AVDv/8jVn/\n5lM4//yNWf+zAAD/swAA//yfZ//8jVn//J9n//yfZ//0eU7//dur/7MAAP+zAAD/3D8r//3R\nlf/926v/9HlO//yNWf/mUzj/9HlO/7MAAP/OKh3/7WZD//3Rlf/90ZX/swAA/7MAAP+zAAD/\n5lM4/7MAAP/AFQ7/swAA/7MAAP+zAAD/3D8r/7MAAP/AFQ7/swAA/7MAAP+zAAD/swAA/9w/\nK//926v/swAA/7MAAP/tZkP/9HlO/84qHf/8sXX/9HlO/7MAAP+zAAD/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/swAA/7MAAP+zAAD/wBUO/7MAAP+zAAD/swAA/7MAAP+zAAD//MOD/7MA\nAP+zAAD/swAA/8AVDv/8sXX/wBUO/7MAAP+zAAD/7WZD/7MAAP+zAAD/swAA/7MAAP+zAAD/\nwBUO/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/8jVn/swAA/84qHf/OKh3/swAA/9w/\nK//cPyv//MOD/9w/K//cPyv/swAA/7MAAP/0eU7//dGV//zDg//8w4P/swAA/7MAAP+zAAD/\nswAA//zDg/+zAAD/swAA/7MAAP+zAAD/wBUO/9w/K//mUzj/swAA/7MAAP+zAAD/ziod/7MA\nAP+zAAD/wBUO/7MAAP/tZkP/swAA/9w/K/+zAAD//dur//3Rlf+zAAD/wBUO/7MAAP+zAAD/\n/MOD/7MAAP+zAAD/swAA/+ZTOP+zAAD//I1Z//yxdf/926v/swAA/7MAAP+zAAD/swAA/7MA\nAP/tZkP/9HlO/84qHf/AFQ7/swAA/84qHf/OKh3/swAA/7MAAP/926v/swAA/7MAAP+zAAD/\nwBUO/7MAAP/AFQ7/3D8r/8AVDv/AFQ7/swAA/9w/K/+zAAD//J9n/8AVDv+zAAD/swAA/7MA\nAP+zAAD/swAA//yxdf/AFQ7/swAA//zDg//AFQ7//I1Z/7MAAP/tZkP//LF1//R5Tv/90ZX/\n/MOD//3lwv/AFQ7/wBUO/9w/K//tZkP//dur//yxdf+zAAD//LF1/7MAAP+zAAD/ziod/7MA\nAP/AFQ7/swAA/7MAAP/90ZX/swAA//R5Tv+zAAD/ziod/8AVDv+zAAD/wBUO/7MAAP+zAAD/\nwBUO//3bq/+zAAD//MOD/7MAAP/OKh3/7WZD//3Rlf+zAAD/swAA/7MAAP+zAAD/3D8r/9w/\nK/+zAAD//dGV/+ZTOP+zAAD/swAA//zDg/+zAAD/wBUO/8AVDv/AFQ7/swAA/7MAAP+zAAD/\nwBUO/9w/K//OKh3/swAA/9w/K/+zAAD/swAA/7MAAP/8n2f/swAA/7MAAP+zAAD/swAA/7MA\nAP/8jVn//I1Z/7MAAP/90ZX/swAA/9w/K/+zAAD//dur/7MAAP+zAAD/swAA/8AVDv/mUzj/\n/LF1/+1mQ//0eU7/ziod/+1mQ/+zAAD/9HlO//R5Tv/mUzj/swAA/7MAAP+zAAD/swAA/84q\nHf/90ZX/3D8r//yNWf/8w4P//J9n/7MAAP+zAAD/5lM4/7MAAP+zAAD/swAA//zDg//8sXX/\n/dGV//yfZ/+zAAD/swAA/7MAAP+zAAD/swAA//7w2f/8n2f//dur/7MAAP+zAAD/swAA/7MA\nAP/AFQ7/swAA/84qHf/0eU7/swAA//yNWf/tZkP/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/\n/MOD/9w/K//AFQ7//dGV/+ZTOP+zAAD/3D8r//zDg/+zAAD/wBUO/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA/7MAAP/mUzj/swAA/7MAAP/AFQ7/swAA/7MAAP+zAAD/ziod/84qHf+zAAD/\nswAA/7MAAP/cPyv/wBUO//yxdf/0eU7/ziod//yxdf+zAAD/swAA/7MAAP/8w4P/swAA/9w/\nK/+zAAD/swAA/+1mQ/+zAAD/wBUO/84qHf/90ZX/swAA//3Rlf/8sXX/swAA//3bq//0eU7/\nswAA/8AVDv+zAAD/swAA/+1mQ//AFQ7/wBUO/7MAAP/AFQ7/swAA/+1mQ/+zAAD/swAA/9w/\nK//tZkP/wBUO/9w/K//8n2f//I1Z/7MAAP/8n2f/wBUO/8AVDv/AFQ7/swAA/7MAAP/90ZX/\nswAA/7MAAP+zAAD/swAA//3Rlf+zAAD/swAA/+ZTOP/8w4P/wBUO//yxdf/8n2f/swAA/7MA\nAP/OKh3/5lM4/7MAAP+zAAD/swAA/8AVDv/OKh3//J9n/9w/K//tZkP//dGV/9w/K//0eU7/\n7WZD/7MAAP/cPyv/swAA/9w/K//8n2f/9HlO/7MAAP/8w4P/swAA/7MAAP+zAAD/3D8r/7MA\nAP+zAAD/3D8r/9w/K/+zAAD//dGV/9w/K//90ZX//J9n/7MAAP/8jVn/swAA//yNWf/8w4P/\nswAA/7MAAP+zAAD/3D8r/8AVDv/cPyv/swAA/+1mQ//mUzj/ziod//zDg/+zAAD/swAA/7MA\nAP/8n2f/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/9w/K/+zAAD//MOD/7MAAP/cPyv/\n5lM4/84qHf/tZkP//I1Z//yfZ//OKh3//vDZ/8AVDv/tZkP/swAA/9w/K//0eU7/3D8r//yx\ndf/cPyv/9HlO/7MAAP/cPyv/swAA/+ZTOP/tZkP//LF1/8AVDv/AFQ7/swAA//R5Tv/8jVn/\nswAA//3Rlf/926v//LF1//R5Tv+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/8sXX/wBUO//3R\nlf/90ZX//J9n//yNWf/8n2f//MOD//zDg//8n2f/ziod/7MAAP/8sXX/wBUO//3Rlf/926v/\n/dur/+ZTOP+zAAD/wBUO//R5Tv/AFQ7/swAA/9w/K/+zAAD/wBUO/7MAAP/8w4P//dGV/9w/\nK//AFQ7/7WZD//zDg//90ZX/swAA//R5Tv/8jVn/swAA/7MAAP/tZkP/ziod/7MAAP/OKh3/\nswAA/+1mQ//OKh3/9HlO//yxdf+zAAD/ziod//zDg/+zAAD/swAA/7MAAP/8w4P/swAA/7MA\nAP/AFQ7/swAA/7MAAP/tZkP//J9n/7MAAP/cPyv/swAA/+ZTOP/tZkP/3D8r//yNWf/8jVn/\n/I1Z/8AVDv/8w4P/9HlO/9w/K//AFQ7/3D8r/7MAAP/8n2f/3D8r//yfZ/+zAAD/9HlO/9w/\nK//OKh3/swAA/+ZTOP/90ZX//dur/84qHf+zAAD/5lM4/7MAAP/cPyv//LF1/7MAAP+zAAD/\nswAA/7MAAP/AFQ7/swAA/8AVDv+zAAD/swAA//R5Tv+zAAD/3D8r/+1mQ//90ZX//LF1//yx\ndf/OKh3/3D8r/8AVDv/AFQ7//dGV/8AVDv+zAAD//dur/7MAAP/mUzj/wBUO/7MAAP/8n2f/\nswAA/84qHf/OKh3/swAA/9w/K//cPyv/swAA/+1mQ//cPyv//I1Z/84qHf/OKh3/7WZD//3b\nq//8w4P/swAA//R5Tv+zAAD/wBUO/9w/K//90ZX//dGV/7MAAP+zAAD/9HlO//3Rlf/mUzj/\n/dGV//zDg//8jVn/swAA/9w/K/+zAAD/swAA/7MAAP/cPyv/swAA//zDg//mUzj/swAA/8AV\nDv+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/8n2f/swAA/+1mQ//mUzj/swAA/7MAAP+zAAD/\nswAA/7MAAP/tZkP/swAA/7MAAP/8n2f//I1Z//3bq/+zAAD/swAA/7MAAP+zAAD/wBUO/7MA\nAP+zAAD/swAA//yxdf/8n2f//J9n/7MAAP+zAAD/wBUO/9w/K/+zAAD/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/swAA/84qHf+zAAD/swAA/7MAAP/AFQ7/ziod/7MAAP/tZkP/swAA/7MA\nAP/OKh3/swAA/7MAAP/AFQ7/5lM4/+1mQ/+zAAD/swAA/7MAAP+zAAD/5lM4/7MAAP+zAAD/\nswAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA//yxdf/8sXX/swAA//3Rlf+zAAD/swAA/8AV\nDv/AFQ7/swAA/7MAAP/mUzj/swAA//R5Tv/8n2f/5lM4/7MAAP+zAAD/swAA/84qHf+zAAD/\nswAA/7MAAP/0eU7/swAA/7MAAP+zAAD//I1Z/7MAAP+zAAD/swAA/9w/K/+zAAD/3D8r/+1m\nQ//AFQ7//dGV/8AVDv/8w4P//dur//R5Tv+zAAD/5lM4/7MAAP/90ZX/7WZD/8AVDv+zAAD/\nswAA/7MAAP+zAAD/swAA//zDg/+zAAD//I1Z/7MAAP+zAAD/wBUO/+1mQ//AFQ7//dur/7MA\nAP+zAAD//dGV/+ZTOP/tZkP/3D8r/7MAAP/8w4P/7WZD/+1mQ/+zAAD//I1Z/+1mQ//AFQ7/\nswAA/7MAAP/8sXX/swAA/7MAAP+zAAD/5lM4/7MAAP+zAAD/swAA/7MAAP+zAAD/wBUO/7MA\nAP/mUzj/5lM4/7MAAP/mUzj/5lM4/+ZTOP/90ZX/wBUO/+1mQ//8jVn//MOD//R5Tv+zAAD/\nswAA/7MAAP+zAAD/swAA/7MAAP/cPyv/wBUO/7MAAP+zAAD/swAA//yxdf+zAAD/swAA/7MA\nAP+zAAD/swAA/7MAAP+zAAD/swAA/8AVDv+zAAD/swAA//zDg/+zAAD/swAA/8AVDv/cPyv/\nziod/7MAAP+zAAD/swAA//zDg/+zAAD/swAA/7MAAP+zAAD/ziod/8AVDv/AFQ7/swAA/7MA\nAP/AFQ7/ziod/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD//MOD/8AVDv/OKh3/\nswAA//3bq/+zAAD/swAA//R5Tv/8w4P/swAA//R5Tv+zAAD/wBUO/8AVDv+zAAD/swAA/7MA\nAP+zAAD//LF1/+ZTOP+zAAD/5lM4/7MAAP/mUzj/swAA/7MAAP+zAAD/swAA/7MAAP/8jVn/\n/MOD/7MAAP+zAAD//LF1/+ZTOP/8sXX/swAA/84qHf/926v/swAA//yxdf+zAAD/swAA/7MA\nAP/8jVn/swAA//R5Tv/926v/swAA/8AVDv/OKh3/swAA/7MAAP/OKh3/3D8r/84qHf/cPyv/\n/MOD/9w/K//cPyv//MOD//3Rlf/AFQ7/swAA/9w/K//0eU7/swAA/7MAAP+zAAD/swAA//3b\nq//cPyv//dGV//yfZ//cPyv//J9n/+ZTOP/8w4P/wBUO/84qHf+zAAD//MOD/7MAAP/AFQ7/\nswAA//yfZ/+zAAD/swAA/+1mQ//8n2f/swAA//zDg/+zAAD/swAA/7MAAP/tZkP/swAA/7MA\nAP+zAAD/swAA/7MAAP/mUzj/7WZD/7MAAP+zAAD/swAA/7MAAP+zAAD/wBUO/+ZTOP+zAAD/\nswAA/7MAAP+zAAD/3D8r/9w/K//cPyv//dur//yxdf+zAAD/swAA/7MAAP+zAAD/wBUO//zD\ng/+zAAD/5lM4/84qHf/90ZX/9HlO/7MAAP+zAAD/swAA//R5Tv+zAAD//dGV/7MAAP+zAAD/\n/MOD//yxdf/8sXX/swAA/9w/K/+zAAD/swAA/+ZTOP+zAAD/swAA/7MAAP+zAAD/swAA/9w/\nK/+zAAD/swAA/7MAAP+zAAD/3D8r/9w/K//cPyv/swAA/84qHf+zAAD/3D8r/7MAAP/8n2f/\n/LF1/7MAAP+zAAD//MOD/8AVDv/0eU7/swAA/9w/K//8n2f//MOD/7MAAP/8sXX/swAA//3R\nlf/8sXX//MOD//R5Tv/90ZX/ziod//yxdf/8jVn//LF1/9w/K//8n2f//I1Z/7MAAP/AFQ7/\n/J9n//yNWf/AFQ7/swAA//3Rlf/8n2f/swAA//yNWf/AFQ7/3D8r/7MAAP+zAAD//MOD/9w/\nK//8w4P/7WZD//3Rlf/AFQ7/wBUO/7MAAP/mUzj/swAA/7MAAP/8jVn/wBUO/7MAAP/8jVn/\n3D8r/7MAAP/AFQ7/3D8r/+ZTOP/90ZX/ziod/9w/K//tZkP/swAA/7MAAP+zAAD/7WZD/9w/\nK//cPyv/wBUO//zDg/+zAAD/9HlO/7MAAP/mUzj//LF1//3Rlf/tZkP/5lM4//yxdf/8n2f/\n/LF1/8AVDv+zAAD/swAA/7MAAP+zAAD/swAA/+ZTOP/cPyv//dur//zDg/+zAAD//dGV/7MA\nAP/8n2f//MOD/7MAAP/mUzj/3D8r/8AVDv/mUzj//I1Z/7MAAP/926v/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/swAA/84qHf+zAAD//dGV/8AVDv/AFQ7/swAA/7MAAP+zAAD//LF1/+ZT\nOP/cPyv//LF1/7MAAP+zAAD/swAA/9w/K/+zAAD/swAA/84qHf+zAAD//MOD/+1mQ//8w4P/\nswAA//R5Tv+zAAD/swAA/7MAAP/tZkP//LF1//3bq/+zAAD/3D8r/7MAAP/90ZX/3D8r/7MA\nAP/AFQ7/wBUO/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/wBUO/7MAAP+zAAD/\nswAA/7MAAP/90ZX/swAA/9w/K/+zAAD/5lM4//zDg/+zAAD/swAA/+1mQ/+zAAD/swAA/7MA\nAP/AFQ7/swAA/7MAAP+zAAD/7WZD//R5Tv+zAAD/swAA/8AVDv/926v//dGV/7MAAP/AFQ7/\n7WZD/9w/K/+zAAD/3D8r/9w/K/+zAAD/3D8r/7MAAP+zAAD/swAA/7MAAP/OKh3/5lM4/7MA\nAP+zAAD/ziod/8AVDv+zAAD/3D8r/7MAAP+zAAD/5lM4/7MAAP/8sXX/swAA/7MAAP/90ZX/\nwBUO/7MAAP/AFQ7/swAA/8AVDv+zAAD/swAA/7MAAP+zAAD/5lM4/7MAAP/8n2f/swAA/7MA\nAP+zAAD/wBUO//3Rlf/AFQ7/swAA/8AVDv/AFQ7/wBUO/7MAAP+zAAD/ziod/84qHf+zAAD/\nswAA/9w/K//cPyv//dGV/8AVDv/AFQ7/wBUO/7MAAP+zAAD//dGV//3Rlf/tZkP/swAA//yN\nWf/OKh3/swAA/7MAAP+zAAD//LF1/+1mQ//8sXX/3D8r/9w/K//AFQ7/ziod/7MAAP/8jVn/\n/dur//3bq//90ZX/7WZD/7MAAP/mUzj//LF1/7MAAP+zAAD/3D8r/+ZTOP/8n2f/swAA/9w/\nK//90ZX//dur/+1mQ//8sXX//MOD/7MAAP+zAAD/swAA/7MAAP+zAAD//dGV/9w/K/+zAAD/\n/dGV//yNWf/8w4P/ziod/7MAAP+zAAD/swAA//zDg//OKh3/swAA//3Rlf/tZkP/swAA/7MA\nAP+zAAD/wBUO/7MAAP/AFQ7/swAA/8AVDv+zAAD//eXC/9w/K/+zAAD/swAA//3Rlf+zAAD/\n/LF1/7MAAP+zAAD/wBUO/7MAAP+zAAD/wBUO//yNWf/cPyv/7WZD/8AVDv/8w4P/swAA/7MA\nAP+zAAD/swAA/+ZTOP/8n2f/wBUO/7MAAP+zAAD/swAA//3bq//AFQ7/swAA//zDg//8sXX/\nswAA/8AVDv/8n2f/5lM4/7MAAP/+8Nn//LF1//R5Tv+zAAD/swAA/7MAAP+zAAD/swAA//yf\nZ//8sXX//LF1/84qHf+zAAD/swAA//zDg//8sXX/swAA/7MAAP+zAAD/swAA/7MAAP/8jVn/\n5lM4/84qHf/cPyv/3D8r/7MAAP/0eU7/wBUO//3bq/+zAAD/7WZD/8AVDv/cPyv/wBUO/+ZT\nOP+zAAD/swAA/7MAAP+zAAD/ziod/7MAAP/AFQ7/swAA/7MAAP/cPyv/swAA/84qHf/95cL/\nswAA//zDg/+zAAD/swAA//7w2f/OKh3/wBUO/7MAAP+zAAD/swAA/7MAAP/8sXX/swAA/+ZT\nOP/8sXX/5lM4/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA//zDg//926v/5lM4//3Rlf/926v/\n5lM4/8AVDv/90ZX/wBUO/+1mQ/+zAAD/wBUO//yxdf+zAAD/ziod/7MAAP+zAAD/3D8r/7MA\nAP/AFQ7/wBUO/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/9w/K/+zAAD/\nwBUO/8AVDv/OKh3/ziod/9w/K/+zAAD/swAA//3Rlf/8w4P/swAA/7MAAP/cPyv/swAA/7MA\nAP/AFQ7//LF1/7MAAP/AFQ7/swAA/7MAAP/OKh3/wBUO/84qHf+zAAD/swAA/84qHf+zAAD/\nswAA/84qHf+zAAD/swAA/7MAAP+zAAD/5lM4/9w/K/+zAAD/swAA/8AVDv+zAAD/swAA/7MA\nAP/8sXX/wBUO/7MAAP/926v/swAA/7MAAP/AFQ7/wBUO//yfZ//8jVn/swAA/8AVDv/8w4P/\nswAA/7MAAP+zAAD/7WZD/84qHf+zAAD/swAA/7MAAP+zAAD/swAA//zDg//AFQ7/swAA/7MA\nAP/8sXX/ziod/7MAAP+zAAD/ziod/7MAAP/mUzj/swAA/7MAAP+zAAD/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/9w/K//8w4P/ziod/7MAAP+zAAD/wBUO/+ZT\nOP/OKh3//I1Z/7MAAP+zAAD//MOD/7MAAP/8jVn/swAA/8AVDv/cPyv/wBUO//yxdf+zAAD/\nswAA/8AVDv+zAAD/wBUO/7MAAP+zAAD//dur/8AVDv+zAAD/swAA/7MAAP/AFQ7/wBUO/84q\nHf/OKh3//I1Z/7MAAP+zAAD/swAA/7MAAP/8sXX/swAA/+1mQ//8w4P/swAA/7MAAP+zAAD/\nswAA/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/OKh3/9HlO/84qHf/OKh3/swAA/8AV\nDv/8w4P/ziod/9w/K//AFQ7/swAA/7MAAP+zAAD/swAA/84qHf/926v//I1Z//zDg/+zAAD/\n5lM4//yxdf+zAAD/swAA/84qHf+zAAD/5lM4/7MAAP/8sXX//dGV/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA//zDg/+zAAD/swAA/7MAAP+zAAD/3D8r/8AVDv/90ZX//LF1//3Rlf+zAAD/\nswAA/+1mQ//8jVn/swAA/7MAAP+zAAD/wBUO//3Rlf/tZkP/swAA/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA//yfZ/+zAAD/ziod//yfZ/+zAAD/swAA//yNWf/tZkP/swAA/7MAAP/8n2f/\nswAA/+1mQ/+zAAD/swAA/7MAAP+zAAD/wBUO/7MAAP/8w4P/swAA/7MAAP+zAAD/swAA/7MA\nAP+zAAD/swAA/7MAAP+zAAD//MOD/+1mQ//mUzj//LF1/84qHf+zAAD//I1Z//yfZ//AFQ7/\nswAA/7MAAP/cPyv/swAA/7MAAP/8jVn/9HlO//zDg//OKh3/swAA//zDg//8sXX/swAA//R5\nTv+zAAD/swAA/7MAAP/90ZX/7WZD/8AVDv+zAAD//LF1/84qHf+zAAD//J9n/7MAAP/8jVn/\n7WZD/7MAAP/8jVn//LF1/7MAAP+zAAD//I1Z/7MAAP+zAAD/ziod/7MAAP/8w4P/swAA/7MA\nAP+zAAD/ziod/7MAAP/tZkP/swAA//R5Tv+zAAD//MOD/8AVDv+zAAD/swAA/7MAAP/0eU7/\nwBUO/84qHf/mUzj/swAA/7MAAP/tZkP/swAA/8AVDv+zAAD/wBUO//3bq//cPyv//I1Z/7MA\nAP/8n2f/swAA/7MAAP/tZkP/swAA//yNWf+zAAD/wBUO//yfZ/+zAAD/swAA/+1mQ//AFQ7/\nziod/7MAAP+zAAD/swAA//zDg//mUzj/wBUO/84qHf/8w4P//dur/7MAAP+zAAD/swAA/+ZT\nOP/mUzj//dGV/7MAAP+zAAD//LF1/+ZTOP/OKh3/wBUO//yxdf+zAAD//LF1/7MAAP+zAAD/\nwBUO//3bq//0eU7//MOD//yfZ/+zAAD/wBUO/7MAAP+zAAD//MOD/7MAAP/cPyv//LF1/9w/\nK//AFQ7/ziod//yNWf/cPyv/5lM4/+1mQ/+zAAD/3D8r/7MAAP/OKh3/swAA//R5Tv+zAAD/\nswAA/7MAAP/tZkP//I1Z//R5Tv+zAAD/swAA/8AVDv+zAAD/9HlO/+ZTOP/90ZX/swAA/7MA\nAP+zAAD/swAA/7MAAP/mUzj/3D8r/7MAAP/926v//LF1//3lwv/OKh3/swAA/8AVDv/tZkP/\nswAA/7MAAP/AFQ7/wBUO//3Rlf+zAAD/5lM4/84qHf/OKh3/wBUO/7MAAP/8jVn/swAA/7MA\nAP/OKh3/swAA/7MAAP/OKh3/swAA/7MAAP+zAAD//LF1/7MAAP+zAAD//LF1/+ZTOP+zAAD/\nziod//yNWf/0eU7/3D8r//3Rlf/0eU7//dGV/+ZTOP+zAAD/swAA/+1mQ//90ZX/ziod//3b\nq/+zAAD//J9n/+1mQ/+zAAD/swAA/7MAAP/tZkP/swAA/8AVDv/AFQ7/swAA/+ZTOP/cPyv/\nswAA/84qHf/OKh3/wBUO/9w/K/+zAAD/5lM4/7MAAP+zAAD//J9n//3Rlf+zAAD/swAA//3R\nlf/0eU7/3D8r/+1mQ//0eU7/ziod/7MAAP/tZkP/7WZD/+ZTOP/cPyv/swAA/8AVDv/OKh3/\n7WZD/9w/K/+zAAD//MOD/7MAAP/tZkP/swAA/7MAAP/cPyv/wBUO/7MAAP+zAAD/swAA/7MA\nAP/8n2f//J9n//3bq/+zAAD/swAA/7MAAP+zAAD/9HlO/7MAAP/tZkP/swAA/7MAAP/AFQ7/\nswAA/7MAAP/tZkP//dGV//yNWf/tZkP/ziod/8AVDv/AFQ7//dGV/7MAAP/OKh3/5lM4//R5\nTv+zAAD/swAA//yNWf/mUzj/swAA//R5Tv+zAAD//MOD/7MAAP+zAAD//MOD/8AVDv/tZkP/\nziod/84qHf+zAAD/swAA/8AVDv/90ZX/7WZD/7MAAP/8jVn/ziod/84qHf/OKh3//dGV//3R\nlf+zAAD//dGV/7MAAP+zAAD/7WZD/8AVDv+zAAD/swAA/8AVDv+zAAD/7WZD/84qHf/8jVn/\nswAA/7MAAP+zAAD/swAA/84qHf+zAAD/swAA/9w/K//90ZX/7WZD//yNWf+zAAD/3D8r/7MA\nAP+zAAD/swAA/+ZTOP/OKh3/ziod/7MAAP/AFQ7/swAA//R5Tv/AFQ7/5lM4/7MAAP+zAAD/\n/dGV/7MAAP/0eU7/swAA/+ZTOP/0eU7/swAA//yxdf/OKh3/wBUO/+ZTOP/8sXX//MOD/84q\nHf/90ZX/wBUO/+ZTOP+zAAD//dGV/7MAAP/tZkP/wBUO/+ZTOP+zAAD//dGV/84qHf+zAAD/\n/LF1//3bq//tZkP/3D8r/7MAAP/8w4P/ziod/84qHf/tZkP/swAA/8AVDv+zAAD/ziod/7MA\nAP/cPyv/3D8r/7MAAP/tZkP/ziod/7MAAP/AFQ7/wBUO/7MAAP+zAAD/9HlO/+ZTOP/926v/\n9HlO/8AVDv/8sXX/swAA/9w/K/+zAAD/swAA//3Rlf/0eU7/ziod/7MAAP/mUzj/swAA/7MA\nAP/AFQ7/9HlO/+1mQ/+zAAD//dGV/+ZTOP+zAAD/swAA//R5Tv+zAAD/swAA/+ZTOP/tZkP/\nwBUO/7MAAP+zAAD//dGV/84qHf/8w4P/swAA/84qHf+zAAD/7WZD/+ZTOP/cPyv//J9n/7MA\nAP/AFQ7/wBUO/7MAAP+zAAD/swAA/7MAAP+zAAD//MOD/8AVDv/AFQ7/ziod//zDg//AFQ7/\nswAA/7MAAP/tZkP/swAA//yfZ/+zAAD/swAA/7MAAP/AFQ7//LF1//zDg/+zAAD//I1Z/7MA\nAP/8n2f/swAA/8AVDv/926v//MOD//3Rlf/8n2f/swAA/7MAAP/cPyv/3D8r//3Rlf+zAAD/\n7WZD/8AVDv/8n2f/9HlO/84qHf/8sXX/wBUO/7MAAP/cPyv//J9n//R5Tv/AFQ7/3D8r/8AV\nDv+zAAD//LF1//3Rlf+zAAD/swAA/7MAAP/cPyv/ziod//3bq//tZkP//MOD/9w/K//mUzj/\nziod/7MAAP/926v//dur/9w/K//mUzj//dGV/9w/K//8jVn/3D8r/8AVDv/8sXX/swAA/9w/\nK//mUzj/wBUO/7MAAP/AFQ7/3D8r/8AVDv/8sXX/swAA//3Rlf/AFQ7//I1Z//yfZ//8w4P/\n7WZD/7MAAP/8n2f/swAA//R5Tv/tZkP//MOD/7MAAP+zAAD//MOD//yxdf/cPyv/swAA//yf\nZ/+zAAD/wBUO/7MAAP+zAAD//dur//3bq//90ZX/swAA/84qHf+zAAD/wBUO/+1mQ//mUzj/\n/dGV/+1mQ/+zAAD/swAA/7MAAP/8n2f/wBUO/+ZTOP+zAAD//J9n/7MAAP/926v/wBUO/7MA\nAP/90ZX/swAA//3bq//926v//I1Z//yxdf+zAAD/5lM4//3Rlf/8jVn/wBUO/8AVDv+zAAD/\nwBUO/7MAAP+zAAD/5lM4/7MAAP/8sXX/3D8r/8AVDv+zAAD/5lM4/84qHf+zAAD/swAA/+1m\nQ/+zAAD//dGV//R5Tv+zAAD/swAA//zDg/+zAAD/swAA/9w/K/+zAAD/3D8r/7MAAP+zAAD/\n/MOD//3bq/+zAAD//dur/7MAAP/926v//J9n/7MAAP/OKh3/swAA/84qHf/OKh3//MOD/+ZT\nOP/8n2f//LF1/7MAAP+zAAD//J9n/84qHf/90ZX/5lM4/8AVDv/AFQ7/swAA/9w/K/+zAAD/\n/dGV//3Rlf/AFQ7/9HlO/7MAAP+zAAD/swAA/7MAAP+zAAD//J9n/84qHf+zAAD/swAA/7MA\nAP/AFQ7/swAA/7MAAP+zAAD/swAA//3Rlf+zAAD/ziod//zDg/+zAAD//dGV/+ZTOP/90ZX/\n3D8r/+1mQ//8jVn/swAA/8AVDv+zAAD/wBUO/9w/K//0eU7/5lM4//zDg/+zAAD//MOD//3R\nlf/tZkP/swAA/7MAAP/8sXX/9HlO/+1mQ//OKh3/ziod//3bq/+zAAD/7WZD/7MAAP+zAAD/\nswAA/7MAAP/AFQ7/swAA/8AVDv/AFQ7/3D8r/7MAAP/mUzj/swAA/+ZTOP/tZkP/swAA/8AV\n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\nDv+zAAD//LF1/84qHf/AFQ7//dur//R5Tv+zAAD/swAA/84qHf+zAAD//dGV/9w/K//mUzj/\n5lM4/7MAAP/OKh3//I1Z/+1mQ//90ZX/3D8r//zDg//8n2f/ziod/8AVDv/mUzj//I1Z/9w/\nK//0eU7/5lM4/9w/K//926v//dGV/84qHf/tZkP/ziod//yfZ//AFQ7/ziod/7MAAP/AFQ7/\nziod/7MAAP+zAAD/swAA/7MAAP+zAAD/swAA/7MAAP/cPyv/wBUO/+1mQ//8w4P/swAA/7MA\nAP+zAAD//LF1//yfZ//90ZX/swAA/7MAAP/8jVn//dGV/7MAAP+zAAD/3D8r/+1mQ//OKh3/\nswAA/7MAAP+zAAD//dur/7MAAP/mUzj/5lM4/7MAAP/AFQ7//LF1/7MAAP/90ZX/swAA/7MA\nAP+zAAD/swAA/9w/K//0eU7/wBUO/7MAAP/8jVn//MOD/7MAAP/OKh3/swAA/+ZTOP+zAAD/\nswAA//yfZ//8n2f/5lM4/8AVDv/OKh3/5lM4//yxdf/8jVn//MOD/7MAAP/8jVn/swAA/+ZT\nOP/mUzj/wBUO/+1mQ//cPyv/swAA/7MAAP/0eU7/7WZD//3Rlf+zAAD/swAA/+ZTOP/mUzj/\nswAA/+ZTOP/8n2f/swAA/7MAAP/8n2f/9HlO/84qHf/mUzj/7WZD/7MAAP/cPyv//I1Z/7MA\nAP+zAAD/9HlO//yfZ//90ZX/3D8r//yxdf/AFQ7//MOD/9w/K//90ZX//dGV/7MAAP/OKh3/\nziod/7MAAP+zAAD/swAA//R5Tv+zAAD/swAA/84qHf/AFQ7/wBUO//R5Tv/AFQ7/swAA/84q\nHf+zAAD/swAA/7MAAP+zAAD/swAA//3bq//8n2f/3D8r/8AVDv/90ZX/swAA/7MAAP/mUzj/\n/MOD/7MAAP/AFQ7//dGV/7MAAP+zAAD/swAA//3Rlf+zAAD/3D8r/7MAAP/cPyv/swAA/+ZT\nOP/mUzj/wBUO/9w/K//8jVn/wBUO/9w/K//AFQ7//LF1//yfZ//90ZX/swAA/7MAAP+zAAD/\n/dGV//3Rlf/90ZX//dur/7MAAP/cPyv/wBUO/7MAAP/8w4P/ziod//yfZ/+zAAD/swAA//zD\ng/+zAAD/swAA//zDg//AFQ7/9HlO/+ZTOP/AFQ7/ziod/7MAAP/OKh3/swAA/7MAAP/mUzj/\n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\nswAA/7MAAP/tZkP/7WZD/7MAAP/AFQ7//I1Z/+ZTOP/AFQ7/ziod//3Rlf/0eU7/swAA/7MA\nAP/8sXX/9HlO/9w/K/+zAAD//dur/7MAAP+zAAD/swAA/7MAAP/tZkP/5lM4/7MAAP+zAAD/\n9HlO/7MAAP/tZkP//I1Z/84qHf+zAAD/swAA/7MAAP/OKh3/swAA/8AVDv/mUzj/9HlO/84q\nHf+zAAD/9HlO//R5Tv+zAAD//I1Z/7MAAP+zAAD/ziod/7MAAP/90ZX//I1Z//yNWf/8sXX/\n7WZD//yNWf/mUzj/9HlO//yxdf/OKh3/swAA/8AVDv/8w4P/swAA/84qHf/cPyv/swAA/84q\nHf/8jVn/wBUO/7MAAP+zAAD/3D8r//3Rlf/cPyv//dGV/+ZTOP/8n2f/swAA/7MAAP/OKh3/\n/MOD//R5Tv+zAAD/5lM4/7MAAP/926v/9HlO/7MAAP/cPyv/5lM4/8AVDv/cPyv/swAA//yf\nZ/+zAAD//dGV/7MAAP/90ZX/3D8r/8AVDv/mUzj/swAA//3Rlf/90ZX/5lM4//3Rlf/mUzj/\n3D8r/8AVDv/90ZX/ziod//yNWf/8n2f/9HlO//3Rlf+zAAD/swAA/7MAAP/8sXX//I1Z//yx\ndf/OKh3//I1Z/7MAAP/AFQ7/3D8r/+ZTOP/OKh3/swAA/7MAAP/AFQ7//LF1/+ZTOP/AFQ7/\nswAA/8AVDv+zAAD/9HlO//3bq//cPyv//LF1/7MAAP+zAAD/wBUO/7MAAP+zAAD//MOD/+ZT\nOP/90ZX//dGV//yNWf+zAAD/5lM4/7MAAP+zAAD/3D8r/7MAAP/mUzj/ziod/7MAAP/tZkP/\n/LF1//R5Tv/AFQ7/wBUO/7MAAP/8n2f/wBUO/7MAAP+zAAD//dGV/7MAAP/mUzj/swAA/+1m\nQ/+zAAD/swAA/7MAAP/AFQ7//I1Z//yxdf+zAAD//dGV/84qHf+zAAD//dur/7MAAP+zAAD/\n3D8r/7MAAP+zAAD/ziod/+1mQ/+zAAD/5lM4/7MAAP+zAAD/swAA/+ZTOP+zAAD/swAA//3R\nlf/926v/swAA/8AVDv/90ZX/wBUO/8AVDv+zAAD/swAA//yxdf/8w4P/3D8r/7MAAP/cPyv/\nswAA/8AVDv/8n2f/ziod/7MAAP/OKh3/9HlO/+1mQ/+zAAD/wBUO//3bq//90ZX//I1Z/9w/\nK//cPyv/swAA/9w/K/+zAAD/wBUO//3Rlf+zAAD/swAA/9w/K//AFQ7//LF1/9w/K/+zAAD/\nziod/7MAAP/8jVn/wBUO/7MAAP/tZkP//MOD/7MAAP/AFQ7/swAA//yxdf/cPyv/5lM4/7MA\nAP/cPyv/wBUO/+1mQ//cPyv//LF1/7MAAP+zAAD/5lM4/8AVDv/0eU7/wBUO/7MAAP+zAAD/\nswAA//yNWf+zAAD/swAA//yfZ/+zAAD/ziod//3Rlf/8n2f//J9n/+ZTOP+zAAD/ziod/+ZT\nOP/8n2f//I1Z/8AVDv/mUzj/3D8r/9w/K//cPyv//MOD/9w/K//90ZX/7WZD/8AVDv+zAAD/\nziod//3bq/+zAAD/swAA//yxdf/OKh3//LF1/7MAAP/8sXX/swAA/7MAAP+zAAD/wBUO/7MA\nAP/cPyv/swAA/+ZTOP+zAAD//J9n/84qHf/AFQ7/swAA/+ZTOP+zAAD/7WZD/+1mQ//mUzj/\nwBUO/+ZTOP/AFQ7//dGV/7MAAP/AFQ7/swAA/+ZTOP/mUzj/5lM4//3Rlf+zAAD//J9n/8AV\nDv/cPyv/swAA/9w/K//8w4P//J9n/7MAAP/8jVn//J9n/7MAAP/OKh3/7WZD/8AVDv/AFQ7/\n5lM4/+1mQ/+zAAD/swAA//yNWf/AFQ7//LF1//yNWf/90ZX/swAA/8AVDv+zAAD//LF1//yN\nWf+zAAD/swAA/+1mQ/+zAAD/ziod//yfZ/+zAAD//I1Z/9w/K//AFQ7//dGV/8AVDv+zAAD/\n5lM4/8AVDv+zAAD/swAA/8AVDv/mUzj/swAA/84qHf/8jVn//LF1/84qHf+zAAD/swAA//R5\nTv/AFQ7/swAA/7MAAP/90ZX/7WZD//3bq/+zAAD/7WZD/8AVDv/OKh3/5lM4//3Rlf/mUzj/\nwBUO/9w/K/+zAAD//MOD/8AVDv/cPyv/5lM4//zDg//8sXX//I1Z//yfZ//OKh3//dur/+ZT\nOP/mUzj/5lM4/7MAAP/AFQ7/wBUO//zDg//mUzj/7WZD/7MAAP/8w4P/ziod/+ZTOP/8sXX/\n/J9n//zDg/+zAAD//J9n//yfZ/+zAAD/swAA/7MAAP/OKh3/5lM4/7MAAP+zAAD/ziod/7MA\nAP/AFQ7//MOD/7MAAP+zAAD/3D8r//R5Tv+zAAD/5lM4/8AVDv+zAAD/wBUO//zDg//90ZX/\n/dGV/84qHf/tZkP/swAA//R5Tv+zAAD/swAA/7MAAP/8w4P//dur/+1mQ//90ZX//LF1/7MA\nAP/AFQ7/swAA/84qHf/OKh3//dGV/9w/K/+zAAD/wBUO//3Rlf+zAAD/swAA/7MAAP+zAAD/\n/LF1/+ZTOP+zAAD/swAA/7MAAP/8n2f/swAA/7MAAP/8jVn/5lM4//3Rlf+zAAD/swAA/7MA\nAP/8w4P/3D8r/7MAAP+zAAD/9HlO/7MAAP/90ZX/5lM4/8AVDv/8n2f/9HlO/8AVDv/AFQ7/\nwBUO//R5Tv/cPyv/swAA/84qHf/90ZX/5lM4/8AVDv/AFQ7/swAA/9w/K/+zAAD//LF1/8AV\nDv+zAAD/swAA/8AVDv+zAAD/wBUO/7MAAP/926v/9HlO/84qHf/8sXX//dGV//R5Tv+zAAD/\n7WZD/8AVDv+zAAD/swAA/7MAAP/cPyv/swAA//R5Tv/8w4P/swAA/7MAAP+zAAD/swAA/+1m\nQ/+zAAD/swAA/7MAAP/OKh3/9HlO/7MAAP/90ZX/swAA/7MAAP+zAAD/swAA//3bq//0eU7/\n7WZD/7MAAP+zAAD/swAA/2IQjEAYIbA/9iNFPQaBjUArpMA/DM21PT0Ki0AUy6E/D5yzPYcW\niUAOEKg/cM4IPcdLj0ACDs0/g/qWPfp+ij8Urvc/SDPWPYlBoD4VUkBArkfRPhNE3TyHFlFA\nFVcdPxsvnT81QdA/GXMXPirjLUA57jw/TtGRPKAyXj77BWFAL2lkPxKDQD6e72dA8iRJPm6G\nqz4ctjtAqmW7PhsvnT81QdA/GXMXPrByaD4LXmpAIk8SP4PAYkD2RaY/PfKHPYlBKEBrggA/\nPtDqPocWAUAxQiA/ByXMPT0KH0DXL8g+rReDPQAAAD4c001APlwKP4Xr0T4Le2RAnl65Pm8S\n8z85tEg/2gMtPRtMhz8j2/k/qmCUPeT3g0Atz7c/DJPpPTVeckApIls/mUe+Pd9PzT4GgQVA\nQpXaPcjvJ0CL4M8+F59CPjVeKkDP99M+/DVZPsoaF0B/pDA/chb2PAAAgD6QSUxA3c3jPgAA\nAAAIrExAVDqYPaabhD4DsmVA6WBVP1AZ7z6cxBhAVyYMPwRWjj/2KKw/P1KEPT1+/z78qRFA\nwXPvPvp+ij8Urvc/SDPWPX0/RUBqvHQ/7l/ZPY2Xrj77IkNADqGKPhNE3TyHFlFAFVcdP28q\n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"}]},"context":{"shiny":false,"rmarkdown":null},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, textureColor.a);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n#endif\n \n#endif\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<script type="application/htmlwidget-sizing" data-for="rgl91980">{"viewer":{"width":450,"height":350,"padding":15,"fill":true},"browser":{"width":960,"height":500,"padding":40,"fill":false}}</script>
</body>
</html>
