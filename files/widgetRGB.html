<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>rglWebGL</title>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      cel.style.position = "absolute";
      var pad = unpackPadding(sizing.padding);
      cel.style.top = pad.top + "px";
      cel.style.right = pad.right + "px";
      cel.style.bottom = pad.bottom + "px";
      cel.style.left = pad.left + "px";
      el.style.width = "100%";
      el.style.height = "100%";

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var rect = el.getBoundingClientRect();
            var result = bindingDef.initialize(el, rect.width, rect.height);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        var getSize = function(el) {
          if (sizeObj) {
            return {w: sizeObj.getWidth(), h: sizeObj.getHeight()}
          } else {
            var rect = el.getBoundingClientRect();
            return {w: rect.width, h: rect.height}
          }
        };

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          var size = getSize(el);
          initResult = binding.initialize(el, size.w, size.h);
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = getSize(el);
          var resizeHandler = function(e) {
            var size = getSize(el);
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();
</script>
<script>/* el is the div, holding the rgl object as el.rglinstance,
     which holds x as el.rglinstance.scene
   x is the JSON encoded rglwidget.
*/


HTMLWidgets.widget({

  name: 'rglWebGL',

  type: 'output',

  factory: function(el, width, height) {
    el.width = width;
    el.height = height;
    var rgl = new rglwidgetClass(),
        onchangeselection = function(e) {
          for (var i = 0; i < rgl.scene.crosstalk.sel_handle.length; i++)
            rgl.clearBrush(except = e.rglSubsceneId);
          rgl.selection(e, false);
        },
        onchangefilter = function(e) {
          rgl.selection(e, true);
        };
    
    return { 
      renderValue: function(x) {
        var i, pel, player, groups,
            inShiny = (typeof Shiny !== "undefined");
      
        x.crosstalk.group = groups = [].concat(x.crosstalk.group);
        x.crosstalk.id = [].concat(x.crosstalk.id);
        x.crosstalk.key = [].concat(x.crosstalk.key);
        x.crosstalk.sel_handle = new Array(groups.length);
        x.crosstalk.fil_handle = new Array(groups.length);
        x.crosstalk.selection = [];
        for (i = 0; i < groups.length; i++) {
          x.crosstalk.sel_handle[i] = new crosstalk.SelectionHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.sel_handle[i].on("change", onchangeselection);
          x.crosstalk.fil_handle[i] = new crosstalk.FilterHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.fil_handle[i].on("change", onchangefilter);
        }
        if (inShiny) {
          // Shiny calls this multiple times, so we need extra cleanup
          // between
          rgl.sphere = undefined;
        }
        rgl.initialize(el, x);
        rgl.initGL();
  
  /* We might have been called after (some of) the players were rendered.
     We need to make sure we respond to their initial values. */

        if (typeof x.players !== "undefined") {
          var players = [].concat(x.players);
          for (i = 0; i < players.length; i++) {
            pel = document.getElementById(players[i]);
            if (pel) {
              player = pel.rglPlayer;
              if (player && (!player.initialized || inShiny)) {
                rgl.Player(pel, player);
                player.initialized = true;
              }
            }
          }
        }
        rgl.drag = 0;
        rgl.drawScene();
      },

      resize: function(width, height) {
        el.width = width;
        el.height = height;
        el.rglinstance.resize(el);
        el.rglinstance.drawScene();
      }
    };
  }
});
</script>
<style type="text/css">.rglPlayer {
width: auto;
height: auto;
}
.rglPlayer .rgl-button {
width: auto;
display: inline-block;
font-size: 75%;
}
.rglPlayer .rgl-slider {
display: inline-block;
width: 30%;
}
.rglPlayer .rgl-label {
display: inline;
padding-left: 6px;
padding-right: 6px;
}
</style>
<script>//// To generate the help pages for this library, use

// jsdoc --template /usr/local/lib/node_modules/foodoc/template *.src.js -R README.md -c JSDoc.json

// To test, set environment variable RGL_DEBUGGING=true
// before building.

/* globals rglwidgetClass: true */

/**
 * The class of an rgl widget
 * @class
*/
rglwidgetClass = function() {
    this.canvas = null;
    this.userMatrix = new CanvasMatrix4();
    this.types = [];
    this.prMatrix = new CanvasMatrix4();
    this.mvMatrix = new CanvasMatrix4();
    this.vp = null;
    this.prmvMatrix = null;
    this.origs = null;
    this.gl = null;
    this.scene = null;
    this.select = {state: "inactive", subscene: null, region: {p1: {x:0, y:0}, p2: {x:0, y:0}}};
    this.drawing = false;
};

    rglwidgetClass.f_is_lit = 1;
    rglwidgetClass.f_is_smooth = 2;
    rglwidgetClass.f_has_texture = 4;
    rglwidgetClass.f_depth_sort = 8;
    rglwidgetClass.f_fixed_quads = 16;
    rglwidgetClass.f_is_transparent = 32;
    rglwidgetClass.f_is_lines = 64;
    rglwidgetClass.f_sprites_3d = 128;
    rglwidgetClass.f_is_subscene = 256;
    rglwidgetClass.f_is_clipplanes = 512;
    rglwidgetClass.f_fixed_size = 1024;
    rglwidgetClass.f_is_points = 2048;
    rglwidgetClass.f_is_twosided = 4096;
    rglwidgetClass.f_fat_lines = 8192;
    rglwidgetClass.f_is_brush = 16384;
    rglwidgetClass.f_has_fog = 32768;
    rglwidgetClass.f_rotating = 65536;
    
    rglwidgetClass.prototype.fogNone = 0;
    rglwidgetClass.prototype.fogLinear = 1;
    rglwidgetClass.prototype.fogExp = 2;
    rglwidgetClass.prototype.fogExp2 = 3;

    /**
     * Methods related to obsolete approaches.
     * @name ___OBSOLETE_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start the writeWebGL scene. This is only used by writeWebGL; rglwidget has
       no debug element.
     */
    rglwidgetClass.prototype.start = function() {
      if (typeof this.prefix !== "undefined") {
        this.debugelement = document.getElementById(this.prefix + "debug");
        this.debug("");
      }
      this.drag = 0;
      this.drawScene();
    };
</script>
<script>    /**
     * Utility methods
     * @name ___UTILITY_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Multiply matrix by vector
     * @returns {number[]}
     * @param M {number[][]} Left operand
     * @param v {number[]} Right operand
     */
    rglwidgetClass.multMV = function(M, v) {
        return [ M.m11 * v[0] + M.m12 * v[1] + M.m13 * v[2] + M.m14 * v[3],
                 M.m21 * v[0] + M.m22 * v[1] + M.m23 * v[2] + M.m24 * v[3],
                 M.m31 * v[0] + M.m32 * v[1] + M.m33 * v[2] + M.m34 * v[3],
                 M.m41 * v[0] + M.m42 * v[1] + M.m43 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Multiply row vector by Matrix
     * @returns {number[]}
     * @param v {number[]} left operand
     * @param M {number[][]} right operand
     */
    rglwidgetClass.multVM = function(v, M) {
        return [ M.m11 * v[0] + M.m21 * v[1] + M.m31 * v[2] + M.m41 * v[3],
                 M.m12 * v[0] + M.m22 * v[1] + M.m32 * v[2] + M.m42 * v[3],
                 M.m13 * v[0] + M.m23 * v[1] + M.m33 * v[2] + M.m43 * v[3],
                 M.m14 * v[0] + M.m24 * v[1] + M.m34 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Euclidean length of a vector
     * @returns {number}
     * @param v {number[]}
     */
    rglwidgetClass.vlen = function(v) {
      return Math.sqrt(rglwidgetClass.dotprod(v, v));
    };

    /**
     * Dot product of two vectors
     * @instance rglwidgetClass
     * @returns {number}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.dotprod = function(a, b) {
      return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    };

    /**
     * Cross product of two vectors
     * @returns {number[]}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.xprod = function(a, b) {
      return [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]];
    };

    /**
     * Bind vectors or matrices by columns
     * @returns {number[][]}
     * @param a {number[][]}
     * @param b {number[]|number[][]}
     */
    rglwidgetClass.cbind = function(a, b) {
      if (b.length < a.length)
        b = rglwidgetClass.repeatToLen(b, a.length);
      else if (a.length < b.length)
        a = rglwidgetClass.repeatToLen(a, b.length);
      return a.map(function(currentValue, index) {
            return [].concat(currentValue).concat(b[index]);
      });
    };

    /**
     * Swap elements
     * @returns {any[]}
     * @param a {any[]}
     * @param i {number} Element to swap
     * @param j {number} Other element to swap
     */
    rglwidgetClass.swap = function(a, i, j) {
      var temp = a[i];
      a[i] = a[j];
      a[j] = temp;
    };

    /**
     * Flatten a matrix into a vector
     * @returns {any[]}
     * @param a {any[][]}
     */
    rglwidgetClass.flatten = function(arr, result) {
      var value;
      if (typeof result === "undefined") result = [];
      for (var i = 0, length = arr.length; i < length; i++) {
        value = arr[i];
        if (Array.isArray(value)) {
          rglwidgetClass.flatten(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    };

    /**
     * set element of 1d or 2d array as if it was flattened.
     * Column major, zero based!
     * @returns {any[]|any[][]}
     * @param {any[]|any[][]} a - array
     * @param {number} i - element
     * @param {any} value
     */
    rglwidgetClass.prototype.setElement = function(a, i, value) {
      if (Array.isArray(a[0])) {
        var dim = a.length,
            col = Math.floor(i/dim),
            row = i % dim;
        a[row][col] = value;
      } else {
        a[i] = value;
      }
    };

    /**
     * Transpose an array
     * @returns {any[][]}
     * @param {any[][]} a
     */
    rglwidgetClass.prototype.transpose = function(a) {
      var newArray = [],
          n = a.length,
          m = a[0].length,
          i;
      for(i = 0; i < m; i++){
        newArray.push([]);
      }

      for(i = 0; i < n; i++){
        for(var j = 0; j < m; j++){
          newArray[j].push(a[i][j]);
        }
      }
      return newArray;
    };

    /**
     * Calculate sum of squares of a numeric vector
     * @returns {number}
     * @param {number[]} x
     */
    rglwidgetClass.prototype.sumsq = function(x) {
      var result = 0, i;
      for (i=0; i < x.length; i++)
        result += x[i]*x[i];
      return result;
    };

    /**
     * Convert a matrix to a CanvasMatrix4
     * @returns {CanvasMatrix4}
     * @param {number[][]|number[]} mat
     */
    rglwidgetClass.prototype.toCanvasMatrix4 = function(mat) {
      if (mat instanceof CanvasMatrix4)
        return mat;
      var result = new CanvasMatrix4();
      mat = rglwidgetClass.flatten(this.transpose(mat));
      result.load(mat);
      return result;
    };

    /**
     * Convert an R-style numeric colour string to an rgb vector
     * @returns {number[]}
     * @param {string} s
     */
    /* jshint bitwise:false */ 
    rglwidgetClass.prototype.stringToRgb = function(s) {
      s = s.replace("#", "");
      var bigint = parseInt(s, 16);
      return [((bigint >> 16) & 255)/255,
              ((bigint >> 8) & 255)/255,
               (bigint & 255)/255];
    };
    /* jshint bitwise:true */
    /**
     * Which list does a particular id come from?
     * @returns { string }
     * @param {number} id The id to look up.
     */
    rglwidgetClass.prototype.whichList = function(id) {
      var obj = this.getObj(id),
          flags = obj.flags;
        if (obj.type === "light")
          return "lights";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_subscene))
            return "subscenes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_clipplanes))
            return "clipplanes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent))
            return "transparent";
        return "opaque";
    };
    
    /**
     * Take a component-by-component product of two 3 vectors
     * @returns {number[]}
     * @param {number[]} x
     * @param {number[]} y
     */
    rglwidgetClass.prototype.componentProduct = function(x, y) {
      if (typeof y === "undefined") {
        this.alertOnce("Bad arg to componentProduct");
      }
      var result = new Float32Array(3), i;
      for (i = 0; i<3; i++)
        result[i] = x[i]*y[i];
      return result;
    };

    /**
     * Get next higher power of two
     * @returns { number }
     * @param { number } value - input value
     */
    rglwidgetClass.prototype.getPowerOfTwo = function(value) {
      var pow = 1;
      while(pow<value) {
        pow *= 2;
      }
      return pow;
    };

    /**
     * Unique entries
     * @returns { any[] }
     * @param { any[] } arr - An array
     */
    rglwidgetClass.prototype.unique = function(arr) {
      arr = [].concat(arr);
      return arr.filter(function(value, index, self) {
        return self.indexOf(value) === index;
      });
    };

    /**
     * Shallow compare of arrays
     * @returns { boolean }
     * @param { any[] } a - An array
     * @param { any[] } b - Another array
     */
    rglwidgetClass.prototype.equalArrays = function(a, b) {
      return a === b || (a && b &&
                      a.length === b.length &&
                      a.every(function(v, i) {return v === b[i];}));
    };
    
    /**
     * Repeat an array to a desired length
     * @returns {any[]}
     * @param {any | any[]} arr The input array
     * @param {number} len The desired output length
     */
    rglwidgetClass.repeatToLen = function(arr, len) {
      arr = [].concat(arr);
      if (!arr.length) 
        throw new RangeError("array is length 0");
      while (arr.length < len/2)
        arr = arr.concat(arr);
      return arr.concat(arr.slice(0, len - arr.length));
    };

    /**
     * Give a single alert message, not to be repeated.
     * @param {string} msg  The message to give.
     */
    rglwidgetClass.prototype.alertOnce = function(msg) {
      // debugger;
      if (typeof this.alerted !== "undefined")
        return;
      this.alerted = true;
      alert(msg);
    };

    /**
     * Get an object by id number.
     * @returns { Object }
     * @param {number} id
     */
    rglwidgetClass.prototype.getObj = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("getObj id is "+typeof id);
      }
      return this.scene.objects[id];
    };

    /**
     * Get ids of a particular type from a subscene or the whole scene
     * @returns { number[] }
     * @param {string} type What type of object?
     * @param {number} subscene  Which subscene?  If not given, find in the whole scene
     */
    rglwidgetClass.prototype.getIdsByType = function(type, subscene) {
      var
        result = [], i, self = this, ids;
      if (typeof subscene === "undefined") {
        Object.keys(this.scene.objects).forEach(
          function(key) {
            key = parseInt(key, 10);
            if (self.getObj(key).type === type)
              result.push(key);
          });
      } else {
        ids = this.getObj(subscene).objects;
        for (i=0; i < ids.length; i++) {
          if (this.getObj(ids[i]).type === type) {
            result.push(ids[i]);
          }
        }
      }
      return result;
    };

    /**
     * Get a particular material property for an obj
     * @returns { any }
     * @param {object} obj  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterial = function(obj, property) {
      var mat;
      if (typeof obj.material === "undefined")
        console.error("material undefined");
      mat = obj.material[property];
      if (typeof mat === "undefined")
          mat = this.scene.material[property];
      return mat;
    };
    
   /**
     * Get a particular material property for an id
     * @returns { any }
     * @param {number} id  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterialId = function(id, property) {
      var obj = this.getObj(id);
      return this.getMaterial(obj, property);
    };

    rglwidgetClass.prototype.getAdj = function (obj, index, offset, text) {
      var len, pos;
      if (typeof obj.pos === "undefined")
        return rglwidgetClass.flatten(obj.adj);
      pos = obj.pos[index % obj.pos.length];
      switch(pos) {
        case 0: return [0.5, 0.5, 0.5];
        case 1: return [0.5, 1 + offset, 0.5];
        case 3: return [0.5, -offset, 0.5];
        case 5: return [0.5, 0.5, -offset];
        case 6: return [0.5, 0.5, 1 + offset];
        case 2: 
        case 4: if (typeof text === "undefined")
                  len = 1;
                else
                  len = text.length;
                if (pos === 2)
                  return [1 + offset/len, 0.5, 0.5];
                else
                  return [-offset/len, 0.5, 0.5];
      }
    };

    /**
     * Count clipping planes in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplanes = function() {
      var self = this,
          bound = 0;
      
      Object.keys(this.scene.objects).forEach(
        function(key) {
          var obj = self.getObj(parseInt(key, 10));
          if (obj.type === "clipplanes")
            bound = bound + obj.offsets.length;
        });
      return bound;
    };

    /**
     * Count clipping plane objects in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplaneObjs = function() {
      return this.countObjs("clipplanes");
    };

    /**
     * Count lights in a scene
     * @returns { number }
     */
    rglwidgetClass.prototype.countLights = function() {
      return this.countObjs("light");
    };

    /**
     * Count objects of specific type in a scene
     * @returns { number }
     * @param { string } type - Type of object to count
     */
    rglwidgetClass.prototype.countObjs = function(type) {
      var self = this,
          bound = 0;

      Object.keys(this.scene.objects).forEach(
        function(key) {
          if (self.getObj(parseInt(key, 10)).type === type)
            bound = bound + 1;
        });
      return bound;
    };

    /**
     * Display a debug message
     * @param { string } msg - The message to display
     * @param { Object } [img] - Image to insert before message
     */
    rglwidgetClass.prototype.debug = function(msg, img) {
      if (typeof this.debugelement !== "undefined" && this.debugelement !== null) {
        this.debugelement.innerHTML = msg;
        if (typeof img !== "undefined") {
          this.debugelement.insertBefore(img, this.debugelement.firstChild);
        }
      } else if (msg !== "")
        alert(msg);
    };

    /**
     * If we are in an ioslides or slidy presentation, get the
     * DOM element of the current slide
     * @returns { Object }
     */
    rglwidgetClass.prototype.getSlide = function() {
      var result = this.el, done = false;
      while (result && !done && this.scene.context.rmarkdown) {
      	switch(this.scene.context.rmarkdown) {
          case "ioslides_presentation":
            if (result.tagName === "SLIDE") return result;
            break;
          case "slidy_presentation":
            if (result.tagName === "DIV" && result.classList.contains("slide"))
              return result;
            break;
          default: return null;
      	}
      	result = result.parentElement;
      }
      return null;
    };

    /**
     * Is this scene visible in the browser?
     * @returns { boolean }
     */
    rglwidgetClass.prototype.isInBrowserViewport = function() {
      var rect = this.canvas.getBoundingClientRect(),
          windHeight = (window.innerHeight || document.documentElement.clientHeight),
          windWidth = (window.innerWidth || document.documentElement.clientWidth);
      if (this.scene.context && this.scene.context.rmarkdown !== null) {
      	if (this.slide)
      	  return (this.scene.context.rmarkdown === "ioslides_presentation" &&
      	          this.slide.classList.contains("current")) ||
      	         (this.scene.context.rmarkdown === "slidy_presentation" &&
      	          !this.slide.classList.contains("hidden"));
      }
      return (
      	rect.top >= -windHeight &&
      	rect.left >= -windWidth &&
      	rect.bottom <= 2*windHeight &&
      	rect.right <= 2*windWidth);
    };
    
    rglwidgetClass.keydiff = function(obj1, obj2) {
      var keys = Object.keys(obj1), i, result = [];
      for (i=0;i<keys.length;i++) {
        if (typeof obj1[keys[i]] !== "undefined" &&
            typeof obj2[keys[i]] === "undefined")
          result.push(keys[i]);
      }
      return result;
    };

    rglwidgetClass.isSet = function(flags, flag) {
      /* jshint bitwise: false */
      return (flags & flag) !== 0;
      /* jshint bitwise: true */
    };
    
    rglwidgetClass.prototype.user2window = function(p, subid) {
      var m, v = [].concat(p);
      
      this.setmvMatrix(subid);
      m = new CanvasMatrix4(this.mvMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.setprMatrix(subid);
      m = new CanvasMatrix4(this.prMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.getViewport(subid);
      v[0] = v[0]*0.5/v[3] + 0.5 + this.vp.x/this.vp.width;
      v[1] = v[1]*0.5/v[3] + 0.5 + this.vp.y/this.vp.height;
      v[2] = (1 + v[2]/v[3])*0.5;
      return v.slice(0, 3);
    };

    /**
     * Andrew's convex hull algorithm. 
     * From Wikipedia, used under Creative Commons Attribution-ShareAlike License
     * @returns { Array } Indices of convex hull points
     */
    rglwidgetClass.chull = function(points) {
      function cross(a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
      }
        
      points.sort(function(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      });

      var lower = [], upper = [];
      for (var i = 0; i < points.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
          lower.pop();
        }
        lower.push(points[i]);
      }

      for (i = points.length - 1; i >= 0; i--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
          upper.pop();
        }
        upper.push(points[i]);
      }

      upper.pop();
      lower.pop();
      return lower.concat(upper);
    };
    
    /**
     * Round number to given precision
     * @param { number } x
     * @param { number } digits
     * @returns { number } 
     */
    rglwidgetClass.signif = function(x, digits) { 
      return parseFloat(x.toPrecision(digits));
    };
      
    /**
     * Check for NA, NaN, undefined, or null
     * @param x
     * @returns { bool }
     */
    rglwidgetClass.missing = function(x) {
      return x !== "-Inf" && x !== "Inf" &&
             (isNaN(x) || x === null || typeof(x) === "undefined");
    };

    /**
     * Write matrix to log
     * @param M
     */
    rglwidgetClass.logMatrix = function(M) {
      console.log("matrix(c("+M.m11+","+M.m12+","+M.m13+","+M.m14+",\n"+
                              M.m21+","+M.m22+","+M.m23+","+M.m24+",\n"+
                              M.m31+","+M.m32+","+M.m33+","+M.m34+",\n"+
                              M.m41+","+M.m42+","+M.m43+","+M.m44+"), byrow=TRUE, ncol=4)");
    };
    
    /**
     * Write vector to log
     * @param {vector} v
     */
     
    rglwidgetClass.logVec3 = function(v) {
      console.log("c("+v[0]+","+v[1]+","+v[2]+")");
    };
    
    /**
     * Sum two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vsum = function(x, y) {
       var i, result = [].concat(x);
       for (i = 0; i < y.length; i++)
         result[i] += y[i];
        return result;
     };
     
    /**
     * difference of two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vdiff = function(x, y) {
        return rglwidgetClass.vsum(x, rglwidgetClass.vscale(y, -1));
     };

    /**
     * Scale a vector
     * @param {number} s
     * @param {vector} x
     */
     rglwidgetClass.vscale = function(x, s) {
       var i, result = [].concat(x);
       for (i = 0; i < x.length; i++)
         result[i] *= s;
        return result;
     };
    
    /**
     * Normalize a vector
     * @param {vector} v
     */
    rglwidgetClass.normalize = function(v) {
      return rglwidgetClass.vscale(v, 1/rglwidgetClass.vlen(v));
    };
    
    /**
     * Compute the dimensions of a regular array
     * without checking that it is regular
     */ 
    rglwidgetClass.arrayDim = function(arr) {
      var result = [];
      while (typeof arr.length !== "undefined") {
        result = result.concat(arr.length);
        arr = arr[0];
      }
      return result;
    };
</script>
<script>/**
     * Methods related to buffered data
     * @name ___METHODS_FOR_BUFFERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Detect rglBuffered object
     * @param { Object } obj - vertices or similar 
     */
    rglwidgetClass.prototype.isBuffered = function(obj) {
      return typeof obj === "string";
    };

    /* The next two functions are taken from 
     
     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
     
     They were written by Mozilla Contributors and dedicated
     to the public domain under CC0. */
     
    /* Array of bytes to Base64 string decoding */
    rglwidgetClass.prototype.b64ToUint6 = function(nChr) {
      return nChr > 64 && nChr < 91 ? nChr - 65 : 
             nChr > 96 && nChr < 123 ? nChr - 71 : 
             nChr > 47 && nChr < 58 ? nChr + 4 : 
             nChr === 43 ? 62 : 
             nChr === 47 ? 63 : 
             0;
    };

    /* jshint bitwise:false */
    rglwidgetClass.prototype.base64DecToArr = function(sBase64, nBlocksSize) {
      var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""),
        nInLen = sB64Enc.length, 
        nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
        taBytes = new Uint8Array(nOutLen);
      for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
          for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
            taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
          }
          nUint24 = 0;
        }
      }
      return taBytes;
    };
    /* jshint bitwise:true */
    
    rglwidgetClass.prototype.getArrayBuffer = function(base64) {
      return this.base64DecToArr(base64, 4).buffer;
    };

    rglwidgetClass.prototype.getBufferedData = function(v) {
      return this.readAccessor(parseInt(v, 10), this.scene.buffer);
    };
    
    rglwidgetClass.prototype.readAccessor = function(acc, buf) {
      var typeSignedByte = 5120, 
          typeUnsignedByte = 5121, 
          typeSignedShort = 5122, 
          typeUnsignedShort = 5123, 
          typeSignedInt = 5124, 
          typeUnsignedInt = 5125, 
          typeFloat = 5126, 
          typeDouble = 5130, 
          accessor = buf.accessors[acc], 
          bufferView = buf.bufferViews[accessor.bufferView], 
          buffer = buf.buffers[bufferView.buffer], 
          bytes, 
          lens = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          }, 
          rowsizes = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 2,
            MAT3: 3,
            MAT4: 4
          }, 
          offset = 0, 
          len = lens[accessor.type], 
          rowsize = rowsizes[accessor.type], 
          count = len * accessor.count, 
          nrows = count / rowsize, 
          values, arr = [], row, i, j, k;
          
      if (typeof buffer.bytes === "string") 
        buffer.bytes = this.getArrayBuffer(buffer.bytes);
        
      bytes = buffer.bytes;
      
      if (typeof accessor.byteOffset !== "undefined") 
        offset += accessor.byteOffset;
        
      if (typeof bufferView.byteOffset !== "undefined") 
        offset += bufferView.byteOffset;
        
      switch (accessor.componentType) {
       case typeSignedByte:
        values = new Int8Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedByte:
        values = new Uint8Array(buffer.bytes, offset, count);
        break;

       case typeSignedShort:
        values = new Int16Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedShort:
        values = new Uint16Array(buffer.bytes, offset, count);
        break;

       case typeSignedInt:
        values = new Int32Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedInt:
        values = new Uint32Array(buffer.bytes, offset, count);
        break;

       case typeFloat:
        values = new Float32Array(buffer.bytes, offset, count);
        break;

       case typeDouble:
        values = new Float64Array(buffer.bytes, offset, count);
        break;
      }

      /* This is all very inefficient, but is convenient
             to work with the old code. */
      k = 0;
      for (i = 0; i < nrows; i++) {
        row = [];
        for (j = 0; j < rowsize; j++) {
          if (accessor.normalized) {
            switch(accessor.componentType) {
              case typeSignedByte:
                row.push(Math.max(values[k++]/127, -1.0));
                break;
              case typeSignedShort:
                row.push(Math.max(values[k++]/32767, -1.0));
                break;
              case typeUnsignedByte:
                row.push(values[k++]/255);
                break;
              case typeUnsignedShort:
                row.push(values[k++]/65535);
                break;
            }
          } else
            row.push(values[k++]);
        }
        arr.push(row);
      }
      return arr;
    };
    
    rglwidgetClass.prototype.expandBufferedFields = function(obj) {
      /* this list needs to match the one in convertScene.R */
      var fields = ["vertices", "normals", "indices", 
                    "texcoords", "colors", "centers"], i, field;
      for (i = 0; i < fields.length; i++) {
        field = obj[fields[i]];
        if (this.isBuffered(field))
          obj[fields[i]] = this.getBufferedData(field);
      }
    };
</script>
<script>    /**
     * Methods related to subscenes
     * @name ___METHODS_FOR_SUBSCENES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */

    /**
     * Is a particular id in a subscene?
     * @returns { boolean }
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.inSubscene = function(id, subscene) {
      return this.getObj(subscene).objects.indexOf(id) > -1;
    };

    /**
     * Translate from window coordinates to viewport coordinates
     * @returns { Object } translated coordinates
     * @param { number } subsceneid - which subscene to use?
     * @param { Object } coords - point to translate
     */
    rglwidgetClass.prototype.translateCoords = function(subsceneid, coords) {
      var viewport = this.getObj(subsceneid).par3d.viewport;
      return {x: coords.x - viewport.x*this.canvas.width,
              y: coords.y - viewport.y*this.canvas.height};
    };

    /**
     * Check whether point is in viewport of subscene
     * @returns {boolean}
     * @param { Object } coords - screen coordinates of point
     * @param { number } subsceneid - subscene to check
     */
    rglwidgetClass.prototype.inViewport = function(coords, subsceneid) {
      var viewport = this.getObj(subsceneid).par3d.viewport,
        x0 = coords.x - viewport.x*this.canvas.width,
        y0 = coords.y - viewport.y*this.canvas.height;
      return 0 <= x0 && x0 <= viewport.width*this.canvas.width &&
             0 <= y0 && y0 <= viewport.height*this.canvas.height;
    };

    /**
     * Find which subscene contains a point
     * @returns { number } subscene id
     * @param { Object } coords - coordinates of point
     */
    rglwidgetClass.prototype.whichSubscene = function(coords) {
      var self = this,
          recurse = function(subsceneid) {
            var subscenes = self.getChildSubscenes(subsceneid), i, id;
            for (i=0; i < subscenes.length; i++) {
              id = recurse(subscenes[i]);
              if (typeof(id) !== "undefined")
                return(id);
            }
            if (self.inViewport(coords, subsceneid))
              return(subsceneid);
            else
              return undefined;
          },
          rootid = this.scene.rootSubscene,
          result = recurse(rootid);
      if (typeof(result) === "undefined")
        result = rootid;
      return result;
    };

    /**
     * Add an id to a subscene.
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.addToSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          ids = [id],
          obj = this.getObj(id), i;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined") {
        ids = ids.concat(obj.newIds);
      }
      thesub.objects = [].concat(thesub.objects);
      for (i = 0; i < ids.length; i++) {
        id = ids[i];
        if (thesub.objects.indexOf(id) === -1) {
          thelist = this.whichList(id);
          thesub.objects.push(id);
          thesub[thelist].push(id);
        }
      }
    };

    /**
     * Delete an id from a subscene
     * @param { number } id - the id to add
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.delFromSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          obj = this.getObj(id),
          ids = [id], i, j;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined")
        ids = ids.concat(obj.newIds);
      thesub.objects = [].concat(thesub.objects); // It might be a scalar
      for (j=0; j<ids.length;j++) {
        id = ids[j];
        i = thesub.objects.indexOf(id);
        if (i > -1) {
          thesub.objects.splice(i, 1);
          thelist = this.whichList(id);
          i = thesub[thelist].indexOf(id);
          thesub[thelist].splice(i, 1);
        }
      }
    };

    /**
     * Set the ids in a subscene
     * @param { number[] } ids - the ids to set
     * @param { number } subsceneid - the id of the subscene
     */
    rglwidgetClass.prototype.setSubsceneEntries = function(ids, subsceneid) {
      var sub = this.getObj(subsceneid);
      sub.objects = ids;
      this.initSubscene(subsceneid);
    };

    /**
     * Get the ids in a subscene
     * @returns {number[]}
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getSubsceneEntries = function(subscene) {
      return this.getObj(subscene).objects;
    };

    /**
     * Get the ids of the subscenes within a subscene
     * @returns { number[] }
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getChildSubscenes = function(subscene) {
      return this.getObj(subscene).subscenes;
    };

    /**
     * Find a particular subscene by inheritance
     * @returns { number } id of subscene to use
     * @param { number } subsceneid - child subscene
     * @param { string } type - type of inheritance:  "projection" or "model"
     */
    rglwidgetClass.prototype.useid = function(subsceneid, type) {
      var sub = this.getObj(subsceneid);
      if (sub.embeddings[type] === "inherit")
        return(this.useid(sub.parent, type));
      else
        return subsceneid;
    };

    /**
     * Find bboxdeco for a subscene
     * @returns { number } id of bboxdeco, or undefined if none
     * @param { number } sub- subscene
     */
    rglwidgetClass.prototype.getBBoxDeco = function(sub) {
      var objects = sub.objects, i, obj;
      for (i = 0; i < objects.length; i++) {
        obj = this.getObj(objects[i]);
        if (obj.type === "bboxdeco")
          return obj;
      }
      if (sub.parent) 
        return this.getBBoxDeco(this.getObj(sub.parent));
      else
        return undefined;
    };
</script>
<script>    /**
     * Methods related to shaders
     * @name ___METHODS_FOR_SHADERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get flags that will end up as shader defines.
     * Static method so it can be called from R
     */
    rglwidgetClass.getDefFlags = function(flags, type, normals, round_points) {
      var f = {};
      f.fat_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_fat_lines);
      f.fixed_quads = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads);
      f.fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size);
      f.has_fog = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_fog);
      f.has_normals = (typeof normals !== "undefined") ||
                        type === "spheres";
      f.has_texture = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_texture);
      f.is_brush = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_brush);
      f.is_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lines);
      f.is_lit = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit);
      f.is_points = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_points);
      f.is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
      f.is_twosided = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_twosided);
      f.needs_vnormal = !rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d) &&
        (f.is_lit && !f.fixed_quads && !f.is_brush) || (f.is_twosided && f.has_normals);
      f.rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating);
      f.round_points = round_points;
      return f;
    };
     
    
    /**
     * Generate the defines for the shader code for an object.
     * 
     * This is a static method so it can be called from R.
     * 
     * @returns {string}
     * @param  id - id of object
     * @param  type - type of object
     * @param  flags - object flags
     * @param  nclipplanes - number of clipping planes in scene 
     *         (may not all be active)
     * @param  nlights - number of lights in scene (ditto)
     * @param  normals - normals for object
     * @param  pointSize - point size for object 
     * @param  textype - texture type for object 
     * @param  antialias - use antialiasing?
     */
    rglwidgetClass.getDefines = function(id, type, flags,
      nclipplanes, nlights, normals, pointSize, textype,
      texmode, texenvmap, antialias, fl) {
      var
        title, defines;
      
      if (typeof fl === "undefined")
        fl = rglwidgetClass.getDefFlags(flags, type, normals, antialias);
        
      title = "  /* ****** "+type+" object "+id+" shader ****** */\n";
      
      defines = "#define NCLIPPLANES " + nclipplanes + "\n"+
                "#define NLIGHTS " + nlights + "\n";
      
      if (fl.fat_lines)
        defines = defines + "#define FAT_LINES 1\n";
      
      if (fl.fixed_quads)
        defines = defines + "#define FIXED_QUADS 1\n";

      if (fl.fixed_size)
        defines = defines + "#define FIXED_SIZE 1\n";

      if (fl.has_fog)
        defines = defines + "#define HAS_FOG 1\n";
        
      if (fl.has_normals)
        defines = defines + "#define HAS_NORMALS 1\n";
        
      if (fl.has_texture) {
        defines = defines + "#define HAS_TEXTURE 1\n";
        defines = defines + "#define TEXTURE_" + textype + "\n";
        defines = defines + "#define TEXMODE_" + texmode + "\n";
        if (texenvmap)
          defines = defines + "#define USE_ENVMAP 1\n";
      }
      
      if (fl.is_brush)
        defines = defines + "#define IS_BRUSH 1\n";  

      if (type === "linestrip")
        defines = defines + "#define IS_LINESTRIP 1\n";         

      if (fl.is_lit)
        defines = defines + "#define IS_LIT 1\n"; 
      
      if (fl.is_points) {
        defines = defines + "#define IS_POINTS 1\n";
        defines = defines + "#define POINTSIZE " + Number.parseFloat(pointSize).toFixed(1) + "\n";
      }
        
      if (type === "sprites")
        defines = defines + "#define IS_SPRITES 1\n";
        
      if (type === "text")
        defines = defines + "#define IS_TEXT 1\n";

      if (fl.is_transparent)
        defines = defines + "#define IS_TRANSPARENT 1\n"; 
        
      if (fl.is_twosided)
        defines = defines + "#define IS_TWOSIDED 1\n";
        
      if (fl.needs_vnormal)
        defines = defines + "#define NEEDS_VNORMAL 1\n";

      if (fl.rotating)
        defines = defines + "#define ROTATING 1\n";
        
      if (fl.round_points)        
        defines = defines + "#define ROUND_POINTS 1\n";   

      // console.log(result);
      return title + defines;
    };

    /**
     * Create code for vertex and fragment shaders
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShaders = function(obj) {
      var header, 
        vertex = obj.userVertexShader, 
        fragment = obj.userFragmentShader;
      
      header = rglwidgetClass.getDefines(
        obj.id, obj.type, obj.flags, 
        this.countClipplanes(), this.countLights(), 
        obj.normals, 
        this.getMaterial(obj, "size"), 
        this.getMaterial(obj, "textype"),
        this.getMaterial(obj, "texmode"),
        this.getMaterial(obj, "texenvmap"),
        this.getMaterial(obj, "point_antialias"),
        obj.defFlags
      );

      if (typeof vertex === "undefined")
        vertex = rglwidgetClass.rgl_vertex_shader();
        
      if (typeof fragment === "undefined") 
        fragment = rglwidgetClass.rgl_fragment_shader();

//      console.log("vertex:");
//      console.log(header + vertex);
//      console.log("fragment:");
//      console.log(header + fragment);
      
      return {vertex: header + vertex,
              fragment: header + fragment};
    };
    
    
    /**
     * Call gl functions to create and compile shader from code
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShader = function(shaderType, code) {
        var gl = this.gl, shader;
        shader = gl.createShader(shaderType);
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost())
            alert(gl.getShaderInfoLog(shader));
        return shader;
    };

</script>
<script>rglwidgetClass.rgl_vertex_shader = function() {
return  "#line 2 1\n"+
"// File 1 is the vertex shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"\n"+
"attribute vec3 aPos;\n"+
"attribute vec4 aCol;\n"+
"uniform mat4 mvMatrix;\n"+
"uniform mat4 prMatrix;\n"+
"varying vec4 vCol;\n"+
"varying vec4 vPosition;\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"attribute vec3 aNorm;\n"+
"uniform mat4 normMatrix;\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"attribute vec2 aTexcoord;\n"+
"varying vec2 vTexcoord;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_SIZE\n"+
"uniform vec3 textScale;\n"+
"#endif\n"+
"\n"+
"#ifdef FIXED_QUADS\n"+
"attribute vec3 aOfs;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"varying float normz;\n"+
"uniform mat4 invPrMatrix;\n"+
"#else\n"+
"attribute vec3 aPos1;\n"+
"attribute vec3 aPos2;\n"+
"varying float normz;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"attribute vec3 aNext;\n"+
"attribute vec2 aPoint;\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"uniform float uAspect;\n"+
"uniform float uLwd;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  \n"+
"#ifndef IS_BRUSH\n"+
"#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n"+
"  vPosition = mvMatrix * vec4(aPos, 1.);\n"+
"#endif\n"+
"  \n"+
"#ifndef FIXED_QUADS\n"+
"  gl_Position = prMatrix * vPosition;\n"+
"#endif\n"+
"#endif // !IS_BRUSH\n"+
"  \n"+
"#ifdef IS_POINTS\n"+
"  gl_PointSize = POINTSIZE;\n"+
"#endif\n"+
"  \n"+
"  vCol = aCol;\n"+
"  \n"+
"// USE_ENVMAP implies NEEDS_VNORMAL\n"+
"\n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n"+
"                        normalize(vNormal.xyz/vNormal.w)));\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_TWOSIDED\n"+
"#ifdef HAS_NORMALS\n"+
"  /* normz should be calculated *after* projection */\n"+
"  normz = (invPrMatrix*vNormal).z;\n"+
"#else\n"+
"  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n"+
"  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n"+
"  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n"+
"  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n"+
"  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n"+
"#endif\n"+
"#endif // IS_TWOSIDED\n"+
"  \n"+
"#ifdef NEEDS_VNORMAL\n"+
"  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n"+
"#endif\n"+
"  \n"+
"#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n"+
"  vTexcoord = aTexcoord;\n"+
"#endif\n"+
"  \n"+
"#if defined(FIXED_SIZE) && !defined(ROTATING)\n"+
"  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w;\n"+
"  gl_Position = pos + vec4(aOfs*textScale, 0.);\n"+
"#endif\n"+
"  \n"+
"#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n"+
"  vec4 pos = mvMatrix * vec4(aPos, 1.);\n"+
"  pos = pos/pos.w + vec4(aOfs,  0.);\n"+
"  gl_Position = prMatrix*pos;\n"+
"#endif\n"+
"  \n"+
"#ifdef FAT_LINES\n"+
"  /* This code was inspired by Matt Deslauriers' code in \n"+
"   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n"+
"  vec2 aspectVec = vec2(uAspect, 1.0);\n"+
"  mat4 projViewModel = prMatrix * mvMatrix;\n"+
"  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n"+
"  currentProjected = currentProjected/currentProjected.w;\n"+
"  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n"+
"  vec2 currentScreen = currentProjected.xy * aspectVec;\n"+
"  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n"+
"  float len = uLwd;\n"+
"  vec2 dir = vec2(1.0, 0.0);\n"+
"  vPoint = aPoint;\n"+
"  vLength = length(nextScreen - currentScreen)/2.0;\n"+
"  vLength = vLength/(vLength + len);\n"+
"  if (vLength > 0.0) {\n"+
"    dir = normalize(nextScreen - currentScreen);\n"+
"  }\n"+
"  vec2 normal = vec2(-dir.y, dir.x);\n"+
"  dir.x /= uAspect;\n"+
"  normal.x /= uAspect;\n"+
"  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n"+
"  gl_Position = currentProjected + offset;\n"+
"#endif\n"+
"  \n"+
"#ifdef IS_BRUSH\n"+
"  gl_Position = vec4(aPos, 1.);\n"+
"#endif\n"+
"}\n" ;};
rglwidgetClass.rgl_fragment_shader = function() {
return  "#line 2 2\n"+
"// File 2 is the fragment shader\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"precision highp float;\n"+
"#else\n"+
"precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"varying vec4 vCol; // carries alpha\n"+
"varying vec4 vPosition;\n"+
"#if defined(HAS_TEXTURE) || defined (IS_TEXT)\n"+
"varying vec2 vTexcoord;\n"+
"uniform sampler2D uSampler;\n"+
"#endif\n"+
"\n"+
"#ifdef HAS_FOG\n"+
"uniform int uFogMode;\n"+
"uniform vec3 uFogColor;\n"+
"uniform vec4 uFogParms;\n"+
"#endif\n"+
"\n"+
"#if defined(IS_LIT) && !defined(FIXED_QUADS)\n"+
"varying vec4 vNormal;\n"+
"#endif\n"+
"\n"+
"#if NCLIPPLANES > 0\n"+
"uniform vec4 vClipplane[NCLIPPLANES];\n"+
"#endif\n"+
"\n"+
"#if NLIGHTS > 0\n"+
"uniform mat4 mvMatrix;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"uniform vec3 emission;\n"+
"uniform float shininess;\n"+
"#if NLIGHTS > 0\n"+
"uniform vec3 ambient[NLIGHTS];\n"+
"uniform vec3 specular[NLIGHTS]; // light*material\n"+
"uniform vec3 diffuse[NLIGHTS];\n"+
"uniform vec3 lightDir[NLIGHTS];\n"+
"uniform bool viewpoint[NLIGHTS];\n"+
"uniform bool finite[NLIGHTS];\n"+
"#endif\n"+
"#endif // IS_LIT\n"+
"\n"+
"#ifdef IS_TWOSIDED\n"+
"uniform bool front;\n"+
"varying float normz;\n"+
"#endif\n"+
"\n"+
"#ifdef FAT_LINES\n"+
"varying vec2 vPoint;\n"+
"varying float vLength;\n"+
"#endif\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"varying vec3 vReflection;\n"+
"#endif\n"+
"\n"+
"void main(void) {\n"+
"  vec4 fragColor;\n"+
"#ifdef FAT_LINES\n"+
"  vec2 point = vPoint;\n"+
"  bool neg = point.y < 0.0;\n"+
"  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n"+
"                 -(point.y - vLength)/(1.0 - vLength);\n"+
"#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n"+
"  if (neg && length(point) <= 1.0) discard;\n"+
"#endif\n"+
"  point.y = min(point.y, 0.0);\n"+
"  if (length(point) > 1.0) discard;\n"+
"#endif // FAT_LINES\n"+
"  \n"+
"#ifdef ROUND_POINTS\n"+
"  vec2 coord = gl_PointCoord - vec2(0.5);\n"+
"  if (length(coord) > 0.5) discard;\n"+
"#endif\n"+
"  \n"+
"#if NCLIPPLANES > 0\n"+
"  for (int i = 0; i < NCLIPPLANES; i++)\n"+
"    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n"+
"#endif\n"+
"    \n"+
"#ifdef FIXED_QUADS\n"+
"    vec3 n = vec3(0., 0., 1.);\n"+
"#elif defined(IS_LIT)\n"+
"    vec3 n = normalize(vNormal.xyz);\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TWOSIDED\n"+
"    if ((normz <= 0.) != front) discard;\n"+
"#endif\n"+
"\n"+
"#ifdef IS_LIT\n"+
"    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n"+
"    vec3 lightdir;\n"+
"    vec4 colDiff;\n"+
"    vec3 halfVec;\n"+
"    vec4 lighteffect = vec4(emission, 0.);\n"+
"    vec3 col;\n"+
"    float nDotL;\n"+
"#ifdef FIXED_QUADS\n"+
"    n = -faceforward(n, n, eye);\n"+
"#endif\n"+
"    \n"+
"#if NLIGHTS > 0\n"+
"    for (int i=0;i<NLIGHTS;i++) {\n"+
"      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n"+
"      lightdir = lightDir[i];\n"+
"      if (!viewpoint[i])\n"+
"        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n"+
"      if (!finite[i]) {\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      } else {\n"+
"        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n"+
"        halfVec = normalize(lightdir + eye);\n"+
"      }\n"+
"      col = ambient[i];\n"+
"      nDotL = dot(n, lightdir);\n"+
"      col = col + max(nDotL, 0.) * colDiff.rgb;\n"+
"      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n"+
"      lighteffect = lighteffect + vec4(col, colDiff.a);\n"+
"    }\n"+
"#endif\n"+
"    \n"+
"#else // not IS_LIT\n"+
"    vec4 colDiff = vCol;\n"+
"    vec4 lighteffect = colDiff;\n"+
"#endif\n"+
"    \n"+
"#ifdef IS_TEXT\n"+
"    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"    \n"+
"#ifdef HAS_TEXTURE\n"+
"\n"+
"// These calculations use the definitions from \n"+
"// https://docs.gl/gl3/glTexEnv\n"+
"\n"+
"#ifdef USE_ENVMAP\n"+
"    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n"+
"    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n"+
"#else\n"+
"    vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXTURE_rgb\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(textureColor.rgb, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif //TEXTURE_rgb\n"+
"        \n"+
"#ifdef TEXTURE_rgba\n"+
"\n"+
"#ifdef TEXMODE_replace\n"+
"// already done\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = lighteffect*textureColor;\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_decal\n"+
"    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n"+
"                     textureColor.a*textureColor.rgb, \n"+
"                     lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n"+
"                    lighteffect.a*textureColor.a);\n"+
"#endif\n"+
"    \n"+
"#endif //TEXTURE_rgba\n"+
"    \n"+
"#ifdef TEXTURE_alpha\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(lighteffect.rgb, textureColor.a);\n"+
"#endif \n"+
"\n"+
"#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n"+
"    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n"+
"#endif\n"+
" \n"+
"#endif\n"+
"    \n"+
"// The TEXTURE_luminance values are not from that reference    \n"+
"#ifdef TEXTURE_luminance\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance\n"+
" \n"+
"    \n"+
"#ifdef TEXTURE_luminance_alpha\n"+
"    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"\n"+
"#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n"+
"    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n"+
"#endif \n"+
"\n"+
"#ifdef TEXMODE_modulate\n"+
"    textureColor = vec4(luminance*lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_blend\n"+
"    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n"+
"                        textureColor.a*lighteffect.a);\n"+
"#endif\n"+
"\n"+
"#ifdef TEXMODE_add\n"+
"    textureColor = vec4(luminance + lighteffect.rgb, \n"+
"                        textureColor.a*lighteffect.a);\n"+
"\n"+
"#endif\n"+
"\n"+
"#endif // TEXTURE_luminance_alpha\n"+
"    \n"+
"    fragColor = textureColor;\n"+
"\n"+
"#elif defined(IS_TEXT)\n"+
"    if (textureColor.a < 0.1)\n"+
"      discard;\n"+
"    else\n"+
"      fragColor = textureColor;\n"+
"#else\n"+
"    fragColor = lighteffect;\n"+
"#endif // HAS_TEXTURE\n"+
"    \n"+
"#ifdef HAS_FOG\n"+
"    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n"+
"    // In Exp and Exp2: use density = density/far\n"+
"    // fogF will be the proportion of fog\n"+
"    // Initialize it to the linear value\n"+
"    float fogF;\n"+
"    if (uFogMode > 0) {\n"+
"      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n"+
"      if (uFogMode > 1)\n"+
"        fogF = mix(uFogParms.w, 1.0, fogF);\n"+
"      fogF = fogF*uFogParms.z;\n"+
"      if (uFogMode == 2)\n"+
"        fogF = 1.0 - exp(-fogF);\n"+
"      // Docs are wrong: use (density*c)^2, not density*c^2\n"+
"      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n"+
"      else if (uFogMode == 3)\n"+
"        fogF = 1.0 - exp(-fogF*fogF);\n"+
"      fogF = clamp(fogF, 0.0, 1.0);\n"+
"      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n"+
"    } else gl_FragColor = fragColor;\n"+
"#else\n"+
"    gl_FragColor = fragColor;\n"+
"#endif // HAS_FOG\n"+
"    \n"+
"}\n" ;};
</script>
<script>    /**
     * Methods related to textures
     * @name ___METHODS_FOR_TEXTURES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getTexFilter = function(filter) {
      var gl = this.gl || this.initGL();
      switch(filter) {
        case "nearest": return gl.NEAREST;
        case "linear": return gl.LINEAR;
        case "nearest.mipmap.nearest": return gl.NEAREST_MIPMAP_NEAREST;
        case "linear.mipmap.nearest": return gl.LINEAR_MIPMAP_NEAREST;
        case "nearest.mipmap.linear": return gl.NEAREST_MIPMAP_LINEAR;
        case "linear.mipmap.linear": return gl.LINEAR_MIPMAP_LINEAR;
        default: console.error("Unknown filter: "+filter);
      }
    };
     
    /**
     * Handle a texture after its image has been loaded
     * @param { Object } texture - the gl texture object
     * @param { Object } textureCanvas - the canvas holding the image
     */
    rglwidgetClass.prototype.handleLoadedTexture = function(texture, textureCanvas) {
      var gl = this.gl || this.initGL();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);

      gl.bindTexture(gl.TEXTURE_2D, null);
    };

    /**
     * Get maximum dimension of texture in current browser.
     * @returns {number}
     */
    rglwidgetClass.prototype.getMaxTexSize = function() {
      var gl = this.gl || this.initGL();	
      return Math.min(4096, gl.getParameter(gl.MAX_TEXTURE_SIZE));
    };
    
    /**
     * Load an image to a texture
     * @param { string } uri - The image location
     * @param { Object } texture - the gl texture object
     */
    rglwidgetClass.prototype.loadImageToTexture = function(uri, texture) {
      var canvas = this.textureCanvas,
          ctx = canvas.getContext("2d"),
          image = new Image(),
          self = this;

       image.onload = function() {

         var w = image.width,
             h = image.height,
             canvasX = self.getPowerOfTwo(w),
             canvasY = self.getPowerOfTwo(h),
             maxTexSize = self.getMaxTexSize();
         while (canvasX > 1 && canvasY > 1 && (canvasX > maxTexSize || canvasY > maxTexSize)) {
           canvasX /= 2;
           canvasY /= 2;
         }
         canvas.width = canvasX;
         canvas.height = canvasY;
         ctx.imageSmoothingEnabled = true;
         ctx.drawImage(image, 0, 0, canvasX, canvasY);
         self.handleLoadedTexture(texture, canvas);
         self.texturesLoading -= 1;
         if (!self.texturesLoading)
           self.drawScene();
       };
       if (!self.texturesLoading)
         self.texturesLoading = 0; // may have been undefined
       self.texturesLoading += 1;
       image.src = uri;
     };

    /**
     * Draw text to the texture canvas
     * @returns { Object } object with text measurements
     * @param { string } text - the text
     * @param { number } cex - expansion
     * @param { string } family - font family
     * @param { number } font - font number
     */
    rglwidgetClass.prototype.drawTextToCanvas = function(text, cex, family, font) {
       var canvasX, canvasY,
           scaling = 20,
           textColour = "white",

           backgroundColour = "rgba(0,0,0,0)",
           canvas = this.textureCanvas,
           ctx = canvas.getContext("2d"),
           i, textHeight = 0, textHeights = [], width, widths = [], 
           offsetx, offsety = 0, line, lines = [], offsetsx = [],
           offsetsy = [], lineoffsetsy = [], fontStrings = [],
           maxTexSize = this.getMaxTexSize(),
           getFontString = function(i) {
             textHeights[i] = scaling*cex[i];
             var fontString = textHeights[i] + "px",
                 family0 = family[i],
                 font0 = font[i];
             if (family0 === "sans")
               family0 = "sans-serif";
             else if (family0 === "mono")
               family0 = "monospace";
             fontString = fontString + " " + family0;
             if (font0 === 2 || font0 === 4)
               fontString = "bold " + fontString;
             if (font0 === 3 || font0 === 4)
               fontString = "italic " + fontString;
             return fontString;
           };
       cex = rglwidgetClass.repeatToLen(cex, text.length);
       family = rglwidgetClass.repeatToLen(family, text.length);
       font = rglwidgetClass.repeatToLen(font, text.length);

       canvasX = 1;
       line = -1;
       offsetx = maxTexSize;
       for (i = 0; i < text.length; i++)  {
         ctx.font = fontStrings[i] = getFontString(i);
         width = widths[i] = ctx.measureText(text[i]).width;
         if (offsetx + width > maxTexSize) {
           offsety = offsety + 2*textHeight;
           if (line >= 0)
             lineoffsetsy[line] = offsety;
           line += 1;
           if (offsety > maxTexSize)
             console.error("Too many strings for texture.");
           textHeight = 0;
           offsetx = 0;
         }
         textHeight = Math.max(textHeight, textHeights[i]);
         offsetsx[i] = offsetx;
         offsetx += width;
         canvasX = Math.max(canvasX, offsetx);
         lines[i] = line;
       }
       offsety = lineoffsetsy[line] = offsety + 2*textHeight;
       for (i = 0; i < text.length; i++) {
       	 offsetsy[i] = lineoffsetsy[lines[i]];
       }
       
       canvasX = this.getPowerOfTwo(canvasX);
       canvasY = this.getPowerOfTwo(offsety);

       canvas.width = canvasX;
       canvas.height = canvasY;

       ctx.fillStyle = backgroundColour;
       ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

       ctx.textBaseline = "alphabetic";
       for(i = 0; i < text.length; i++) {
         ctx.font = fontStrings[i];
         ctx.fillStyle = textColour;
         ctx.textAlign = "left";
         ctx.fillText(text[i], offsetsx[i],  offsetsy[i]);
       }
       return {canvasX:canvasX, canvasY:canvasY,
               widths:widths, textHeights:textHeights,
               offsetsx:offsetsx, offsetsy:offsetsy};
     };

</script>
<script>    /**
     * Methods related to projections
     * @name ___METHODS_FOR_PROJECTIONS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get the viewport
     */
     
    rglwidgetClass.prototype.getViewport = function(id) {
      var vp = this.getObj(id).par3d.viewport,
         x = vp.x*this.canvas.width,
         y = vp.y*this.canvas.height,
         width = vp.width*this.canvas.width,
         height = vp.height*this.canvas.height;
       this.vp = {x:x, y:y, width:width, height:height};
    };
    
    /**
     * Set the gl viewport and scissor test
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setViewport = function(id) {
       var gl = this.gl || this.initGL();
       this.getViewport(id);
       gl.viewport(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.scissor(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.enable(gl.SCISSOR_TEST);
     };

    /**
     * Set the projection matrix for a subscene
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setprMatrix = function(id) {
       var subscene = this.getObj(id),
          embedding = subscene.embeddings.projection;
       if (embedding === "replace")
         this.prMatrix.makeIdentity();
       else
         this.setprMatrix(subscene.parent);
       if (embedding === "inherit")
         return;
       // This is based on the Frustum::enclose code from geom.cpp
       var bbox = subscene.par3d.bbox,
           scale = subscene.par3d.scale,
           ranges = [(bbox[1]-bbox[0])*scale[0]/2,
                     (bbox[3]-bbox[2])*scale[1]/2,
                     (bbox[5]-bbox[4])*scale[2]/2],
           radius = Math.sqrt(this.sumsq(ranges))*1.1; // A bit bigger to handle labels
       if (radius <= 0) radius = 1;
       var observer = subscene.par3d.observer,
           distance = observer[2],
           FOV = subscene.par3d.FOV, ortho = FOV === 0,
           t = ortho ? 1 : Math.tan(FOV*Math.PI/360),
           near = distance - radius,
           far = distance + radius,
           hlen,
           aspect = this.vp.width/this.vp.height,
           z = subscene.par3d.zoom,
           userProjection = subscene.par3d.userProjection;
       if (far < 0.0)
         far = 1.0;
       if (near < far/100.0)
         near = far/100.0;
       this.frustum = {near:near, far:far};
       hlen = t*near;
       if (ortho) {
         if (aspect > 1)
           this.prMatrix.ortho(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.ortho(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       } else {
         if (aspect > 1)
           this.prMatrix.frustum(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.frustum(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       }
       this.prMatrix.multRight(userProjection);
     };

    /**
     * Set the model-view matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmvMatrix = function(id) {
       var observer = this.getObj(id).par3d.observer;
       this.mvMatrix.makeIdentity();
       this.setmodelMatrix(id);
       this.mvMatrix.translate(-observer[0], -observer[1], -observer[2]);

     };

    /**
     * Set the model matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmodelMatrix = function(id) {
      var subscene = this.getObj(id),
          embedding = subscene.embeddings.model;
      if (embedding === "replace") {
        var bbox = subscene.par3d.bbox,
            center = [(bbox[0]+bbox[1])/2,
                      (bbox[2]+bbox[3])/2,
                      (bbox[4]+bbox[5])/2];
        this.mvMatrix.translate(-center[0], -center[1], -center[2]);
      }
      if (embedding !== "inherit") {
        var scale = subscene.par3d.scale;
        this.mvMatrix.scale(scale[0], scale[1], scale[2]);
        this.mvMatrix.multRight( subscene.par3d.userMatrix );
      }
      if (embedding !== "replace")
        this.setmodelMatrix(subscene.parent);
     };

    /**
     * Set the normals matrix for a subscene
     * @param { number } subsceneid - id of the subscene
     */
     rglwidgetClass.prototype.setnormMatrix2 = function() {
       this.normMatrix = new CanvasMatrix4(this.mvMatrix);
       this.normMatrix.invert();
       this.normMatrix.transpose();
     };

    /**
     * Set the combined projection-model-view matrix
     */
    rglwidgetClass.prototype.setprmvMatrix = function() {
       this.prmvMatrix = new CanvasMatrix4( this.mvMatrix );
       this.prmvMatrix.multRight( this.prMatrix );
     };

    rglwidgetClass.prototype.setInvPrMatrix = function() {
      this.invPrMatrix = new CanvasMatrix4( this.prMatrix );
      this.invPrMatrix.invert();
      this.invPrMatrix.transpose();
    };
</script>
<script>    /**
     * Methods related to mouse handling
     * @name ___METHODS_FOR_MOUSE_HANDLING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getCursor = function(mode) {
      switch(mode) {
        case "none": 
          return "none";
        case "trackball":
        case "xAxis":
        case "yAxis":
        case "zAxis":
        case "polar":
          return "grab";
        case "selecting":
          return "crosshair";
        case "fov":
        case "zoom":
          return "zoom-in";
        case "user":
          return "default";
      }
      return "dragging";
    };
    
    /**
     * Set mouse mode for a subscene
     * @param { string } mode - name of mode
     * @param { number } button - button number (0 to 4)
     * @param { number } subscene - subscene id number
     * @param { number } stayActive - if truthy, don't clear brush
     */
    rglwidgetClass.prototype.setMouseMode = function(mode, button, subscene, stayActive) {
      var sub = this.getObj(subscene),
          which = ["none", "left", "right", "middle", "wheel"][button];
      if (!stayActive && sub.par3d.mouseMode[which] === "selecting")
        this.clearBrush(null);
      sub.par3d.mouseMode[which] = mode;
      if (button === 1 || (button === 0 && mode !== "none"))
        this.canvas.style.cursor = this.getCursor(mode);
      if (button === 0 && mode !== "none")
        sub.needsBegin = mode;
    };

    /**
     * Compute mouse coordinates relative to current canvas
     * @returns { Object }
     * @param { Object } event - event object from mouse click
     */
    rglwidgetClass.prototype.relMouseCoords = function(event) {
      var rect = this.canvas.getBoundingClientRect();
      return {x:event.clientX-rect.left, y:event.clientY-rect.top};
    };
    
    /**
     * Send mouse selection to Shiny
     */
    rglwidgetClass.prototype.recordSelection = function(subid) {
      var result = {};
      if (typeof this.select !== "undefined" && 
          typeof this.select.state !== "undefined" &&
          this.select.state !== "inactive") {
        result = { subscene: subid,
                   state: this.select.state,
                   region: this.select.region
                 };
        this.setmvMatrix(subid);
        result.model = this.mvMatrix;
        this.setprMatrix(subid);
        result.proj = this.prMatrix;
        this.getViewport(subid);
        result.view = this.vp;
      } else
        result.state = "inactive";
      Shiny.setInputValue(this.scene.selectionInput + ":shinyMouse3d", result);
    }; 

    /**
     * Set mouse handlers for the scene
     */
    rglwidgetClass.prototype.setMouseHandlers = function() {
      var self = this, activeSubscene, handler,
          handlers = {}, drag = 0;

      handlers.rotBase = 0;

      self.screenToVector = function(x, y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
          radius = Math.max(width, height)/2.0,
          cx = width/2.0,
          cy = height/2.0,
          px = (x-cx)/radius,
          py = (y-cy)/radius,
          plen = Math.sqrt(px*px+py*py);
        if (plen > 1.e-6) {
          px = px/plen;
          py = py/plen;
        }
        var angle = (Math.SQRT2 - plen)/Math.SQRT2*Math.PI/2,
          z = Math.sin(angle),
          zlen = Math.sqrt(1.0 - z*z);
        px = px * zlen;
        py = py * zlen;
        return [px, py, z];
      };

      handlers.trackballdown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.rotBase = self.screenToVector(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.trackballmove = function(x,y) {
        var rotCurrent = self.screenToVector(x,y),
            rotBase = handlers.rotBase,
            dot = rotBase[0]*rotCurrent[0] +
                  rotBase[1]*rotCurrent[1] +
                  rotBase[2]*rotCurrent[2],
            angle = Math.acos( dot/rglwidgetClass.vlen(rotBase)/rglwidgetClass.vlen(rotCurrent) )*180.0/Math.PI,
            axis = rglwidgetClass.xprod(rotBase, rotCurrent),
            objects = self.scene.objects,
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            l = activeModel.par3d.listeners,
            i;
        if (angle === 0.0)
          return;    
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(angle, axis[0], axis[1], axis[2]);
        }
        self.drawScene();
      };
      handlers.trackballend = 0;

      self.clamp = function(x, lo, hi) {
      	return Math.max(lo, Math.min(x, hi));
      };

      self.screenToPolar = function(x,y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
    	  r = Math.min(width, height)/2,
    	  dx = self.clamp(x - width/2, -r, r),
    	  dy = self.clamp(y - height/2, -r, r);
    	  return [Math.asin(dx/r), Math.asin(-dy/r)];
      };

      handlers.polardown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.dragBase = self.screenToPolar(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
          activeSub.camBase = [-Math.atan2(activeSub.saveMat.m13, activeSub.saveMat.m11),
                               Math.atan2(activeSub.saveMat.m32, activeSub.saveMat.m22)];
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.polarmove = function(x,y) {
        var dragCurrent = self.screenToPolar(x,y),
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            objects = self.scene.objects,
            l = activeModel.par3d.listeners,
            i, j, changepos = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          for (j=0; j<2; j++)
            changepos[j] = -(dragCurrent[j] - handlers.dragBase[j]);
          activeSub.par3d.userMatrix.makeIdentity();
          activeSub.par3d.userMatrix.rotate(changepos[0]*180/Math.PI, 0,-1,0);
          activeSub.par3d.userMatrix.multRight(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(changepos[1]*180/Math.PI, -1,0,0);
        }
        self.drawScene();
      };
      handlers.polarend = 0;

      handlers.axisdown = function(x) {
        handlers.rotBase = self.screenToVector(x, self.canvas.height/2);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.axismove = function(x) {
        var rotCurrent = self.screenToVector(x, self.canvas.height/2),
            rotBase = handlers.rotBase,
            angle = (rotCurrent[0] - rotBase[0])*180/Math.PI,
            rotMat = new CanvasMatrix4();
        rotMat.rotate(angle, handlers.axis[0], handlers.axis[1], handlers.axis[2]);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(activeSub.saveMat);
          activeSub.par3d.userMatrix.multLeft(rotMat);
        }
        self.drawScene();
      };
      handlers.axisend = 0;

      handlers.y0zoom = 0;
      handlers.zoomdown = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        handlers.y0zoom = y;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.zoom0 = Math.log(activeSub.par3d.zoom);
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.zoommove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom = Math.exp(activeSub.zoom0 + (y-handlers.y0zoom)/self.canvas.height);
        }
        self.drawScene();
      };
      handlers.zoomend = 0;

      handlers.y0fov = 0;
      handlers.fovdown = function(x, y) {
        handlers.y0fov = y;
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.fov0 = activeSub.par3d.FOV;
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.fovmove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.FOV = Math.max(1, Math.min(179, activeSub.fov0 +
             180*(y-handlers.y0fov)/self.canvas.height));
        }
        self.drawScene();
      };
      handlers.fovend = 0;
      
      handlers.selectingdown = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height, 
          p = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	self.select.region = {p1: p, p2: p};
      	if (self.select.subscene && self.select.subscene !== activeSubscene)
      	  self.delFromSubscene(self.scene.brushId, self.select.subscene);
      	self.select.subscene = activeSubscene;
      	self.addToSubscene(self.scene.brushId, activeSubscene);
      	self.select.state = "changing";
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene); 
      	self.drawScene();
      	self.canvas.style.cursor = "crosshair";
      };
      
      handlers.selectingmove = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height;
      	if (self.select.state === "inactive") 
      	  return;
      	self.select.region.p2 = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene);
      	self.drawScene();
      };
      
      handlers.selectingend = 0;
      /* jshint evil:true */
      handlers.userdown = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].begin;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.usermove = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].update;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.userend = function() {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].end;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self);
        }
      };

      self.canvas.onpointerdown = function ( ev ){
        // pointers and mice differ in capture rules; 
        // act like a mouse.
        if (ev.target.hasPointerCapture(ev.pointerId))
          ev.target.releasePointerCapture(ev.pointerId);
          
        if (!ev.which) // Use w3c defns in preference to MS
        switch (ev.button) {
          case 0: ev.which = 1; break;
          case 1:
          case 4: ev.which = 2; break;
          case 2: ev.which = 3;
        }
        drag = ["none", "left", "middle", "right", "wheel"][ev.which];
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height-coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f;
        handler = sub.par3d.mouseMode[drag];
        switch (handler) {
        case "xAxis":
          handler = "axis";
          handlers.axis = [1.0, 0.0, 0.0];
          break;
        case "yAxis":
          handler = "axis";
          handlers.axis = [0.0, 1.0, 0.0];
          break;
        case "zAxis":
          handler = "axis";
          handlers.axis = [0.0, 0.0, 1.0];
          break;
        }
        f = handlers[handler + "down"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
          ev.preventDefault();
        } else
          console.warn("Mouse handler '" + handler + "' is not implemented.");

      };

      self.canvas.onpointerup = function ( ev ){
        if ( !drag ) return;
        var f = handlers[handler + "end"];
        if (f) {
          f.call(self);
          ev.preventDefault();
        }
        drag = 0;
        handlers.onpointermove( ev );
      };

      self.canvas.onpointerout = self.canvas.onpointerup;

      handlers.onpointermove = function ( ev ) {
        var coords = self.relMouseCoords(ev), sub, f;
        coords.y = self.canvas.height - coords.y;
        if (ev.buttons === 0) {
          activeSubscene = self.whichSubscene(coords);
          drag = "none";
          sub = self.getObj(activeSubscene);
          handler = sub.par3d.mouseMode.none;
          if (handler !== "none") {
            if (sub.needsBegin) {
              f = handlers[handler + "down"];
              if (f) {
                coords = self.translateCoords(activeSubscene, coords);
                f.call(self, coords.x, coords.y);
              }
              sub.needsBegin = 0;
            }
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.none);
          } else {
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.left);  
            return;
          }
        }
        f = handlers[handler + "move"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
        }
      };
      

      self.canvas.onpointerenter = function() {
        self.canvas.addEventListener("pointermove",               handlers.onpointermove);
      };
      
      self.canvas.onpointerleave = function() {
        self.canvas.removeEventListener("pointermove",
          handlers.onpointermove);
      };

      handlers.setZoom = function(ds) {
        var i;
        if (typeof activeSubscene === "undefined")
          activeSubscene = self.scene.rootSubscene;
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            l = activeProjection.par3d.listeners;

        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom *= ds;
        }
        self.drawScene();
      };
      
      handlers.pushwheel = function(ev) {
        ev.deltaY = -ev.deltaY;
        handlers.pullwheel(ev);
      };
      
      handlers.pullwheel = function(ev) {
        var del = 1.05;
        if (ev.shiftKey) del = 1.005;
        var ds = ev.deltaY < 0 ? del : (1 / del);
        handlers.setZoom(ds);
      };
      
      handlers.user2wheel = function(ev) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks.wheel.rotate;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
          fn.call(self, ev.deltaY < 0 ? 1 : 2);
        }        
      };
        
      handlers.wheelHandler = function(ev) {
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height - coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f,
            handler = sub.par3d.mouseMode.wheel,
            evlocal;
            
        ev.deltaY = ev.deltaY || ev.detail || ev.deltaX || ev.wheelDelta;
                      
        switch(handler) {
          case "none": break;
          case "push":
          case "pull":
          case "user2":
            f = handlers[handler + "wheel"];
            if (f) {
              evlocal = {};
              evlocal.deltaY = ev.deltaY;
              evlocal.shiftKey = ev.shiftKey;
              evlocal.preventDefault = function() { ev.preventDefault(); };
              f.call(self, evlocal);
            }
            break;
          default: 
            evlocal = {};
            evlocal.preventDefault = function() { ev.preventDefault(); };
            evlocal.which = 4;
            evlocal.clientX = self.canvas.width/2;
            evlocal.clientY = self.canvas.height/2;
            self.canvas.onpointerdown(evlocal);
            evlocal.clientX += ev.deltaX;
            evlocal.clientY += ev.deltaY;
            handlers.onpointermove(evlocal);
            self.canvas.onpointerup(evlocal);
        }
        ev.preventDefault();
      };
      
      handlers.get_finger_dist = function(ev) {
        var diffX = ev.touches[0].clientX - ev.touches[1].clientX,
            diffY = ev.touches[0].clientY - ev.touches[1].clientY;
        return Math.sqrt(diffX * diffX + diffY * diffY); 
      };
      
      handlers.touchstart = function(ev) {
        var touch = ev.touches[0],
          mouseEvent = new MouseEvent("pointerdown",
            {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
        ev.preventDefault();
        if (ev.touches.length === 2) {
          var coords = self.relMouseCoords(touch);
          coords.y = self.canvas.height-coords.y;
          activeSubscene = self.whichSubscene(coords);
          handlers.finger_dist0 = handlers.get_finger_dist(ev);
          handlers.zoomdown(coords.x, coords.y);
        }
        self.dispatchEvent(mouseEvent);
      };
      
      handlers.touchend = function(ev) {
        var mouseEvent;
        ev.preventDefault();
        if (ev.touches.length === 1) {
          mouseEvent = new MouseEvent("pointerup", {});
          self.dispatchEvent(mouseEvent);
        }
      };
      
      handlers.touchmove = function(ev) {
        var touch = ev.touches[0],
          mouseEvent;
        ev.preventDefault();
        if (ev.touches.length > 1) {
          var coords = self.relMouseCoords(touch),
              new_dist = handlers.get_finger_dist(ev);
          coords.y = self.canvas.height*Math.log(handlers.finger_dist0/new_dist) + handlers.y0zoom;
          handlers.zoommove(coords.x, coords.y);
        } else {
          mouseEvent = new MouseEvent("pointermove",
          {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          self.dispatchEvent(mouseEvent);
        }
      };

      self.canvas.addEventListener("DOMMouseScroll", handlers.wheelHandler, false);
      self.canvas.addEventListener("mousewheel", handlers.wheelHandler, false);
      self.canvas.addEventListener("touchstart", handlers.touchstart, {passive: false});
      self.canvas.addEventListener("touchend", handlers.touchend, {passive: false});
      self.canvas.addEventListener("touchmove", handlers.touchmove, {passive: false});
	  };
</script>
<script>    /**
     * Methods related to initialization
     * @name ___METHODS_FOR_INITIALIZATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Initial test for WebGL
     */
    rglwidgetClass.prototype.initGL0 = function() {
      if (!window.WebGLRenderingContext){
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org");
        return;
      }
    };

    /**
     * Initialize WebGL
     * @returns { Object } the WebGL context
     */
    rglwidgetClass.prototype.initGL = function() {
      var self = this, success = false;
      if (this.gl) {
      	if (!this.drawing && this.gl.isContextLost())
          this.restartCanvas();
        else
          return this.gl;
      }
      // if (!this.isInBrowserViewport()) return; Return what??? At this point we know this.gl is null.
      this.canvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      this.canvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      this.gl = this.canvas.getContext("webgl", this.webGLoptions) ||
               this.canvas.getContext("experimental-webgl", this.webGLoptions);
      success = !!(this.gl && this.gl instanceof WebGLRenderingContext);
      if (!success)
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org"); 
      this.index_uint = this.gl.getExtension("OES_element_index_uint");
      var save = this.startDrawing();
      Object.keys(this.scene.objects).forEach(function(key){
        self.initObjId(parseInt(key, 10));
        });
      this.stopDrawing(save);
      return this.gl;
    };

    /**
     * Resize the display to match element
     * @param { Object } el - DOM element to match
     */
    rglwidgetClass.prototype.resize = function(el) {
      this.canvas.width = el.width;
      this.canvas.height = el.height;
    };

    /**
     * Initialize the sphere object
     */
    rglwidgetClass.prototype.initSphere = function(sections, segments) {
      var v = [], phi = [], theta = [], it = [], centers = [],
           i, j, k, ind, result = {};
       
      for (i = 0; i <= sections; i++) {
        phi.push(i/sections - 0.5);
      }

      for (j = 0; j <= segments; j++) {
        theta.push(2*j/segments);
        for (i = 0; i <= sections; i++) {
          /* These are [x,y,z,s,t]: */
          v.push([Math.sin(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),
                  Math.sin(Math.PI*phi[i]),
                  Math.cos(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),                               
                  theta[j]/2,
                  phi[i] + 0.5]);
           // console.log("xyzst="+v[v.length-1]);
        }
      }
      result.values = new Float32Array(rglwidgetClass.flatten(v));
      result.vertexCount = v.length;
      
      for (j = 0; j < segments; j++) {
        for (i = 0; i < sections; i++) {
          ind = i + (sections + 1)*j;
          if (i > 0)                       // Not south pole
            it.push([ind, 
                     ind + sections + 1,
                     ind + 1]);
          if (i < sections - 1)             // Not north pole
            it.push([ind + sections + 1, 
                     ind + sections + 2,
                     ind + 1]);
        }
      }
      result.it = new Uint16Array(rglwidgetClass.flatten(it));
      
      for (i = 0; i < it.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 3; k++) {// vertices
            centers[i][j] += v[it[i][k]][j]/3;
          }
        }
      }
      result.centers = centers;
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:0, radofs:-1, oofs:-1,
                         tofs:3, nextofs:-1, pointofs:-1, stride:5};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "sphere";
      this.sphere = result;
      this.initShapeGL(this.sphere);
    };

    /**
     * Initialize the cube object
     */
    rglwidgetClass.prototype.initCube = function() {
   var v = [[0, 0, 0], [1, 0, 0], 
            [0, 1, 0], [1, 1, 0], 
            [0, 0, 1], [1, 0, 1],
            [0, 1, 1], [1, 1, 1]],
          ib = [[0, 2, 3, 1], 
                [2, 6, 7, 3], 
                [1, 3, 7, 5], 
                [0, 4, 6, 2], 
                [0, 1, 5, 4], 
                [4, 5, 7, 6]], 
          centers = [], i, j, k, 
          i0, i1, i2,
          normal, result = {};
       
      for (i = 0; i < ib.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 4; k++) {// vertices
            centers[i][j] += v[ib[i][k]][j]/4;
          }
        }
      }
      result.centers = centers; 
      result.values = new Float32Array(6*4*3*2);
      result.vertexCount = 24;
      result.vertices = new Array(24);
      result.normals = new Array(24);
      for (i=0; i < 6; i++) {
        for (j=0; j < 4; j++) {
          i0 = ib[i][j];
          result.vertices[4*i + j] = v[i0];
          i1 = ib[i][(j + 1) % 4];
          i2 = ib[i][(j + 2) % 4];
          if (j === 0)
            normal = rglwidgetClass.normalize(rglwidgetClass.xprod(rglwidgetClass.vdiff(v[i1], v[i0]),
                                  rglwidgetClass.vdiff(v[i2], v[i0])));
          result.normals[4*i + j] = normal;
          for (k=0; k < 3; k++) {
            result.values[i*24 + j*6 + k] = v[i0][k];
            result.values[i*24 + j*6 + 3 + k] = normal[k];
          }
        }
        for (j=0; j<4; j++)
          ib[i][j] = 4*i + j;
      }
      result.ib = new Uint16Array(rglwidgetClass.flatten(ib));
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:3, radofs:-1, oofs:-1,
                         tofs:-1, nextofs:-1, pointofs:-1, stride:6};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "quads";
      this.cube = result;
      this.initShapeGL(this.cube);
    };
    

    /**
     * Do the gl part of initializing the sphere and cube
     */
    rglwidgetClass.prototype.initShapeGL = function(shape) {
      var gl = this.gl || this.initGL();
      if (gl.isContextLost()) return;
      shape.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, shape.buf);
      gl.bufferData(gl.ARRAY_BUFFER, shape.values, gl.STATIC_DRAW);
      shape.ibuf = [gl.createBuffer(), gl.createBuffer()];
      return;
    };

    /* Initialize common sphere object from spheres object
    */
    rglwidgetClass.prototype.initShapeFromObj = function(shape, obj) {
      var i, pass, f, mode, self = this,
        /* This function selects things that would be
           the back, ignoring perspective -- this is what 
           we want for the bounding box decoration. */
        is_back = function(i) {
                var normal = [].concat(shape.normals[i]),
                  pt = shape.vertices[i];
                normal.push(-rglwidgetClass.dotprod(normal, pt));
                normal = rglwidgetClass.multVM(normal, self.normMatrix);
                return normal[2] < 0 || (normal[2] === 0 && normal[0] < 0);
              }; 
      shape.ofsLoc = obj.ofsLoc;
      shape.texLoc = obj.texLoc;
      shape.texture = obj.texture;
      shape.sampler = obj.sampler;
      shape.uFogMode = obj.uFogMode;
      shape.uFogColor = obj.uFogColor;
      shape.uFogParms = obj.uFogParms;
      shape.userAttribLocations = obj.userAttribLocations;
      shape.userUniformLocations = obj.userUniformLocations;
      shape.normLoc = obj.normLoc;
      shape.invPrMatLoc = obj.invPrMatLoc;
      shape.clipLoc = obj.clipLoc;
      shape.nextLoc = obj.nextLoc;
      shape.pointLoc = obj.pointLoc;
      shape.aspectLoc = obj.aspectLoc;
      shape.lwdLoc = obj.lwdLoc;
      shape.prog = obj.prog;
      shape.material = obj.material;
      shape.flags = obj.flags;
      shape.defFlags = obj.defFlags;
      shape.someHidden = obj.someHidden;
      shape.fastTransparency = obj.fastTransparency;
      shape.nlights = obj.nlights;
      shape.emission = obj.emission;
      shape.emissionLoc = obj.emissionLoc;
      shape.shininess = obj.shininess;
      shape.shininessLoc = obj.shininessLoc;
      shape.ambient = obj.ambient;
      shape.ambientLoc = obj.ambientLoc;
      shape.specular = obj.specular;
      shape.specularLoc = obj.specularLoc;
      shape.diffuse = obj.diffuse;
      shape.diffuseLoc = obj.diffuseLoc;
      shape.lightDir = obj.lightDir;
      shape.lightDirLoc = obj.lightDirLoc;
      shape.viewpoint = obj.viewpoint;
      shape.viewpointLoc = obj.viewpointLoc;
      shape.finite = obj.finite;
      shape.finiteLoc = obj.finiteLoc;
      shape.prMatLoc = obj.prMatLoc;
      shape.mvMatLoc = obj.mvMatLoc;
      shape.normMatLoc = obj.normMatLoc;
      shape.frontLoc = obj.frontLoc;
      shape.index_uint = false;
      shape.is_transparent = obj.is_transparent;
      shape.ignoreExtent = obj.ignoreExtent;
      if (shape.passes !== obj.passes ||
          JSON.stringify( shape.pmode) !== JSON.stringify(obj.pmode)) {
        shape.passes = obj.passes;
        shape.pmode = obj.pmode;
        for (pass = 0; pass < obj.passes; pass++) {
          mode =  shape.pmode[pass];
          if (typeof  shape.indices[mode] === "undefined") {
            f = [];
            switch (mode) {
            case "culled": break;
            case "points":
              f.length =  shape.vertexCount;
              for (i=0; i < f.length; i++)
                f[i] = i;
              break;
            case "lines":
              if (typeof shape.it !== "undefined") {
                f.length = 2* shape.it.length;
      	        for (i=0; i <  shape.it.length/3; i++) {
      	          f[6*i] =  shape.it[3*i];
      	          f[6*i + 1] =  shape.it[3*i + 1];
      	          f[6*i + 2] =  shape.it[3*i + 1];
      	          f[6*i + 3] =  shape.it[3*i + 2];
      	          f[6*i + 4] =  shape.it[3*i + 2];
      	          f[6*i + 5] =  shape.it[3*i];
      	        }
              } else {
                f.length = 2*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[8*i] = shape.ib[4*i];
                  f[8*i + 1] = shape.ib[4*i + 1];
                  f[8*i + 2] = shape.ib[4*i + 1];
                  f[8*i + 3] = shape.ib[4*i + 2];
                  f[8*i + 4] = shape.ib[4*i + 2];
                  f[8*i + 5] = shape.ib[4*i + 3];
                  f[8*i + 6] = shape.ib[4*i + 3];
                  f[8*i + 7] = shape.ib[4*i];
                }
              }
      	      break;
      	    case "filled":
      	      if (typeof shape.it !== "undefined")
      	        f =  shape.it;
      	      else if (typeof shape.ib !== "undefined") {
      	        f.length = 1.5*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[6*i] = shape.ib[4*i];
                  f[6*i+1] = shape.ib[4*i + 1];
                  f[6*i+2] = shape.ib[4*i + 2];
                  f[6*i+3] = shape.ib[4*i];
                  f[6*i+4] = shape.ib[4*i + 2];
                  f[6*i+5] = shape.ib[4*i + 3];
                }      	        
      	      }
      	      break;
      	    }              
            shape.indices[mode] = new Uint16Array(f);
          }
        }
      }       
      for (pass = 0; pass < obj.passes; pass++) {
        mode =  shape.pmode[pass];
        shape.f[pass] =  shape.indices[mode];
        if (typeof obj.draw_front !== "undefined" &&
            !obj.draw_front) {
          shape.f[pass] = shape.f[pass].filter(is_back);   
        }
      }
      // console.log("Names in  shapes not in  shape:"+JSON.stringify(rglwidgetClass.keydiff(obj,  shape)));
       shape.initialized = true;
    };

    /**
     * Initialize a subscene
     * @param { number } id - id of subscene.
     */
    rglwidgetClass.prototype.initSubscene = function(id) {
      var sub = this.getObj(id),
          i, obj;

      if (sub.type !== "subscene")
        return;

      sub.par3d.userMatrix = this.toCanvasMatrix4(sub.par3d.userMatrix);
      sub.par3d.userProjection = this.toCanvasMatrix4(sub.par3d.userProjection);
      sub.par3d.userProjection.transpose();
      sub.par3d.listeners = [].concat(sub.par3d.listeners);
      sub.backgroundId = undefined;
      sub.subscenes = [];
      sub.clipplanes = [];
      sub.transparent = [];
      sub.opaque = [];
      sub.lights = [];
      sub.needsBegin = true;
      if (typeof sub.objects !== "undefined")
        sub.objects = [].concat(sub.objects); /* make sure it's an array */
      for (i=0; i < sub.objects.length; i++) {
        obj = this.getObj(sub.objects[i]);
        if (typeof obj === "undefined") {
          sub.objects.splice(i, 1);
          i--;
        } else if (obj.type === "background")
          sub.backgroundId = obj.id;
        else
          sub[this.whichList(obj.id)].push(obj.id);
      }
    };
    
    rglwidgetClass.prototype.initBBox = function(obj) {
      if (!this.cube)
        this.initCube();
      obj.cube = {id: obj.id + 0.1,
                    type: "quads",
                    flags: obj.flags,
                    material: obj.material,
                    colors: [obj.colors[0]],
                    vertices: this.cube.vertices,
                    normals: this.cube.normals,
                    draw_front: obj.draw_front,
                    initialized: false
        };
      if (this.getMaterial(obj.cube, "front") !==
          this.getMaterial(obj.cube, "back"))
        /* jshint bitwise: false */  
        obj.cube.flags |= rglwidgetClass.f_is_twosided;
        /* jshint bitwise: true */
      this.scene.objects[obj.cube.id] = obj.cube;
      obj.ticks = {id: obj.id + 0.2,
                     type: "lines",
                     flags: rglwidgetClass.f_has_fog,
                     material: obj.material,
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     axes: obj.axes,
                     initialized: false
      };
      this.scene.objects[obj.ticks.id] = obj.ticks;
      obj.labels = {id: obj.id + 0.3,
                     type: "text",
                     flags: rglwidgetClass.f_has_fog + 
                            rglwidgetClass.f_fixed_size + 
                            rglwidgetClass.f_fixed_quads,
                     material: {lit: false},
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     cex: [[1]],
                     family: [["sans"]],
                     font: [[1]],
                     adj: [[0.5, 0.5, 0.5]],
                     ignoreExtent: true,
                     initialized: false
      };
      this.scene.objects[obj.labels.id] = obj.labels;
      obj.initialized = true;
    };
    
    rglwidgetClass.prototype.initBackground = function(obj) {
      var material, fl = obj.defFlags;
      if (typeof obj.ids !== "undefined")
        obj.quad = rglwidgetClass.flatten([].concat(obj.ids));
      else if (obj.sphere) {
        fl.has_normals = true;
        fl.needs_vnormal = true;
        obj.defFlags = fl;
        material = obj.material;
        material.front = "culled";
        obj.vertices = [[0,0,0]];
        obj.texcoords = [[0,0]];
      }  
    };

    /**
     * Initialize object for display
     * @param { number } id - id of object to initialize
     */
    rglwidgetClass.prototype.initObjId = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("initObj id is "+typeof id);
      }
      return this.initObj(this.getObj(id));
    };

    /**
     * Initialize object for display
     * @param { Object } obj - object to initialize
     */
    rglwidgetClass.prototype.initObj = function(obj) {
      var type = obj.type, 
          flags = obj.flags,
          normals = obj.normals,
          round_points = (typeof obj.material === "undefined") ?
            false : this.getMaterial(obj, "point_antialias"),
          has_indices = typeof obj.indices !== "undefined",
          has_spheres = type === "spheres" || 
                        (type === "background" && obj.sphere),
          sprites_3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          depth_sort = rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort),
          gl = this.gl || this.initGL(),
          fl, polygon_offset,
          texinfo, drawtype, nclipplanes, f, nrows, oldrows,
          i,j,v,v1,v2, mat, uri, matobj, pass, pmode,
          dim, nx, nz, nrow, shaders;

    obj.initialized = true;
    
    obj.someHidden = false; // used in selection
    
    this.expandBufferedFields(obj);
    
    if (type === "subscene")
      return;
      
    obj.defFlags = fl = rglwidgetClass.getDefFlags(flags, type, normals, round_points);
  
    obj.is_transparent = fl.is_transparent;
  
    if (type === "bboxdeco")
      return this.initBBox(obj);
      
    if (has_spheres && typeof this.sphere === "undefined")
      this.initSphere(16, 16);

    if (type === "light") {
      obj.ambient = new Float32Array(obj.colors[0].slice(0,3));
      obj.diffuse = new Float32Array(obj.colors[1].slice(0,3));
      obj.specular = new Float32Array(obj.colors[2].slice(0,3));
      obj.lightDir = new Float32Array(obj.vertices[0]);
      return;
    }

    if (type === "clipplanes") {
      obj.vClipplane = rglwidgetClass.flatten(rglwidgetClass.cbind(obj.normals, obj.offsets));
      return;
    }

    if (type === "background") {
      this.initBackground(obj);
      if (!obj.sphere)
        return;
    }

    polygon_offset = this.getMaterial(obj, "polygon_offset");
    if (polygon_offset[0] !== 0 || polygon_offset[1] !== 0)
      obj.polygon_offset = polygon_offset;

    if (fl.is_transparent) {
      depth_sort = ["triangles", "quads", "surface",
                    "spheres", "sprites", "text",
                    "planes"].indexOf(type) >= 0;
    }
    
    if (fl.is_brush)
      this.initSelection(obj.id);

    if (typeof obj.vertices === "undefined")
      obj.vertices = [];

    v = obj.vertices;
    if (has_indices)
      obj.vertexCount = obj.indices.length;
    else
      obj.vertexCount = v.length;
      
    if (!obj.vertexCount) return;

    if (fl.is_twosided && !fl.has_normals && type !== "background") {
      if (typeof obj.userAttributes === "undefined")
        obj.userAttributes = {};
      v1 = Array(v.length);
      v2 = Array(v.length);
      if (obj.type === "triangles" || obj.type === "quads") {
      	if (obj.type === "triangles")
      	  nrow = 3;
      	else
      	  nrow = 4;
        for (i=0; i<Math.floor(v.length/nrow); i++)
          for (j=0; j<nrow; j++) {
            v1[nrow*i + j] = v[nrow*i + ((j+1) % nrow)];
            v2[nrow*i + j] = v[nrow*i + ((j+2) % nrow)];
          }
      } else if (obj.type === "surface") {
        dim = obj.dim[0];
        nx = dim[0];
        nz = dim[1];
        for (j=0; j<nx; j++) {
          for (i=0; i<nz; i++) {
            if (i+1 < nz && j+1 < nx) {
              v2[j + nx*i] = v[j + nx*(i+1)];
              v1[j + nx*i] = v[j+1 + nx*(i+1)];
            } else if (i+1 < nz) {
              v2[j + nx*i] = v[j-1 + nx*i];
              v1[j + nx*i] = v[j + nx*(i+1)];
            } else {
              v2[j + nx*i] = v[j + nx*(i-1)];
              v1[j + nx*i] = v[j-1 + nx*(i-1)];
            }
          }
        }
      }
      obj.userAttributes.aPos1 = v1;
      obj.userAttributes.aPos2 = v2;
    }

    if (!sprites_3d) {
      if (gl.isContextLost()) return;
      if (typeof obj.prog !== "undefined") {
        gl.deleteProgram(obj.prog);
        obj.prog = undefined;
      }
      
      shaders = this.getShaders(obj);
      
      obj.prog = gl.createProgram();
      gl.attachShader(obj.prog, this.getShader( gl.VERTEX_SHADER,
                      shaders.vertex ));
      gl.attachShader(obj.prog, this.getShader( gl.FRAGMENT_SHADER,
                      shaders.fragment ));
      //  Force aPos to location 0, aCol to location 1
      gl.bindAttribLocation(obj.prog, 0, "aPos");
      gl.bindAttribLocation(obj.prog, 1, "aCol");
      gl.linkProgram(obj.prog);
      var linked = gl.getProgramParameter(obj.prog, gl.LINK_STATUS);
      if (!linked) {

        // An error occurred while linking
        var lastError = gl.getProgramInfoLog(obj.prog);
        console.warn("Error in program linking:" + lastError);

        gl.deleteProgram(obj.prog);
        return;
      }
    }

    if (type === "text") {
      texinfo = this.drawTextToCanvas(obj.texts,
                                      rglwidgetClass.flatten(obj.cex),
                                      rglwidgetClass.flatten(obj.family),
                                      rglwidgetClass.flatten(obj.family));
    }

    if (fl.fixed_quads && !sprites_3d) {
      obj.ofsLoc = gl.getAttribLocation(obj.prog, "aOfs");
    }

    if (fl.has_texture || type === "text") {
      if (!obj.texture) {
        obj.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
      }
      obj.texLoc = gl.getAttribLocation(obj.prog, "aTexcoord");
      obj.sampler = gl.getUniformLocation(obj.prog, "uSampler");
    }
    
    if (fl.has_fog && !sprites_3d) {
      obj.uFogMode = gl.getUniformLocation(obj.prog, "uFogMode");
      obj.uFogColor = gl.getUniformLocation(obj.prog, "uFogColor");
      obj.uFogParms = gl.getUniformLocation(obj.prog, "uFogParms");
    }

    if (fl.has_texture) {
      mat = obj.material;
      if (typeof mat.uri !== "undefined")
        uri = mat.uri;
      else if (typeof mat.uriElementId === "undefined") {
        matobj = this.getObj(mat.uriId);
        if (typeof matobj !== "undefined") {
          uri = matobj.material.uri;
        } else {
          uri = "";
        }
      } else
        uri = document.getElementById(mat.uriElementId).rglinstance.getObj(mat.uriId).material.uri;

      this.loadImageToTexture(uri, obj.texture);
    }

    if (type === "text") {
      this.handleLoadedTexture(obj.texture, this.textureCanvas);
    }

    var stride = 3, nc, cofs, nofs, radofs, oofs, tofs, vnew, fnew,
        nextofs = -1, pointofs = -1, alias, colors, key, selection,
        filter, adj, offset, attr, last, options;

    obj.alias = undefined;
    
    colors = obj.colors;

    j = this.scene.crosstalk.id.indexOf(obj.id);
    if (j >= 0) {
      key = this.scene.crosstalk.key[j];
      options = this.scene.crosstalk.options[j];
      colors = colors.slice(0); 
      for (i = 0; i < v.length; i++)
        colors[i] = obj.colors[i % obj.colors.length].slice(0);
      if ( (selection = this.scene.crosstalk.selection) &&
           (selection.length || !options.selectedIgnoreNone) )
        for (i = 0; i < v.length; i++) {
          if (!selection.includes(key[i])) {
            if (options.deselectedColor)
              colors[i] = options.deselectedColor.slice(0);
            colors[i][3] = colors[i][3]*options.deselectedFade;   /* default: mostly transparent if not selected */
          } else if (options.selectedColor)
            colors[i] = options.selectedColor.slice(0);
        }
      if ( (filter = this.scene.crosstalk.filter) )
        for (i = 0; i < v.length; i++) 
          if (!filter.includes(key[i])) {
            if (options.filteredColor)
              colors[i] = options.filteredColor.slice(0);
            colors[i][3] = colors[i][3]*options.filteredFade;   /* default: completely hidden if filtered */
          }
    }  
    
    nc = obj.colorCount = colors.length;
    if (nc > 1) {
      cofs = stride;
      stride = stride + 4;
      v = rglwidgetClass.cbind(v, colors);
    } else {
      cofs = -1;
      obj.onecolor = rglwidgetClass.flatten(colors);
    }

    if (fl.has_normals && !has_spheres) {
      nofs = stride;
      stride = stride + 3;
      v = rglwidgetClass.cbind(v, typeof obj.pnormals !== "undefined" ? obj.pnormals : obj.normals);
    } else
      nofs = -1;

    if (typeof obj.radii !== "undefined") {
      radofs = stride;
      stride = stride + 1;
      // FIXME:  always concat the radii?
      if (obj.radii.length === v.length) {
        v = rglwidgetClass.cbind(v, obj.radii);
      } else if (obj.radii.length === 1) {
        v = v.map(function(row) { return row.concat(obj.radii[0]);});
      }
    } else
      radofs = -1;
      
    // Add default indices
    if (has_indices) {
      f = Array(obj.indices.length);
      for (i = 0; i < f.length; i++)
        f[i] = obj.indices[i] - 1;
    } else {
      f = Array(v.length);
      for (i = 0; i < v.length; i++)
        f[i] = i;
    }
    obj.f = [f,f];

    if (type === "sprites" && !sprites_3d) {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      fnew = new Array(4*v.length);
      alias = new Array(v.length);
      var rescale = fl.fixed_size ? 72 : 1,
          size = obj.radii, s = rescale*size[0]/2;
      last = v.length;
      f = obj.f[0];
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = obj.adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset);
        if (size.length > 1)
          s = rescale*size[i]/2;
        adj[0] = 2*s*(adj[0] - 0.5);
        adj[1] = 2*s*(adj[1] - 0.5);
        adj[2] = 2*s*(adj[2] - 0.5);
        vnew[i]  = v[i].concat([0,0]).concat([-s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i] = f[i];
        vnew[last]= v[i].concat([1,0]).concat([s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i+1] = last++;
        vnew[last]= v[i].concat([1,1]).concat([s-adj[0],
                                               s-adj[1],
                                               -adj[2]]);
        fnew[4*i+2] = last++;
        vnew[last]= v[i].concat([0,1]).concat([-s-adj[0],
                                                s-adj[1],
                                                -adj[2]]);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (type === "text") {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      f = obj.f[0];
      fnew = new Array(4*f.length);
      alias = new Array(v.length);
      last = v.length;
      adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset, obj.texts[i]);
        vnew[i]  = v[i].concat([0,-0.5]).concat(adj);
        fnew[4*i] = f[i];
        vnew[last] = v[i].concat([1,-0.5]).concat(adj);
        fnew[4*i+1] = last++;
        vnew[last] = v[i].concat([1, 1.5]).concat(adj);
        fnew[4*i+2] = last++;
        vnew[last] = v[i].concat([0, 1.5]).concat(adj);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
        for (j=0; j < 4; j++) {
          v1 = vnew[fnew[4*i+j]];
          v1[oofs] = 2*(v1[tofs]-v1[oofs])*texinfo.widths[i];
          v1[oofs+1] = 2*(v1[tofs+1]-v1[oofs+1])*texinfo.textHeights[i];
          v1[oofs+2] = 2*(0.5-v1[oofs+2])*texinfo.textHeights[i]/1000.0;
          v1[tofs] = (texinfo.offsetsx[i] + v1[tofs]*texinfo.widths[i])/texinfo.canvasX;
          v1[tofs+1] = 1.0-(texinfo.offsetsy[i] -
              v1[tofs+1]*texinfo.textHeights[i])/texinfo.canvasY;
          vnew[fnew[4*i+j]] = v1;
        }
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (typeof obj.texcoords !== "undefined") {
      tofs = stride;
      stride += 2;
      oofs = -1;
      v = rglwidgetClass.cbind(v, obj.texcoords);
    } else {
      tofs = -1;
      oofs = -1;
    }
    
    obj.alias = alias;
                          
    if (typeof obj.userAttributes !== "undefined") {
      obj.userAttribOffsets = {};
      obj.userAttribLocations = {};
      obj.userAttribSizes = {};
      for (attr in obj.userAttributes) {
      	obj.userAttribLocations[attr] = gl.getAttribLocation(obj.prog, attr);
      	if (obj.userAttribLocations[attr] >= 0) { // Attribute may not have been used
      	  obj.userAttribOffsets[attr] = stride;
      	  v = rglwidgetClass.cbind(v, obj.userAttributes[attr]);
      	  stride = v[0].length;
      	  obj.userAttribSizes[attr] = stride - obj.userAttribOffsets[attr];
      	} else
      	  console.warn("attribute '"+attr+"' not found in object "+obj.id+".");
      }
    }

    if (typeof obj.userUniforms !== "undefined" ||
        typeof obj.userTextures !== "undefined") {
      obj.userUniformLocations = {};
      for (attr in obj.userUniforms) {
        obj.userUniformLocations[attr] = gl.getUniformLocation(obj.prog, attr);
        if (obj.userUniformLocations[attr] === null)
          console.warn("uniform '"+attr+"' not found in object "+obj.id+".");
      }
      for (attr in obj.userTextures) {
        var texture = obj.userTextures[attr];
        texture.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
        texture.sampler = gl.getUniformLocation(obj.prog, attr);
        if (texture.sampler === null)
          console.warn("sampler '"+attr+"' not found in object "+obj.id+".");
        uri = texture.uri;
        this.loadImageToTexture(uri, texture.texture);
      }
    }

    if (sprites_3d) {
      obj.userMatrix = new CanvasMatrix4();
      obj.userMatrix.load(rglwidgetClass.flatten(obj.usermatrix));
      obj.objects = rglwidgetClass.flatten([].concat(obj.ids));
      fl.is_lit = false;
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        obj.offset = obj.adj[0];
      } else
        obj.offset = 0;
        
      for (i=0; i < obj.objects.length; i++)
        this.initObjId(obj.objects[i]);
    }

    nclipplanes = this.countClipplanes();
    if (nclipplanes && !sprites_3d) {
      obj.clipLoc = gl.getUniformLocation(obj.prog,"vClipplane");
    }

    if (fl.is_lit) {
      obj.emissionLoc = gl.getUniformLocation(obj.prog, "emission");
      obj.emission = new Float32Array(this.stringToRgb(this.getMaterial(obj, "emission")));
      obj.shininessLoc = gl.getUniformLocation(obj.prog, "shininess");
      obj.shininess = this.getMaterial(obj, "shininess");
      obj.nlights = this.countLights();
      if (obj.nlights > 0) {
        obj.ambient = new Float32Array(this.stringToRgb(this.getMaterial(obj, "ambient")));
        obj.specular = new Float32Array(this.stringToRgb(this.getMaterial(obj, "specular")));
        obj.ambientLoc = gl.getUniformLocation(obj.prog, "ambient");
        obj.specularLoc = gl.getUniformLocation(obj.prog, "specular");
        obj.diffuseLoc = gl.getUniformLocation(obj.prog, "diffuse" );
        obj.lightDirLoc = gl.getUniformLocation(obj.prog, "lightDir");
        obj.viewpointLoc = gl.getUniformLocation(obj.prog, "viewpoint");
        obj.finiteLoc = gl.getUniformLocation(obj.prog, "finite" );
      }
    }
    
    obj.passes = fl.is_twosided + 1;
    obj.pmode = new Array(obj.passes);
    for (pass = 0; pass < obj.passes; pass++) {
      if (type === "triangles" || type === "quads" || type === "surface" || has_spheres)
      	pmode = this.getMaterial(obj, (pass === 0) ? "front" : "back");
      else pmode = "filled";
      obj.pmode[pass] = pmode;
    }
    if (!has_spheres) {
      obj.f.length = obj.passes;
      for (pass = 0; pass < obj.passes; pass++) {
      	f = fnew = obj.f[pass];
        pmode = obj.pmode[pass];
      	if (pmode === "culled")
      	  fnew = [];
        else if (pmode === "points") {
          // stay with default
        } else if ((type === "quads" || type === "text" ||
             type === "sprites") && !sprites_3d) {
          nrows = Math.floor(obj.vertexCount/4);
          if (pmode === "filled") {
            fnew = Array(6*nrows);
            for (i=0; i < nrows; i++) {
              fnew[6*i] = f[4*i];
              fnew[6*i+1] = f[4*i + 1];
              fnew[6*i+2] = f[4*i + 2];
              fnew[6*i+3] = f[4*i];
              fnew[6*i+4] = f[4*i + 2];
              fnew[6*i+5] = f[4*i + 3];
            }
          } else {
            fnew = Array(8*nrows);
            for (i=0; i < nrows; i++) {
              fnew[8*i] = f[4*i];
              fnew[8*i+1] = f[4*i + 1];
              fnew[8*i+2] = f[4*i + 1];
              fnew[8*i+3] = f[4*i + 2];
              fnew[8*i+4] = f[4*i + 2];
              fnew[8*i+5] = f[4*i + 3];
              fnew[8*i+6] = f[4*i + 3];
              fnew[8*i+7] = f[4*i];
            }
          }
        } else if (type === "triangles") {
          nrows = Math.floor(obj.vertexCount/3);
          if (pmode === "filled") {
            fnew = Array(3*nrows);
            for (i=0; i < fnew.length; i++) {
              fnew[i] = f[i];
            }
          } else if (pmode === "lines") {
            fnew = Array(6*nrows);
      	    for (i=0; i < nrows; i++) {
      	      fnew[6*i] = f[3*i];
      	      fnew[6*i + 1] = f[3*i + 1];
      	      fnew[6*i + 2] = f[3*i + 1];
      	      fnew[6*i + 3] = f[3*i + 2];
      	      fnew[6*i + 4] = f[3*i + 2];
      	      fnew[6*i + 5] = f[3*i];
      	    }
          }
        } else if (has_spheres) {
          // default
        } else if (type === "surface") {
          dim = obj.dim[0];
          nx = dim[0];
          nz = dim[1];
          if (pmode === "filled") {
            fnew = [];
            for (j=0; j<nx-1; j++) {
              for (i=0; i<nz-1; i++) {
                fnew.push(f[j + nx*i],
                       f[j + nx*(i+1)],
                       f[j + 1 + nx*(i+1)],
                       f[j + nx*i],
                       f[j + 1 + nx*(i+1)],
                       f[j + 1 + nx*i]);
              }
            }
          } else if (pmode === "lines") {
            fnew = [];
            for (j=0; j<nx; j++) {
              for (i=0; i<nz; i++) {
                if (i+1 < nz)
                  fnew.push(f[j + nx*i],
                         f[j + nx*(i+1)]);
                if (j+1 < nx)
                  fnew.push(f[j + nx*i],
                         f[j+1 + nx*i]);
              }
            }
          }
        }
        obj.f[pass] = fnew;
        if (depth_sort) {
          drawtype = "DYNAMIC_DRAW";
        } else {
          drawtype = "STATIC_DRAW";
        }
      }
    }
    
    if (fl.fat_lines) {
      alias = undefined;
      obj.nextLoc = gl.getAttribLocation(obj.prog, "aNext");
      obj.pointLoc = gl.getAttribLocation(obj.prog, "aPoint");
      obj.aspectLoc = gl.getUniformLocation(obj.prog, "uAspect");
      obj.lwdLoc = gl.getUniformLocation(obj.prog, "uLwd");
      // Expand vertices to turn each segment into a pair of triangles
        
      	for (pass = 0; pass < obj.passes; pass++) {
      	  f = obj.f[pass];	
          oldrows = f.length;
      	  if (obj.pmode[pass] === "lines") 
      	    break;
      	}
      
      if (type === "linestrip") 
        nrows = 4*(oldrows - 1); 
      else
        nrows = 2*oldrows;
      vnew = new Array(nrows);
      fnew = new Array(1.5*nrows);
      
      // We're going to turn each pair of vertices into 4 new ones, with the "next" and "pt" attributes
      // added.
      // We do this by copying the originals in the first pass, adding the new attributes, then in a 
      // second pass add new vertices at the end.

      for (i = 0; i < v.length; i++) {
        vnew[i] = v[i].concat([0,0,0,0,0]); 
      }

      nextofs = stride;
      pointofs = stride + 3;
      stride = stride + 5;
            
      // Now add the extras
      var ind, k;
      last = v.length - 1;
      ind = 0;
      alias = new Array(f.length);
      for (i = 0; i < f.length; i++)
        alias[i] = [];
      for (i = 0; i < f.length - 1; i++) {
      	if (type !== "linestrip" && i % 2 === 1)
      	  continue;
      	k = ++last;
      	vnew[k] = vnew[f[i]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i+1]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = -1;
      	fnew[ind] = k;
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+1] = last;
      	alias[f[i]].push(last-1, last);
      	last++;
      	k = last;
      	vnew[k] = vnew[f[i+1]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = 1;
      	fnew[ind+2] = k;
      	fnew[ind+3] = fnew[ind+1];
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+4] = last;
      	fnew[ind+5] = fnew[ind+2];
      	ind += 6;
      	alias[f[i+1]].push(last-1, last);
      }
      vnew.length = last+1;
      v = vnew;
      obj.vertexCount = v.length;
      if (typeof alias !== "undefined" && typeof obj.alias !== "undefined") {  // Already have aliases from previous section?
        var oldalias = obj.alias, newalias = Array(obj.alias.length);
        for (i = 0; i < newalias.length; i++) {
          newalias[i] = oldalias[i].slice();
          for (j = 0; j < oldalias[i].length; j++)
            Array.prototype.push.apply(newalias[i], alias[oldalias[j]]); // pushes each element 
        }
        obj.alias = newalias;
      } else
        obj.alias = alias;
      
      for (pass = 0; pass < obj.passes; pass++)
      	if (type === "lines" || type === "linestrip" || obj.pmode[pass] === "lines") {
          obj.f[pass] = fnew;
        }
      
      if (depth_sort) 
        drawtype = "DYNAMIC_DRAW";
      else
        drawtype = "STATIC_DRAW";
    }
    
      for (pass = 0; pass < obj.passes; pass++) {
        if (obj.vertexCount > 65535) {
          if (this.index_uint) {
            obj.f[pass] = new Uint32Array(obj.f[pass]);
            obj.index_uint = true;
          } else
            this.alertOnce("Object has "+obj.vertexCount+" vertices, not supported in this browser.");
        } else {
          obj.f[pass] = new Uint16Array(obj.f[pass]);
          obj.index_uint = false;
        }
      }
    
    if (stride !== v[0].length) {
      this.alertOnce("problem in stride calculation");
    }

    obj.vOffsets = {vofs:0, cofs:cofs, nofs:nofs, radofs:radofs, oofs:oofs, tofs:tofs,
                    nextofs:nextofs, pointofs:pointofs, stride:stride};

    obj.values = new Float32Array(rglwidgetClass.flatten(v));

    if (!has_spheres && !sprites_3d) {
      obj.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
      gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW); //
      obj.ibuf = Array(obj.passes);
      obj.ibuf[0] = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[0]);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[0], gl[drawtype]);
      if (fl.is_twosided) {
      	obj.ibuf[1] = gl.createBuffer();
      	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[1]);
      	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[1], gl[drawtype]);
      }
    }

    if (!sprites_3d) {
      obj.mvMatLoc = gl.getUniformLocation(obj.prog, "mvMatrix");
      obj.prMatLoc = gl.getUniformLocation(obj.prog, "prMatrix");

      if (fl.fixed_size) {
        obj.textScaleLoc = gl.getUniformLocation(obj.prog, "textScale");
      }
    }

    if (fl.needs_vnormal) {
      obj.normLoc = gl.getAttribLocation(obj.prog, "aNorm");
      obj.normMatLoc = gl.getUniformLocation(obj.prog, "normMatrix");
    }

    if (fl.is_twosided) {
      obj.frontLoc = gl.getUniformLocation(obj.prog, "front");
      if (fl.has_normals)
        obj.invPrMatLoc = gl.getUniformLocation(obj.prog, "invPrMatrix");
    }
  };
    
    /**
     * Initialize the DOM object
     * @param { Object } el - the DOM object
     * @param { Object } x - the scene data sent by JSON from R
     */
    rglwidgetClass.prototype.initialize = function(el, x) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.style.display = "block";
      this.scene = x;
      this.normMatrix = new CanvasMatrix4();
      this.invPrMatrix = new CanvasMatrix4();
      this.saveMat = {};
      this.distance = null;
      this.posLoc = 0;
      this.colLoc = 1;
      if (el) {
        el.rglinstance = this;
        this.el = el;
        this.webGLoptions = el.rglinstance.scene.webGLoptions;
        this.initCanvas();
      }
      if (typeof Shiny !== "undefined") {
        var self = this;
        Shiny.addCustomMessageHandler("shinyGetPar3d",
          function(message) {
            var i, param, 
                subscene = self.getObj(message.subscene),
                parameters = [].concat(message.parameters),
                result = {tag: message.tag, subscene: message.subscene};
            if (typeof subscene !== "undefined") {
              for (i = 0; i < parameters.length; i++) {
                param = parameters[i];
                result[param] = subscene.par3d[param];
              }
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
            Shiny.setInputValue("par3d:shinyPar3d", result, {priority: "event"});
          });
          
        Shiny.addCustomMessageHandler("shinySetPar3d",
          function(message) {
            var param = message.parameter, 
                subscene = self.getObj(message.subscene);
            if (typeof subscene !== "undefined") {
              subscene.par3d[param] = message.value;
              subscene.initialized = false;
              self.drawScene();
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
          });
          
        Shiny.addCustomMessageHandler("resetBrush",
          function(message) {
            if (message === self.scene.selectionInput) {
              self.clearBrush(null);
              self.recordSelection(0);
            }
          });
      }
    };
    
    /**
     * Restart the WebGL canvas
     */
    rglwidgetClass.prototype.restartCanvas = function() {
      var newcanvas = document.createElement("canvas"),
          self = this, 
          labelid = this.el.getAttribute("aria-labelledby");
      newcanvas.width = this.el.width;
      newcanvas.height = this.el.height;
      newcanvas.setAttribute("aria-labelledby", 
        labelid);
        
      if (typeof this.scene.altText !== "undefined")
        // We're in Shiny, so alter the label
        document.getElementById(labelid).innerHTML = this.scene.altText;

      newcanvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      newcanvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      while (this.el.firstChild) {
        this.el.removeChild(this.el.firstChild);
      }
      this.el.appendChild(newcanvas);
      this.canvas = newcanvas;
      if (this.scene.javascript) {
        /* jshint evil:true */
        Function('"use strict";' + this.scene.javascript)();
        /* jshint evil:false */
      }
      this.setMouseHandlers();
      if (this.gl) 
        Object.keys(this.scene.objects).forEach(function(key){
          self.getObj(parseInt(key, 10)).texture = undefined; 
          });
      this.gl = null;
    };

    /**
     * Initialize the WebGL canvas
     */
    rglwidgetClass.prototype.initCanvas = function() {
      this.restartCanvas();
      var objs = this.scene.objects,
          self = this;
          
      /* These hold context specific data.  In Shiny, they   
         need to be deleted.  Elsewhere, they don't exist
         and these are no-ops. */
         
      delete this.cube;
      delete this.sphere;
      
      Object.keys(objs).forEach(function(key){
        self.initSubscene(parseInt(key, 10));
      });

      this.onContextRestored = function() {
        self.initGL();
        self.drawScene();
      };

      this.onContextLost = function(event) {
        if (!self.drawing)
          this.gl = null;
        event.preventDefault();
      };

      this.initGL0();
      this.lazyLoadScene = function() {
      	if (typeof self.slide === "undefined")
      	  self.slide = self.getSlide();
      	if (self.isInBrowserViewport()) {
      	  if (!self.gl || self.gl.isContextLost())
      	    self.initGL();
      	  self.drawScene();
      	}
      };
      window.addEventListener("DOMContentLoaded", this.lazyLoadScene, false);
      window.addEventListener("load", this.lazyLoadScene, false);
      window.addEventListener("resize", this.lazyLoadScene, false);
      window.addEventListener("scroll", this.lazyLoadScene, false);
      this.slide = this.getSlide();
      if (this.slide) {
        if (typeof this.slide.rgl === "undefined")
          this.slide.rgl = [this];
        else
          this.slide.rgl.push(this);
        if (this.scene.context.rmarkdown) 
          if (this.scene.context.rmarkdown === "ioslides_presentation") {
            this.slide.setAttribute("slideenter", "this.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window);})");
          } else if (this.scene.context.rmarkdown === "slidy_presentation") {
            // This method would also work in ioslides, but it gets triggered
            // something like 5 times per slide for every slide change, so
            // you'd need a quicker function than lazyLoadScene.
            var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
            observer = new MutationObserver(function(mutations) {
              mutations.forEach(function() {
                self.slide.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window); });});});
            observer.observe(this.slide, { attributes: true, attributeFilter:["class"] });
          }
      }
    };
</script>
<script>/**
 * Methods related to drawing transparent objects
 * @name ___METHODS_FOR_TRANSPARENCY___
 * @memberof rglwidgetClass
 * @kind function
 * @instance

 * These functions order the centers of displayed objects so they
 * can be drawn using the painters algorithm, necessary to support
 * transparency.  

 * Note that objid is not obj.id when drawing spheres.
 */

/**
 * Break objects into pieces
 * @returns { array } Array of pieces
 */
    rglwidgetClass.prototype.getPieces = function(context, objid, subid, obj) {
      var n = obj.centers.length,
          depth,
          result = new Array(n),
          z, w, i;
      context = context.slice();
          
      for(i=0; i<n; i++) {
        z = this.prmvMatrix.m13*obj.centers[i][0] +
            this.prmvMatrix.m23*obj.centers[i][1] +
            this.prmvMatrix.m33*obj.centers[i][2] +
            this.prmvMatrix.m43;
        w = this.prmvMatrix.m14*obj.centers[i][0] +
            this.prmvMatrix.m24*obj.centers[i][1] +
            this.prmvMatrix.m34*obj.centers[i][2] +
            this.prmvMatrix.m44;
        depth = z/w;
        result[i] = {context: context, 
                     objid: objid,
                     subid: subid,
                     index: i, 
                     depth: depth};
      }
      return result;    
    };
    
    /**
     * Get pieces from sphere
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getSpherePieces = function(context, subid, obj)
    {
      if (obj.fastTransparency) 
        if (subid === 0) // Only compute pieces once
          return this.getPieces(context, obj.id, -1, obj);
        else
          return [];
      else
        return this.getPieces(context, obj.id, subid, this.sphere);
    };
    
   /**
     * Get pieces from cube
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getCubePieces = function(context, obj)
    {
      return this.getPieces(context, obj.id, 0, this.cube);
    };
    
    /**
     * Merge pieces that can be drawn in one call
     * @returns { object }
     * @param { array } pieces - The pieces to merge
     */
    rglwidgetClass.prototype.mergePieces = function(pieces) {
      var result = [];
      if (pieces.length > 0) {
        var i,
          thiscontext = pieces[0].context, 
          thisobjid = pieces[0].objid, 
          thissubid = pieces[0].subid,
          indices = [];
        for (i= 0; i < pieces.length; i++) {
          if (pieces[i].context !== thiscontext || 
              pieces[i].objid !== thisobjid ||
              pieces[i].subid !== thissubid) {
            result.push({context: thiscontext, objid: thisobjid,
                         subid: thissubid, indices: indices});
            thiscontext = pieces[i].context;
            thisobjid = pieces[i].objid;
            thissubid = pieces[i].subid;
            indices = [];
          }
          indices.push(pieces[i].index);
        }
        result.push({context: thiscontext, objid: thisobjid,
                                subid: thissubid,
                                indices: indices});
      }
      return result;
    };

    /**
     * Sort pieces by depth
     * @returns { array }
     * @param { array } pieces - array of pieces 
     */
    rglwidgetClass.prototype.sortPieces = function(pieces) {
      var compare = function(i,j) {
        var diff = j.depth - i.depth;
        // We want to avoid context or obj changes,
        // so sort on those next.
        if (diff === 0) {
          var c1 = j.context.slice(),
              c2 = i.context.slice();
          diff = c1.length - c2.length; 
          while (diff === 0 && c1.length > 0) {
            diff = c1.pop() - c2.pop();
          }
          if (diff === 0)
            diff = j.objid - i.objid;
          if (diff === 0)
            diff = j.subid - i.subid;
        }
        return diff;
      }, result = [];
      if (pieces.length) 
        result = pieces.sort(compare);
      return result;
    };
</script>
<script>    /**
     * Methods related to drawing
     * @name ___METHODS_FOR_DRAWING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start drawing
     * @returns { boolean } Previous state
     */
    rglwidgetClass.prototype.startDrawing = function() {
    	var value = this.drawing;
    	this.drawing = true;
    	return value;
    };

    /**
     * Stop drawing and check for context loss
     * @param { boolean } saved - Previous state
     */
    rglwidgetClass.prototype.stopDrawing = function(saved) {
      this.drawing = saved;
      if (!saved && this.gl && this.gl.isContextLost())
        this.restartCanvas();
    };

    /**
     * Update the triangles used to display a plane
     * @param { number } id - id of the plane
     * @param { Object } bbox - bounding box in which to display the plane
     */
    rglwidgetClass.prototype.planeUpdateTriangles = function(obj, bbox) {
      var perms = [[0,0,1], [1,2,2], [2,1,0]],
          x, xrow, elem, A, d, nhits, i, j, k, u, v, w, intersect, which, v0, v2, vx, reverse,
          face1 = [], face2 = [], normals = [],
          nPlanes = obj.normals.length, idx, center;
      obj.bbox = bbox;
      obj.vertices = [];
      obj.centers = [];
      obj.initialized = false;
      for (elem = 0; elem < nPlanes; elem++) {
//    Vertex Av = normal.getRecycled(elem);
        x = [];
        A = obj.normals[elem];
        d = obj.offsets[elem][0];
        nhits = 0;
        for (i=0; i<3; i++)
          for (j=0; j<2; j++)
            for (k=0; k<2; k++) {
              u = perms[0][i];
              v = perms[1][i];
              w = perms[2][i];
              if (A[w] !== 0.0) {
                intersect = -(d + A[u]*bbox[j+2*u] + A[v]*bbox[k+2*v])/A[w];
                if (bbox[2*w] < intersect && intersect < bbox[1+2*w]) {
                  xrow = [];
                  xrow[u] = bbox[j+2*u];
                  xrow[v] = bbox[k+2*v];
                  xrow[w] = intersect;
                  x.push(xrow);
                  face1[nhits] = j + 2*u;
                  face2[nhits] = k + 2*v;
                  nhits++;
                }
              }
            }

            if (nhits > 3) {
            /* Re-order the intersections so the triangles work */
              for (i=0; i<nhits-2; i++) {
                which = 0; /* initialize to suppress warning */
                for (j=i+1; j<nhits; j++) {
                  if (face1[i] === face1[j] || face1[i] === face2[j] ||
                      face2[i] === face1[j] || face2[i] === face2[j] ) {
                    which = j;
                    break;
                  }
                }
                if (which > i+1) {
                  rglwidgetClass.swap(x, i+1, which);
                  rglwidgetClass.swap(face1, i+1, which);
                  rglwidgetClass.swap(face2, i+1, which);
                }
              }
            }
            if (nhits >= 3) {
      /* Put in order so that the normal points out the FRONT of the faces */
              v0 = [x[0][0] - x[1][0] , x[0][1] - x[1][1], x[0][2] - x[1][2]];
              v2 = [x[2][0] - x[1][0] , x[2][1] - x[1][1], x[2][2] - x[1][2]];
              /* cross-product */
              vx = rglwidgetClass.xprod(v0, v2);
              reverse = rglwidgetClass.dotprod(vx, A) > 0;

              for (i=0; i<nhits-2; i++) {
                obj.vertices.push(x[0]);
                center = [];
                for (k = 0; k<3; k++)
                  center.push(x[0][k]/3);
                normals.push(A);
                for (j=1; j<3; j++) {
                  idx = i + (reverse ? 3-j : j);
                  obj.vertices.push(x[idx]);
                  for (k=0; k<3; k++)
                    center[k] += x[idx][k]/3;
                  normals.push(A);
                }
                obj.centers.push(center);
              }
            }
      }
      obj.pnormals = normals;
    };
    
    rglwidgetClass.prototype.mode4type = {points : "POINTS",
                     linestrip : "LINE_STRIP",
                     abclines : "LINES",
                     lines : "LINES",
                     sprites : "TRIANGLES",
                     planes : "TRIANGLES",
                     text : "TRIANGLES",
                     quads : "TRIANGLES",
                     surface : "TRIANGLES",
                     triangles : "TRIANGLES",
                     sphere : "TRIANGLES"
    };
    
    /**
     * Disable unused arrays
     * @param { Object } obj - Object to work with
     * @param { Array } enabled - Array indicating which are enabled
     */
    rglwidgetClass.prototype.disableArrays = function(obj, enabled) {
      var gl = this.gl || this.initGL(),
          objLocs = ["normLoc", "texLoc", "ofsLoc", "pointLoc", "nextLoc"],
          thisLocs = ["posLoc", "colLoc"], i, attr;
      for (i = 0; i < objLocs.length; i++) 
        if (enabled[objLocs[i]]) gl.disableVertexAttribArray(obj[objLocs[i]]);
      for (i = 0; i < thisLocs.length; i++)
        if (enabled[thisLocs[i]]) gl.disableVertexAttribArray(this[objLocs[i]]);
      if (typeof obj.userAttributes !== "undefined") {
      	for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.disableVertexAttribArray( obj.userAttribLocations[attr] );
      	}
      }
    };

    /**
     * Start drawing the scene
     */    
    rglwidgetClass.prototype.doStartScene = function() {
      var gl = this.gl || this.initGL();
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearDepth(1.0);
      gl.clearColor(1,1,1,1);
      gl.depthMask(true); // Must be true before clearing depth buffer
      /* jshint bitwise: false */
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      /* jshint bitwise: true */
    };
    
    /**
     * Set gl depth test based on object's material
     * @param { Object } obj - object to use
     */
    rglwidgetClass.prototype.doDepthTest = function(obj) {
      var gl = this.gl,
          tests = {never: gl.NEVER,
                   less:  gl.LESS,
                   equal: gl.EQUAL,
                   lequal:gl.LEQUAL,
                   greater: gl.GREATER,
                   notequal: gl.NOTEQUAL,
                   gequal: gl.GEQUAL,
                   always: gl.ALWAYS},
           test = tests[this.getMaterial(obj, "depth_test")];
      gl.depthFunc(test);
    };    
    
    /**
     * Set polygon offset for an obj
     * @param { object } obj - object to use
     */
    rglwidgetClass.prototype.doPolygonOffset = function(obj) { 
      var gl = this.gl;
      if (typeof obj.polygon_offset !== "undefined") {
        gl.polygonOffset(obj.polygon_offset[0],
                          obj.polygon_offset[1]);
        gl.enable(gl.POLYGON_OFFSET_FILL);
      } else
        gl.disable(gl.POLYGON_OFFSET_FILL);
    };
    
    /**
     * Do code for clipping
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doClipping = function(obj, subscene) {
      var gl = this.gl,
          clipcheck = 0,
          clipplaneids = subscene.clipplanes,
          clip, i,j, n = this.countClipplanes(),
          clipplanedata; 
          
      if (n > 0) {
        clipplanedata = new Float32Array(4*n);
        for (i=0; i < clipplaneids.length; i++) {
          clip = this.getObj(clipplaneids[i]);
          for (j=0; j < clip.offsets.length; j++) {
            clipplanedata.set(clip.IMVClip[j], clipcheck);
            clipcheck += 4;
          }
        }
      
        // Leftovers are initialized to zero, which is fine
        gl.uniform4fv(obj.clipLoc, clipplanedata);
      }
    };
    
    /**
     * Do code for lighting
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doLighting = function(obj, subscene) {
    var gl = this.gl, i, j, n, light,
      ambient, specular, diffuse, lightDir, viewpoint, finite,
      ambient0, specular0;

      gl.uniform3fv( obj.emissionLoc, obj.emission);
      gl.uniform1f( obj.shininessLoc, obj.shininess);
      while ((typeof subscene.lights === "undefined" ||
              subscene.lights.length === 0) && 
             typeof subscene.parent !== "undefined")
        subscene = this.getObj(subscene.parent);

      if (typeof subscene.lights === "undefined")
        return;
        
      n = subscene.lights.length;
        
      ambient = new Float32Array(3*n);
      specular = new Float32Array(3*n);
      diffuse = new Float32Array(3*n);
      lightDir = new Float32Array(3*n);
      viewpoint = new Int32Array(n);
      finite = new Int32Array(n);
          
      for (i=0; i < n; i++) {
        light = this.getObj(subscene.lights[i]);
        if (!light.initialized) this.initObj(light);
        ambient0 = this.componentProduct(light.ambient, obj.ambient);
        specular0 = this.componentProduct(light.specular, obj.specular);
        for (j=0; j < 3; j++) {
          ambient[3*i + j] = ambient0[j];
          specular[3*i + j] = specular0[j];
          diffuse[3*i + j] = light.diffuse[j];
          lightDir[3*i + j] = light.lightDir[j];
        }
        viewpoint[i] = light.viewpoint;
        finite[i] = light.finite;
      }
        
      for (i = n; i < obj.nlights; i++) {
        for (j = 0; j < 3; j++) {
          ambient[3*i + j] = 0.0;
          specular[3*i + j] = 0.0;
          diffuse[3*i + j] = 0.0;
        }
      }
        
      gl.uniform3fv( obj.ambientLoc, ambient);
      gl.uniform3fv( obj.specularLoc, specular);
      gl.uniform3fv( obj.diffuseLoc, diffuse);
      gl.uniform3fv( obj.lightDirLoc, lightDir);
      gl.uniform1iv( obj.viewpointLoc, viewpoint);
      gl.uniform1iv( obj.finiteLoc, finite);
    };
    
    /**
     * Do code for colors
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doColors = function(obj) {
      var gl = this.gl;
      if (obj.colorCount === 1) {
        gl.disableVertexAttribArray( this.colLoc );
        gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
        return false;
      } else {
        gl.enableVertexAttribArray( this.colLoc );
        gl.vertexAttribPointer(this.colLoc, 4, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.cofs);
        return true;
      }
    };
    
    /**
     * Do code for normals
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormals = function(obj) {
      var gl = this.gl;
      if (obj.vOffsets.nofs >= 0) {
        gl.enableVertexAttribArray( obj.normLoc );
        gl.vertexAttribPointer(obj.normLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nofs);
        return true;
      } else
        return false;
    };
    
    /**
     * Do code for vNormal
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormMat = function(obj) {
      var gl = this.gl;
        
      gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(this.normMatrix.getAsArray()) );
    };
    
    /**
     * Do code for textures
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doTexture = function(obj) {
      var gl = this.gl, 
          is_sphere = obj.type === "sphere";
        gl.enableVertexAttribArray( obj.texLoc );
        if (is_sphere)
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*this.sphere.vOffsets.stride, 4*this.sphere.vOffsets.tofs);
        else
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.tofs);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.uniform1i( obj.sampler, 0);
        return true;
    };
    
    /**
     * Do code for user attributes
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserAttributes = function(obj) {
      if (typeof obj.userAttributes !== "undefined") {
        var gl = this.gl;
      	for (var attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.enableVertexAttribArray( obj.userAttribLocations[attr] );
      	  gl.vertexAttribPointer( obj.userAttribLocations[attr], obj.userAttribSizes[attr],
      	  			  gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.userAttribOffsets[attr]);
      	}
      }
    };

    /**
     * Do code for user uniforms
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserUniforms = function(obj) {
      var gl = this.gl, attr;
      if (typeof obj.userUniforms !== "undefined") {
      	for (attr in obj.userUniformLocations) {
      	  var loc = obj.userUniformLocations[attr];
      	  if (loc !== null) {
      	    var uniform = obj.userUniforms[attr];
      	    if (typeof uniform !== "undefined") {
      	      var dim = rglwidgetClass.arrayDim(uniform);
      	      if (dim.length === 0)
      	        gl.uniform1f(loc, uniform);
      	      else if (dim.length === 1) {
      	        uniform = new Float32Array(uniform);
      	        switch(uniform.length) {
      	      	  case 2: gl.uniform2fv(loc, uniform); break;
      	      	  case 3: gl.uniform3fv(loc, uniform); break;
      	      	  case 4: gl.uniform4fv(loc, uniform); break;
      	      	  default: console.warn("bad uniform length");
      	        }
      	      } else if (dim.length === 2 && dim[0] === 4 && dim[1] === 4)
      	        gl.uniformMatrix4fv(loc, false, new Float32Array(rglwidgetClass.flatten(uniform)));
      	      else if (dim.length === 2) {
      	        uniform = new Float32Array(rglwidgetClass.flatten(uniform));
      	        switch(dim[[1]]) {
      	          case 1: gl.uniform1fv(loc, uniform); break;
      	          case 2: gl.uniform2fv(loc, uniform); break;
      	          case 3: gl.uniform3fv(loc, uniform); break;
      	          case 4: gl.uniform4fv(loc, uniform); break;
      	          default: console.warn("bad uniform column count");
      	        }
      	      } else
      	        console.warn("unsupported uniform shape");
      	    }
      	  }
      	}
      }
      if (typeof obj.userTextures !== "undefined") {
        var has_texture = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_has_texture),
              texnum = has_texture - 1;
        for (attr in obj.userTextures) {
      	  var texture = obj.userTextures[attr];
      	  if (texture.sampler !== null) {
      	    texnum += 1;
      	    gl.activeTexture(gl.TEXTURE0 + texnum);
            gl.bindTexture(gl.TEXTURE_2D, texture.texture);
            gl.uniform1i( texture.sampler, texnum);
      	  }
      	}
      }
    };

    /**
     * Load indices for complex drawing
     * @param { object } obj - Object to work with
     * @param { numeric } pass - Which pass of drawing?
     * @param { array } indices - Indices to draw
     */    
    rglwidgetClass.prototype.doLoadIndices = function(obj, pass, indices) {
      var gl = this.gl,
          f = obj.f[pass],
          type = obj.type,
          fat_lines = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_fat_lines),
          fnew, step;
      switch(type){
        case "points":
          step = 1;
          break;
        case "abclines":
        case "lines":
          if (fat_lines)
            step = 6;
          else
            step = 2;
          break;
        case "linestrip":
          if (fat_lines)
            step = 6;
          else
            step = 1;
          break;
        case "sphere":
        case "planes":
        case "triangles":
          step = 3;
          break;
        case "text":
        case "sprites":
        case "quads":
        case "surface":
          step = 6;
          break;
        default:
          console.error("loadIndices for "+type);
          return 0;
      }
      if (obj.index_uint)
        fnew = new Uint32Array(step * indices.length);
      else
        fnew = new Uint16Array(step * indices.length);
      for (var i = 0; i < indices.length; i++) {
        for (var j = 0; j < step; j++) {
          fnew[step*i + j] = f[step*indices[i] + j];
        }
      }
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fnew, gl.DYNAMIC_DRAW);
      return fnew.length;
    };

    /**
     * Do code for depth masking
     * @param { boolean } mask - whether to mask
     */
    rglwidgetClass.prototype.doMasking = function(mask) {
      var gl = this.gl;
      gl.depthMask(mask);
    };

    /**
     * Do code for alpha blending
     * @param { boolean }  blend - Whether to blend.
     * @param { integer }  objid - Object id
     */    
    rglwidgetClass.prototype.doBlending = function(blend, objid) {
      var gl = this.gl, blendfunc, obj, 
        blends =  {zero: gl.ZERO,
                   one:  gl.ONE,
                   src_color: gl.SRC_COLOR,
                   one_minus_src_color: gl.ONE_MINUS_SRC_COLOR,
                   dst_color: gl.DST_COLOR,
                   one_minus_dst_color: gl.ONE_MINUS_DST_COLOR,
                   src_alpha: gl.SRC_ALPHA,
                   one_minus_src_alpha: gl.ONE_MINUS_SRC_ALPHA,
                   dst_alpha: gl.DST_ALPHA,
                   one_minus_dst_alpha: gl.ONE_MINUS_DST_ALPHA,
                   constant_color: gl.CONSTANT_COLOR,
                   one_minus_constant_color: gl.ONE_MINUS_CONSTANT_COLOR,
                   constant_alpha: gl.CONSTANT_ALPHA,
                   one_minus_constant_alpha: gl.ONE_MINUS_CONSTANT_ALPHA,
                   src_alpha_saturate: gl.SRC_ALPHA_SATURATE};
      if (blend) {
        obj = this.getObj(objid);
        blendfunc = this.getMaterial(obj, "blend");
        gl.blendFuncSeparate(blends[blendfunc[0]],
                             blends[blendfunc[1]],
                             gl.ONE, gl.ONE);
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
    };
    
    /**
     * Set up for fog in the subscene
     * @param { object } obj - background object
     * @param { object } subscene - which subscene
     */
    rglwidgetClass.prototype.doFog = function(obj, subscene) {
      var gl = this.gl, fogmode, color, 
          observer = subscene.par3d.observer[2],
          sintheta = Math.sin(subscene.par3d.FOV*Math.PI/180/2),
          parms = [this.frustum.near - 2*observer,
                   this.frustum.far - 2*observer,
                   this.fogScale,
                   (1-sintheta)/(1+sintheta)];
      if (typeof this.fogType === "undefined")
        this.fogType = "none";
      if (typeof this.fogScale === "undefined")
        parms[2] = 1;
      if (sintheta === 0)
        parms[3] = 1/3;
      switch(this.fogType){
        case "none": fogmode = 0; break;
        case "linear": 
          fogmode = 1; break;
        case "exp":  
          fogmode = 2; break;
        case "exp2": 
          fogmode = 3;
          break;
        default: console.error("Unknown fogtype "+this.fogType);
      }
      gl.uniform1i(obj.uFogMode, fogmode);
      color = this.fogColor;
      gl.uniform3f(obj.uFogColor, color[0], color[1], color[2]);
      gl.uniform4f(obj.uFogParms, parms[0], parms[1], parms[2], parms[3]);
    };

    /* The draw methods are called twice.  When 
       this.opaquePass is true, they should draw opaque parts
       of the scene, and return the list of transparent
       pieces.  Here context is the context array on input,
       modified when the matrices are changed.
       When this.opaquePass is false, the context argument
       contains a "piece", i.e. an ordered list of parts
       of the object to draw. */

    /**
     * Draw simple object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */       
    rglwidgetClass.prototype.drawSimple = function(obj, subscene, context) {
      var 
          fl,
          is_transparent,
          type = obj.type,
          gl = this.gl || this.initGL(),
          count,
          pass, mode, pmode,
          enabled = {};
        
      if (!obj.initialized)
        this.initObj(obj);
        
      if (this.texturesLoading)
        return[];

      count = obj.vertexCount;
      if (!count)
        return [];
    
      fl = obj.defFlags;
      is_transparent = fl.is_transparent || obj.someHidden;
      
      if (is_transparent && this.opaquePass)
        return this.getPieces(context, obj.id, 0, obj);

      this.doDepthTest(obj);
      
      this.doMasking(this.getMaterial(obj, "depth_mask"));
            
      gl.useProgram(obj.prog);

      this.doPolygonOffset(obj);

      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);

      gl.uniformMatrix4fv( obj.prMatLoc, false, new Float32Array(this.prMatrix.getAsArray()) );
      gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(this.mvMatrix.getAsArray()) );

      this.doClipping(obj, subscene);

      if (fl.needs_vnormal)
        this.doNormMat(obj);
        
      if (fl.is_lit)
        this.doLighting(obj, subscene);

      if (fl.has_fog)
        this.doFog(obj, subscene);

      this.doUserAttributes(obj);

      this.doUserUniforms(obj);
 
      gl.enableVertexAttribArray( this.posLoc );
      enabled.posLoc = true;
        
      if (fl.has_texture || obj.type === "text")
        enabled.texLoc = this.doTexture(obj);

      enabled.colLoc = this.doColors(obj);
      enabled.normLoc = this.doNormals(obj);

      if (fl.fixed_size) {
        gl.uniform3f( obj.textScaleLoc, 0.75/this.vp.width, 0.75/this.vp.height, 1.0);
      }
      
      if (fl.fixed_quads) {
        gl.enableVertexAttribArray( obj.ofsLoc );
        enabled.ofsLoc = true;
        gl.vertexAttribPointer(obj.ofsLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.oofs);
      }

      for (pass = 0; pass < obj.passes; pass++) {
      	pmode = obj.pmode[pass];
        if (pmode === "culled")
          continue;

      	mode = fl.fat_lines && (fl.is_lines || pmode === "lines") ? "TRIANGLES" : this.mode4type[type];

      	if (fl.is_twosided) {
      	  gl.uniform1i(obj.frontLoc, pass !== 0);
      	  if (fl.has_normals) {
      	    gl.uniformMatrix4fv(obj.invPrMatLoc, false, new Float32Array(this.invPrMatrix.getAsArray()));
      	  }
      	}

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
        if (!this.opaquePass) {
          if (type === "sphere" && obj.fastTransparency)
            count = this.doLoadIndices(obj, pass, this.sphere.fastpieces[0].indices);
          else
            count = this.doLoadIndices(obj, pass, context.indices);
        } else {
          count = obj.f[pass].length;
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[pass], gl.STATIC_DRAW);
        }
      	if (!fl.is_lines && pmode === "lines" && !fl.fat_lines) {
          mode = "LINES";
        } else if (pmode === "points") {
          mode = "POINTS";
        }
                          
        if ((fl.is_lines || pmode === "lines") && fl.fat_lines) {
          gl.enableVertexAttribArray(obj.pointLoc);
          enabled.pointLoc = true;
          gl.vertexAttribPointer(obj.pointLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.pointofs);
          gl.enableVertexAttribArray(obj.nextLoc );
          enabled.nextLoc = true;
          gl.vertexAttribPointer(obj.nextLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nextofs);
          gl.uniform1f(obj.aspectLoc, this.vp.width/this.vp.height);
          gl.uniform1f(obj.lwdLoc, this.getMaterial(obj, "lwd")/this.vp.height);
        }

        gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*obj.vOffsets.stride,  4*obj.vOffsets.vofs);

        gl.drawElements(gl[mode], count, obj.index_uint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);
      }
      this.disableArrays(obj, enabled);
      return [];
    };

    /**
     * Draw planes object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */      
    rglwidgetClass.prototype.drawPlanes = function(obj, subscene, context) {
      if (this.opaquePass && (obj.bbox !== subscene.par3d.bbox || !obj.initialized)) {
          this.planeUpdateTriangles(obj, subscene.par3d.bbox);
      }
      return this.drawSimple(obj, subscene, context);
   };

    /**
     * @param { object } obj - object to draw
     * @param { object } subscene 
     * @param { array } context 
     * @description
     * Draw spheres in a subscene<br>
     * 
     * Drawing spheres happens in six ways:<br>
     * 1 opaquepass, not transparent:  transform and draw this.sphere count times<br>
     * 2 opaquepass, transparent, not fast: transform & collect sphere pieces count times<br>
     * 3 opaquepass, transparent, fast:  order the centres into separate pieces, order this.sphere once<br>
     * 4 not opaquepass, not transparent:  do nothing<br>
     * 5 not opaquepass, transparent, not fast:  transform for one sphere, draw one merged piece<br>
     * 6 not opaquepass, transparent, fast:  transform for one sphere, draw this.sphere in fixed order.<br>
     **/

    rglwidgetClass.prototype.drawSpheres = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sphereMV, baseofs, ofs, sscale, i,
          count, nc, scount, scale, indices, sphereNorm,
          enabled = {}, drawing,
          saveNorm = new CanvasMatrix4(this.normMatrix),
          saveMV = new CanvasMatrix4(this.mvMatrix),
          savePRMV = null,
          result = [], idx, margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!obj.initialized)
        this.initObj(obj);

      count = obj.vertexCount;
      if (!count) 
        return [];
        
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return [];
        
      if (this.prmvMatrix !== null)
        savePRMV = new CanvasMatrix4(this.prmvMatrix);
      
      scale = subscene.par3d.scale;        
      sphereNorm = new CanvasMatrix4();
      sphereNorm.scale(scale[0], scale[1], scale[2]);
      sphereNorm.multRight(saveNorm);
      this.normMatrix = sphereNorm;

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      if (drawing) {
        nc = obj.colorCount;
        if (nc === 1) {
          this.sphere.onecolor = obj.onecolor;
        }
      }
      
      this.initShapeFromObj(this.sphere, obj);

      if (!this.opaquePass && obj.fastTransparency && typeof this.sphere.fastpieces === "undefined") {
        this.sphere.fastpieces = this.getPieces(context.context, obj.id, 0, this.sphere);
        this.sphere.fastpieces = this.sortPieces(this.sphere.fastpieces);
        this.sphere.fastpieces = this.mergePieces(this.sphere.fastpieces);
      }

      if (this.opaquePass)
        scount = count;
      else {
        indices = context.indices;
        if (obj.fastTransparency)
          scount = indices.length;  /* Each item gives the center of a whole sphere */
        else
          scount = 1;               /* Each item is a fragment of the sphere, at location subid */
      }
      for (i = 0; i < scount; i++) {
        sphereMV = new CanvasMatrix4();
        if (this.opaquePass)
          idx = i;
        else if (obj.fastTransparency)
          idx = indices[i];
        else
          idx = context.subid;
        if (typeof idx === "undefined")
          console.error("idx is undefined");
        baseofs = idx*obj.vOffsets.stride;
        ofs = baseofs + obj.vOffsets.radofs;
        sscale = obj.values[ofs];

        sphereMV.scale(sscale/scale[0], sscale/scale[1], sscale/scale[2]);
        sphereMV.translate(obj.values[baseofs],
                             obj.values[baseofs+1],
                             obj.values[baseofs+2]);
        sphereMV.multRight(saveMV);
        this.mvMatrix = sphereMV;
        this.setnormMatrix2();
        this.setprmvMatrix();
        if (drawing) {
          if (nc > 1) {
            this.sphere.onecolor = obj.values.slice(baseofs + obj.vOffsets.cofs, baseofs + obj.vOffsets.cofs + 4);
          }
          this.drawSimple(this.sphere, subscene, context);
        } else 
          result = result.concat(this.getSpherePieces(context, i, obj));
      }
      if (drawing)
        this.disableArrays(obj, enabled);
      this.normMatrix = saveNorm;
      this.mvMatrix = saveMV;
      this.prmvMatrix = savePRMV;
        
      return result;
    };
    
    /**
     * Prepare clipplanes for drawing
     * @param { object } obj - clip planes object
     */
    rglwidgetClass.prototype.drawClipplanes = function(obj) {
      var count = obj.offsets.length,
        IMVClip = [];
      for (var i=0; i < count; i++) {
        IMVClip[i] = rglwidgetClass.multMV(this.invMatrix, obj.vClipplane.slice(4*i, 4*(i+1)));
      }
      obj.IMVClip = IMVClip;
      return [];
    };

    /**
     * Prepare linestrip for drawing
     * @param { object } obj - line strip object
     * @param { object } subscene 
     * @param { array } context 
     */    
    rglwidgetClass.prototype.drawLinestrip = function(obj, subscene, context) {
      var origIndices, i, j, margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      if (this.opaquePass)
        return this.drawSimple(obj, subscene, context);
      origIndices = context.indices.slice();
      for (i=0; i < origIndices.length; i++) {
        j = origIndices[i];
        if (j < obj.centers.length - 1) {
          context.indices = [j, j+1];
          this.drawSimple(obj, subscene, context);
        }
      }
      context.indices = origIndices;
      return [];
    };
          
    /**
     * Draw a sprites object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { object } context
     */
    rglwidgetClass.prototype.drawSprites = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sprites3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size),
          rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating),
          i,j,
          origMV = new CanvasMatrix4( this.mvMatrix ),
          origPRMV = null,
          origPR,
          pos, radius, userMatrix,
          result = [], margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!sprites3d) 
        return this.drawSimple(obj, subscene, context);
      
      if (!obj.initialized)
        this.initObj(obj);

      if (!obj.vertexCount)
        return [];
    
      is_transparent = is_transparent || obj.someHidden;
      
      var norigs = obj.vertices.length,
          savenorm = new CanvasMatrix4(this.normMatrix),
          iOrig, adj, offset;

      userMatrix = obj.userMatrix;
                   
      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } else
        norigs = 1;
          
      if (this.prmvMatrix !== null)
         origPRMV = new CanvasMatrix4( this.prmvMatrix );

      offset = obj.offset;
      
      if (fixed_size && !rotating) {
        origPR = this.prMatrix;
        this.prMatrix = new CanvasMatrix4();
      }
        
      for (iOrig=0; iOrig < norigs; iOrig++) {
        if (this.opaquePass)
          j = iOrig;
        else
          j = context.subid;
        pos = [].concat(obj.vertices[j]).concat(1.0);
        radius = obj.radii.length > 1 ? obj.radii[j][0] : obj.radii[0][0];
        this.mvMatrix = new CanvasMatrix4(userMatrix);
        adj = this.getAdj(obj, j, offset);
        this.mvMatrix.translate(1 - 2*adj[0], 1 - 2*adj[1], 1 - 2*adj[2]);
        this.mvMatrix.scale(radius, radius, radius);
        
        if (fixed_size) {
          var viewport = subscene.par3d.viewport,
            winwidth = viewport.width*this.canvas.width,
            winheight = viewport.height*this.canvas.height,
            scalex = 27/winwidth, scaley = 27/winheight,
              scale = Math.sqrt(scalex * scaley);
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            pos = rglwidgetClass.multVM(pos, origPR);
            this.mvMatrix.scale(scalex, scaley, scale);
          } else {
            scale = 4.0 * scale * subscene.par3d.zoom;
            this.mvMatrix.scale(scale, scale, scale);
          }
          this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          if (rotating)
            this.mvMatrix.multRight(origMV);
        } else {
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          } else {
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
            this.mvMatrix.multRight(origMV);
          }
        }
        this.setnormMatrix2();
        this.setprmvMatrix();
      
        for (i=0; i < obj.objects.length; i++)
          if (this.opaquePass)
            result = result.concat(this.drawObjId(obj.objects[i], subscene.id, context.concat(j)));
          else
            this.drawObjId(obj.objects[i], subscene.id, context);
      }
      this.normMatrix = savenorm;
      this.mvMatrix = origMV;
      if (fixed_size && !rotating)
        this.prMatrix = origPR;
      if (origPRMV !== null)
        this.prmvMatrix = origPRMV;
      return result;
    };
    
    /**
     * Draw object that might be in margin
     * @param { Object } obj - text object to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawMarginal = function(obj, subscene, context) {
      var margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      return this.drawSimple(obj, subscene, context);
    };
    
    /**
     * Draw bounding box and decorations
     * @param { Object } obj - bboxdeco to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawBBox = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          scale, bbox, indices,
          enabled = {}, drawing,
          result = [], idx, center, edges,
          saved;

      if (!obj.initialized)
        this.initBBox(obj);
      
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return result;
      
      this.setBbox(obj, subscene);
      
      saved = this.setBBoxMatrices(obj);
      
      bbox = obj.bbox;
      center = obj.center;

      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];

      if (!obj.cube.initialized) {
        this.initObj(obj.cube);
      }

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      this.cube.onecolor = obj.cube.onecolor;
      this.initShapeFromObj(this.cube, obj.cube);

      if (!this.opaquePass)
        indices = context.indices;

      if (this.opaquePass)
        idx = 0;
      else
        idx = context.subid;
      if (typeof idx === "undefined")
        console.error("idx is undefined");

      if (drawing) {
        this.drawSimple(this.cube, subscene, context);
      } else 
        result = result.concat(this.getCubePieces(context, obj));

      if (!obj.ticks.initialized) {
        obj.ticks.locations = this.getTickLocations(obj);
        obj.ticks.edges = undefined;
      }
      edges = this.getTickEdges(this.prmvMatrix);
      if (obj.needsAxisCallback) 
        this.doAxisCallback(obj, edges);
      if (!obj.ticks.edges || edges.toString() !== obj.ticks.edges.toString()) {
        obj.ticks.edges = edges;
        this.getTickVertices(obj.ticks);
        this.placeTickLabels(obj);
        this.setTickLabels(obj);
      }
      if (!obj.ticks.initialized) {
        this.initObj(obj.ticks);
        this.initObj(obj.labels);
      }
        
      if (drawing) {
        this.drawSimple(obj.ticks, subscene, context);
        this.drawSimple(obj.labels, subscene, context);

        this.disableArrays(obj, enabled);
      } else {
        result = result.concat(this.drawSimple(obj.ticks, subscene, context));
        result = result.concat(this.drawSimple(obj.labels, subscene, context));
      }

      this.restoreBBoxMatrices(saved);
        
      return result;
    };
    
    /**
     * Use ids to choose object to draw
     * @param { numeric } id - object to draw
     * @param { numeric } subscene
     * @param { array } context
     */   
    rglwidgetClass.prototype.drawObjId = function(id, subsceneid, context) {
      if (typeof id !== "number")
        this.alertOnce("drawObjId id is "+typeof id);

      return this.drawObj(this.getObj(id), this.getObj(subsceneid), context);
   };
   
    /**
     * Draw an object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { array } context
     */
    rglwidgetClass.prototype.drawObj = function(obj, subscene, context) {
      switch(obj.type) {
        case "abclines":
        case "surface":
          return this.drawSimple(obj, subscene, context);
        case "points":
        case "lines":  
        case "triangles":
        case "quads":
        case "text":
          return this.drawMarginal(obj, subscene, context);
        case "linestrip":
          return this.drawLinestrip(obj, subscene, context);
        case "planes":
          return this.drawPlanes(obj, subscene, context);
        case "spheres":
          return this.drawSpheres(obj, subscene, context);
        case "clipplanes":
          return this.drawClipplanes(obj);
        case "sprites":
          return this.drawSprites(obj, subscene, context);
        case "light":
          return [];
        case "bboxdeco":
          return this.drawBBox(obj, subscene, context);
      }
      
      console.error("drawObj for type = "+obj.type);
    };

    /**
     * Draw the background for a subscene
     * @param { number } id - id of background object
     * @param { number } subsceneid - id of subscene
     */
    rglwidgetClass.prototype.drawBackground = function(id, subsceneid, context) {
      var gl = this.gl || this.initGL(),
          obj = this.getObj(id),
          subscene,
          bg, i, savepr, saveinvpr, savemv, savenorm, m, bbox, result = [], 
          savedm = gl.getParameter(gl.DEPTH_WRITEMASK),
          savedt = gl.isEnabled(gl.DEPTH_TEST),
          saveblend = gl.isEnabled(gl.BLEND);

      if (!obj.initialized)
        this.initObj(obj);

      if (obj.colors.length) {
        bg = obj.colors[0];
        gl.depthMask(true);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.fogColor = bg;
      } else {
        this.fogColor = [0,0,0,0];
        obj.colors = [[0,0,0,0]];
      }
  
      this.fogType = obj.fogtype;
      this.fogScale = obj.fogscale;
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      if (typeof obj.quad !== "undefined") {
        savepr = this.prMatrix;
        saveinvpr = this.invPrMatrix;
        savemv = this.mvMatrix;
        this.prMatrix = new CanvasMatrix4();
        this.invPrMatrix = new CanvasMatrix4();
        this.mvMatrix = new CanvasMatrix4();
        for (i=0; i < obj.quad.length; i++)
          result = result.concat(this.drawObjId(obj.quad[i], subsceneid));
        this.prMatrix = savepr;
        this.invPrMatrix = saveinvpr;
        this.mvMatrix = savemv;

      } else if (obj.sphere) {
        subscene = this.getObj(subsceneid);
        savemv = this.mvMatrix;
        savenorm = this.normMatrix;
        bbox = subscene.par3d.bbox;
        var center = [(bbox[0] + bbox[1])/2, 
                  (bbox[2] + bbox[3])/2, 
                  (bbox[4] + bbox[5])/2, 1],
            scale = subscene.par3d.scale,
            ranges = [bbox[1] - bbox[0], 
                  bbox[3] - bbox[2],
                  bbox[5] - bbox[4]],
            avgscale = rglwidgetClass.vlen(ranges)/Math.sqrt(3),
            aspect = [ranges[0]*scale[0]/avgscale,
                      ranges[1]*scale[1]/avgscale,
                      ranges[2]*scale[2]/avgscale],
            maxaspect = Math.max(aspect[0], aspect[1], aspect[2]),
            zoom = subscene.par3d.zoom;
        m = new CanvasMatrix4();
        m.rotate(90, 1, 0, 0);
        m.scale(zoom*2.0*maxaspect*ranges[0]/aspect[0], 
                zoom*2.0*maxaspect*ranges[1]/aspect[1],
                zoom*2.0*maxaspect*ranges[2]/aspect[2]);
        m.translate(center[0], center[1], center[2]);
        m.multRight(savemv);
        center = rglwidgetClass.multVM(center, savemv);
        m.translate(-center[0], -center[1], -center[2]);
        m.scale(1, 1, 0.25/zoom);
        m.translate(center[0], center[1], center[2]);
        this.mvMatrix = m;
        this.initShapeFromObj(this.sphere, obj);
        this.sphere.onecolor = obj.colors.length > 1 ? obj.colors[1] : obj.colors[0];
        
        this.normMatrix = new CanvasMatrix4();
        
        this.setnormMatrix2();
        this.setprmvMatrix();
        
        result = result.concat(this.drawSimple(this.sphere, subscene, context));
        this.mvMatrix = savemv;
        this.normMatrix = savenorm;
      }
      gl.depthMask(savedm);
      if (savedt)
        gl.enable(gl.DEPTH_TEST);
      if (saveblend)
        gl.enable(gl.BLEND);
      return result;
    };

    /**
     * Draw a subscene
     * @param { number } subsceneid - id of subscene
     * @param { array } context 
     */
    rglwidgetClass.prototype.drawSubscene = function(subsceneid, context) {
      var sub = this.getObj(subsceneid),
          objects = this.scene.objects,
          clipids = sub.clipplanes,
          subids = sub.objects,
          subscene_has_faces = false,
          subscene_needs_sorting = false,
          flags, i, obj, result = [];
          
      if (sub.par3d.skipRedraw)
        return result;
      
      if (this.opaquePass) {
        for (i=0; i < subids.length; i++) {
      	  obj = objects[subids[i]];
          flags = obj.flags;
          if (typeof flags !== "undefined") {
            subscene_has_faces = subscene_has_faces || 
                            (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit) &&
                            !rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads));
            obj.is_transparent = obj.someHidden || 
              rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
            subscene_needs_sorting = subscene_needs_sorting || 
              obj.is_transparent ||
              rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort);
          }
        }
      }

      this.setViewport(subsceneid);

      this.setprMatrix(subsceneid);
      this.setInvPrMatrix();
      this.setmvMatrix(subsceneid);
      this.setnormMatrix2();
      this.setprmvMatrix();
      this.invMatrix = new CanvasMatrix4(this.mvMatrix);
      this.invMatrix.invert();
      
      if (this.opaquePass) {
        context = context.slice();
        context.push(subsceneid);
        
        this.doBlending(false);
        this.subsceneid = subsceneid;
        if (typeof this.sphere !== "undefined") // reset this.sphere.fastpieces; it will be recreated if needed
          this.sphere.fastpieces = undefined;
        if (typeof sub.backgroundId !== "undefined")
          result = result.concat(this.drawBackground(sub.backgroundId, subsceneid, context));
      }

      if (subids.length) {
            
        if (clipids.length > 0) {
          for (i = 0; i < clipids.length; i++)
            this.drawObjId(clipids[i], subsceneid);
        }
        
        subids = sub.opaque.concat(sub.transparent);
        if (this.opaquePass) {
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawObjId(subids[i], subsceneid, context));
          subids = sub.subscenes;
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawSubscene(subids[i], context));
        }
      }
      return result;
    };
    
    /**
     * Set the context for drawing transparently
     * @param { array } context
     */
    rglwidgetClass.prototype.setContext = function(context) {
      var result = [], objid, obj, type;
      context = context.slice();
      context.reverse();
      while (context.length > 0) {
        objid = context.pop();
        obj = this.getObj(objid);
        type = obj.type;
        switch (type) {
          case "subscene":
            this.drawSubscene(objid, false);
            break;
          case "sprites":
            result = result.concat(context.pop());
            break;
          case "spheres":
            // this.initSphereFromObj(obj);  // FIXME:  not needed?
            break;
          case "bboxdeco":
            result = result.concat(context.pop());
            break;
          default:
            console.error("bad type '", type, "' in setContext");
        }
      }
      return result;
    };
    
    /**
     * Draw the transparent pieces of a scene
     * @param {object} pieces
     */
    rglwidgetClass.prototype.drawPieces = function(pieces) {
      var i, prevcontext = [], context;
      for (i = 0; i < pieces.length; i++) {
        context = pieces[i].context.slice();
        if (context !== prevcontext) {
          prevcontext = context.slice();
          context = this.setContext(context);
          this.doBlending(true, pieces[i].objid);
        }
        this.drawObjId(pieces[i].objid, this.subsceneid, 
                       pieces[i]);
      }
    };
 
    /**
     * Draw the whole scene
     */
    rglwidgetClass.prototype.drawScene = function() {
      var wasDrawing = this.startDrawing(),
          pieces;
      if (!wasDrawing) {
        if (this.select.state !== "inactive")
          this.selectionChanged();

        this.doStartScene();
        this.opaquePass = true;
        pieces = this.drawSubscene(this.scene.rootSubscene, []);
        this.opaquePass = false;
        pieces = this.sortPieces(pieces);
        pieces = this.mergePieces(pieces);
        this.drawPieces(pieces);
      }
      this.stopDrawing(wasDrawing);
    };
</script>
<script>
    /**
     * Change the displayed subset
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The subset control data.
     */
    rglwidgetClass.prototype.subsetSetter = function(el, control) {
      if (typeof control.subscenes === "undefined" ||
          control.subscenes === null)
        control.subscenes = this.scene.rootSubscene;
      var value = Math.round(control.value),
          subscenes = [].concat(control.subscenes),
          fullset = [].concat(control.fullset),
          i, j, subsceneid,
          adds = [], deletes = [];
      if (rglwidgetClass.missing(value))
        value = control.value = 0;
      if (control.accumulate)
        for (i=0; i <= value; i++)
          adds = adds.concat(control.subsets[i]);
      else
        adds = adds.concat(control.subsets[value]);
      deletes = fullset.filter(function(x) { return adds.indexOf(x) < 0; });
      for (i = 0; i < subscenes.length; i++) {
        subsceneid = subscenes[i];
        if (typeof this.getObj(subsceneid) === "undefined")
          this.alertOnce("typeof object is undefined");
        for (j = 0; j < adds.length; j++)
          this.addToSubscene(adds[j], subsceneid);
        for (j = 0; j < deletes.length; j++)
          this.delFromSubscene(deletes[j], subsceneid);
      }
    };

    /**
     * Change the requested property
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The property setter control data.
     */
    rglwidgetClass.prototype.propertySetter = function(el, control)  {
      var value = control.value,
          values = [].concat(control.values),
          svals = [].concat(control.param),
          direct = values[0] === null,
          entries = [].concat(control.entries),
          ncol = entries.length,
          nrow = values.length/ncol,
          properties = rglwidgetClass.repeatToLen(control.properties, ncol),
          objids = rglwidgetClass.repeatToLen(control.objids, ncol),
          property, objid = objids[0],
          obj = this.getObj(objid),
          propvals, i, j, v1, v2, p, entry, gl, needsBinding,
          newprop, newid,

          getPropvals = function() {
            if (property === "userMatrix")
              return obj.par3d.userMatrix.getAsArray();
            else if (property === "scale" || property === "FOV" || property === "zoom")
              return [].concat(obj.par3d[property]);
            else
              return [].concat(obj[property]);
          },

          putPropvals = function(newvals) {
            if (newvals.length === 1)
              newvals = newvals[0];
            if (property === "userMatrix")
              obj.par3d.userMatrix.load(newvals);
            else if (property === "scale" || property === "FOV" || property === "zoom")
              obj.par3d[property] = newvals;
            else
              obj[property] = newvals;
          };

      if (direct && typeof value === "undefined")
        return;

      if (control.interp) {
        values = values.slice(0, ncol).concat(values).
                 concat(values.slice(ncol*(nrow-1), ncol*nrow));
        svals = [-Infinity].concat(svals).concat(Infinity);
        for (i = 1; i < svals.length; i++) {
          if (value <= svals[i]) {
            if (svals[i] === Infinity)
              p = 1;
            else
              p = (svals[i] - value)/(svals[i] - svals[i-1]);
            break;
          }
        }
      } else if (!direct) {
        value = Math.round(value);
      }

      for (j=0; j<entries.length; j++) {
        entry = entries[j];
        newprop = properties[j];
        newid = objids[j];

        if (newprop !== property || newid !== objid) {
          if (typeof property !== "undefined")
            putPropvals(propvals);
          property = newprop;
          objid = newid;
          obj = this.getObj(objid);
          propvals = getPropvals();
        }
        if (control.interp) {
          v1 = values[ncol*(i-1) + j];
          v2 = values[ncol*i + j];
          this.setElement(propvals, entry, p*v1 + (1-p)*v2);
        } else if (!direct) {
          this.setElement(propvals, entry, values[ncol*value + j]);
        } else {
          this.setElement(propvals, entry, value[j]);
        }
      }
      putPropvals(propvals);

      needsBinding = [];
      for (j=0; j < entries.length; j++) {
        if (properties[j] === "values" &&
            needsBinding.indexOf(objids[j]) === -1) {
          needsBinding.push(objids[j]);
        }
      }
      for (j=0; j < needsBinding.length; j++) {
        gl = this.gl || this.initGL();
        obj = this.getObj(needsBinding[j]);
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertices
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The vertext setter control data.
     */
    rglwidgetClass.prototype.vertexSetter = function(el, control)  {
      var svals = [].concat(control.param),
          j, k, p, a, propvals, stride, ofs, obj, entry,
          attrib, vertex, varies,
          ofss    = {x:"vofs", y:"vofs", z:"vofs",
                     red:"cofs", green:"cofs", blue:"cofs",
                     alpha:"cofs", radii:"radofs",
                     nx:"nofs", ny:"nofs", nz:"nofs",
                     ox:"oofs", oy:"oofs", oz:"oofs",
                     ts:"tofs", tt:"tofs"},
          pos     = {x:0, y:1, z:2,
                     red:0, green:1, blue:2,
                     alpha:3,radii:0,
                     nx:0, ny:1, nz:2,
                     ox:0, oy:1, oz:2,
                     ts:0, tt:1},
        values = control.values,
        direct = values === null,
        ncol,
        interp = control.interp,
        vertices = [].concat(control.vertices),
        attributes = [].concat(control.attributes),
        value = control.value, newval, aliases, alias;

      ncol = Math.max(vertices.length, attributes.length);

      if (!ncol)
        return;

      vertices = rglwidgetClass.repeatToLen(vertices, ncol);
      attributes = rglwidgetClass.repeatToLen(attributes, ncol);

      if (direct)
        interp = false;

      /* JSON doesn't pass Infinity */
      svals[0] = -Infinity;
      svals[svals.length - 1] = Infinity;

      for (j = 1; j < svals.length; j++) {
        if (value <= svals[j]) {
          if (interp) {
            if (svals[j] === Infinity)
              p = 1;
            else
              p = (svals[j] - value)/(svals[j] - svals[j-1]);
          } else {
            if (svals[j] - value > value - svals[j-1])
              j = j - 1;
          }
          break;
        }
      }

      obj = this.getObj(control.objid);
      // First, make sure color attributes vary in original
      if (typeof obj.vOffsets !== "undefined") {
      	varies = true;
        for (k = 0; k < ncol; k++) {
          attrib = attributes[k];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[attrib]];
            if (ofs < 0) {
              switch(attrib) {
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(control.objid);
      }
      propvals = obj.values;
      aliases = obj.alias;
      if (typeof aliases === "undefined")
        aliases = [];
      for (k=0; k<ncol; k++) {
        if (direct) {
          newval = value;
        } else if (interp) {
          newval = p*values[j-1][k] + (1-p)*values[j][k];
        } else {
          newval = values[j][k];
        }      	
        attrib = attributes[k];
        vertex = vertices[k];
        alias = aliases[vertex];
        if (obj.type === "planes" || obj.type === "clipplanes") {
          ofs = ["nx", "ny", "nz", "offset"].indexOf(attrib);
          if (ofs >= 0) {
            if (ofs < 3) {
              if (obj.normals[vertex][ofs] !== newval) {  // Assume no aliases here...
              	obj.normals[vertex][ofs] = newval;
              	obj.initialized = false;
              }
            } else {
              if (obj.offsets[vertex][0] !== newval) {
              	obj.offsets[vertex][0] = newval;
              	obj.initialized = false;
              }
            }
            continue;
          }
        }
        // Not a plane setting...
        ofs = obj.vOffsets[ofss[attrib]];
        if (ofs < 0)
          this.alertOnce("Attribute '"+attrib+"' not found in object "+control.objid);
        else {
          stride = obj.vOffsets.stride;
          ofs = ofs + pos[attrib];
          entry = vertex*stride + ofs;
          propvals[entry] = newval;
          if (typeof alias !== "undefined")
            for (a = 0; a < alias.length; a++)
              propvals[alias[a]*stride + ofs] = newval;
        }
      }
      if (typeof obj.buf !== "undefined") {
        var gl = this.gl || this.initGL();
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, propvals, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertex properties by age
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The age setter control data.
     */
    rglwidgetClass.prototype.ageSetter = function(el, control) {
      var objids = [].concat(control.objids),
          nobjs = objids.length,
          time = control.value,
          births = [].concat(control.births),
          ages = [].concat(control.ages),
          steps = births.length,
          j = Array(steps),
          p = Array(steps),
          i, k, l, age, j0, propvals, stride, ofs, objid, obj,
          attrib, dim, varies, alias, aliases, a, d,
          attribs = ["colors", "alpha", "radii", "vertices",
                     "normals", "origins", "texcoords",
                     "x", "y", "z",
                     "red", "green", "blue"],
          ofss    = ["cofs", "cofs", "radofs", "vofs",
                     "nofs", "oofs", "tofs",
                     "vofs", "vofs", "vofs",
                     "cofs", "cofs", "cofs"],
          dims    = [3,1,1,3,
                     3,2,2,
                     1,1,1,
                     1,1,1],
          pos     = [0,3,0,0,
                     0,0,0,
                     0,1,2,
                     0,1,2];
      /* Infinity doesn't make it through JSON */
      ages[0] = -Infinity;
      ages[ages.length-1] = Infinity;
      for (i = 0; i < steps; i++) {
        if (births[i] !== null) {  // NA in R becomes null
          age = time - births[i];
          for (j0 = 1; age > ages[j0]; j0++);
          if (ages[j0] === Infinity)
            p[i] = 1;
          else if (ages[j0] > ages[j0-1])
            p[i] = (ages[j0] - age)/(ages[j0] - ages[j0-1]);
          else
            p[i] = 0;
          j[i] = j0;
        }
      }
      // First, make sure color attributes vary in original
      for (l = 0; l < nobjs; l++) {
      	objid = objids[l];
      	obj = this.getObj(objid);
      	varies = true;
        if (typeof obj.vOffsets === "undefined")
          continue;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs < 0) {
              switch(attribs[k]) {
              	case "colors":
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(objid);
      }
      for (l = 0; l < nobjs; l++) {
        objid = objids[l];
        obj = this.getObj(objid);
        if (typeof obj.vOffsets === "undefined")
          continue;
        aliases = obj.alias;
        if (typeof aliases === "undefined")
          aliases = [];
        propvals = obj.values;
        stride = obj.vOffsets.stride;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs >= 0) {
              dim = dims[k];
              ofs = ofs + pos[k];
              for (i = 0; i < steps; i++) {
              	alias = aliases[i];
                if (births[i] !== null) {
                  for (d=0; d < dim; d++) {
                    propvals[i*stride + ofs + d] = p[i]*attrib[dim*(j[i]-1) + d] + (1-p[i])*attrib[dim*j[i] + d];
                    if (typeof alias !== "undefined")
                      for (a=0; a < alias.length; a++)
                        propvals[alias[a]*stride + ofs + d] = propvals[i*stride + ofs + d];
                  }
                }
              }
            } else
              this.alertOnce("\'"+attribs[k]+"\' property not found in object "+objid);
          }
        }
        obj.values = propvals;
        if (typeof obj.buf !== "undefined") {
          var gl = this.gl || this.initGL();
          gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
          gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
        }
      }
    };

    /**
     * Bridge to old style control
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The bridge control data.
     */
    rglwidgetClass.prototype.oldBridge = function(el, control) {
      var attrname, global = window[control.prefix + "rgl"];
      if (global)
        for (attrname in global)
          this[attrname] = global[attrname];
      window[control.prefix + "rgl"] = this;
    };

    /**
     * Set up a player control
     * @param { Object } el - The player control element
     * @param { Object } control - The player data.
     */
    rglwidgetClass.prototype.Player = function(el, control) {
      var
        self = this,
        components = [].concat(control.components),
        buttonLabels = [].concat(control.buttonLabels),

        Tick = function() { /* "this" will be a timer */
          var i,
              nominal = this.value,
              slider = this.Slider,
              labels = this.outputLabels,
              output = this.Output,
              step;
          if (typeof slider !== "undefined" && nominal !== slider.value)
            slider.value = nominal;
          if (typeof output !== "undefined") {
            step = Math.round((nominal - output.sliderMin)/output.sliderStep);
            if (labels !== null) {
              output.innerHTML = labels[step];
            } else {
              step = step*output.sliderStep + output.sliderMin;
              output.innerHTML = step.toPrecision(output.outputPrecision);
            }
          }
          for (i=0; i < this.actions.length; i++) {
            this.actions[i].value = nominal;
          }
          self.applyControls(el, this.actions, false);
          self.drawScene();
        },

        OnSliderInput = function() { /* "this" will be the slider */
          this.rgltimer.value = Number(this.value);
          this.rgltimer.Tick();
        },

        addSlider = function(min, max, step, value) {
          var slider = document.createElement("input");
          slider.type = "range";
          slider.min = min;
          slider.max = max;
          slider.step = step;
          slider.value = value;
          slider.oninput = OnSliderInput;
          slider.sliderActions = control.actions;
          slider.sliderScene = this;
          slider.className = "rgl-slider";
          slider.id = el.id + "-slider";
          el.rgltimer.Slider = slider;
          slider.rgltimer = el.rgltimer;
          el.appendChild(slider);
        },

        addLabel = function(labels, min, step, precision) {
          var output = document.createElement("output");
          output.sliderMin = min;
          output.sliderStep = step;
          output.outputPrecision = precision;
          output.className = "rgl-label";
          output.id = el.id + "-label";
          el.rgltimer.Output = output;
          el.rgltimer.outputLabels = labels;
          el.appendChild(output);
        },

        addButton = function(which, label, active) {
          var button = document.createElement("input"),
              onclicks = {Reverse: function() { this.rgltimer.reverse();},
                    Play: function() { this.rgltimer.play();
                                       this.value = this.rgltimer.enabled ? this.inactiveValue : this.activeValue; },
                   Slower: function() { this.rgltimer.slower(); },
                   Faster: function() { this.rgltimer.faster(); },
                   Reset: function() { this.rgltimer.reset(); },
              	   Step:  function() { this.rgltimer.step(); }
              };
          button.rgltimer = el.rgltimer;
          button.type = "button";
          button.value = label;
          button.activeValue = label;
          button.inactiveValue = active;
          if (which === "Play")
            button.rgltimer.PlayButton = button;
          button.onclick = onclicks[which];
          button.className = "rgl-button";
          button.id = el.id + "-" + which;
          el.appendChild(button);
        };

        if (typeof control.reinit !== "undefined" && control.reinit !== null) {
          control.actions.reinit = control.reinit;
        }
        el.rgltimer = new rgltimerClass(Tick, control.start, control.interval, control.stop,
                                        control.step, control.value, control.rate, control.loop, control.actions);
        for (var i=0; i < components.length; i++) {
          switch(components[i]) {
            case "Slider": addSlider(control.start, control.stop,
                                   control.step, control.value);
              break;
            case "Label": addLabel(control.labels, control.start,
                                   control.step, control.precision);
              break;
            default:
              addButton(components[i], buttonLabels[i], control.pause);
          }
        }
        el.rgltimer.Tick();
    };

    /**
     * Apply all registered controls
     * @param { Object } el - DOM element of the control
     * @param { Object } x - List of actions to apply
     * @param { boolean } [draw=true] - Whether to redraw after applying
     */
    rglwidgetClass.prototype.applyControls = function(el, x, draw) {
      var self = this, reinit = x.reinit, i, control, type;
      for (i = 0; i < x.length; i++) {
        control = x[i];
        type = control.type;
        self[type](el, control);
      }
      if (typeof reinit !== "undefined" && reinit !== null) {
        reinit = [].concat(reinit);
        for (i = 0; i < reinit.length; i++)
          self.getObj(reinit[i]).initialized = false;
      }
      if (typeof draw === "undefined" || draw)
        self.drawScene();
    };

    /**
     * Handler for scene change
     * @param { Object } message - What sort of scene change to do?
     */
    rglwidgetClass.prototype.sceneChangeHandler = function(message) {
      var self = document.getElementById(message.elementId).rglinstance,
          objs = message.objects, mat = message.material,
          root = message.rootSubscene,
          initSubs = message.initSubscenes,
          redraw = message.redrawScene,
          skipRedraw = message.skipRedraw,
          deletes, subs, allsubs = [], i,j;
      if (typeof message.delete !== "undefined") {
        deletes = [].concat(message.delete);
        if (typeof message.delfromSubscenes !== "undefined")
          subs = [].concat(message.delfromSubscenes);
        else
          subs = [];
        for (i = 0; i < deletes.length; i++) {
          for (j = 0; j < subs.length; j++) {
            self.delFromSubscene(deletes[i], subs[j]);
          }
          delete self.scene.objects[deletes[i]];
        }
      }
      if (typeof objs !== "undefined") {
        Object.keys(objs).forEach(function(key){
          key = parseInt(key, 10);
          self.scene.objects[key] = objs[key];
          self.initObjId(key);
          var obj = self.getObj(key),
              subs = [].concat(obj.inSubscenes), k;
          allsubs = allsubs.concat(subs);
          for (k = 0; k < subs.length; k++)
            self.addToSubscene(key, subs[k]);
        });
      }
      if (typeof mat !== "undefined") {
        self.scene.material = mat;
      }
      if (typeof root !== "undefined") {
        self.scene.rootSubscene = root;
      }
      if (typeof initSubs !== "undefined")
        allsubs = allsubs.concat(initSubs);
      allsubs = self.unique(allsubs);
      for (i = 0; i < allsubs.length; i++) {
        self.initSubscene(allsubs[i]);
      }
      if (typeof skipRedraw !== "undefined") {
        root = self.getObj(self.scene.rootSubscene);
        root.par3d.skipRedraw = skipRedraw;
      }
      if (redraw)
        self.drawScene();
    };
</script>
<script>    /**
     * Methods related to selection
     * @name ___METHODS_FOR_SELECTION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Respond to brush change
     */
    rglwidgetClass.prototype.selectionChanged = function() {
      var i, j, k, id, subid = this.select.subscene, subscene,
          objids, obj,
          p1 = this.select.region.p1, p2 = this.select.region.p2,
          filter, selection = [], handle, keys, xmin, x, xmax, ymin, y, ymax, z, v,
          someHidden;
      if (!subid)
        return;
      subscene = this.getObj(subid);
      objids = subscene.objects;
      filter = this.scene.crosstalk.filter;
      this.setmvMatrix(subid);
      this.setprMatrix(subid);
      this.setprmvMatrix();
      xmin = Math.min(p1.x, p2.x);
      xmax = Math.max(p1.x, p2.x);
      ymin = Math.min(p1.y, p2.y);
      ymax = Math.max(p1.y, p2.y);
      for (i = 0; i < objids.length; i++) {
      	id = objids[i];
      	j = this.scene.crosstalk.id.indexOf(id);
      	if (j >= 0) {
      	  keys = this.scene.crosstalk.key[j];
      	  obj = this.getObj(id);
      	  someHidden = false;
      	  for (k = 0; k < keys.length; k++) {
      	    if (filter && filter.indexOf(keys[k]) < 0) {
      	      someHidden = true;
      	      continue;
      	    }
      	    v = [].concat(obj.vertices[k]).concat(1.0);
            v = rglwidgetClass.multVM(v, this.prmvMatrix);
            x = v[0]/v[3];
            y = v[1]/v[3];
            z = v[2]/v[3];
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax && -1.0 <= z && z <= 1.0) {
              selection.push(keys[k]);
            } else
              someHidden = true;
      	  }
      	  obj.someHidden = someHidden && (filter || selection.length);
      	  obj.initialized = false;
      	  /* Who should we notify?  Only shared data in the current subscene, or everyone? */
      	  if (!this.equalArrays(selection, this.scene.crosstalk.selection)) {
      	    handle = this.scene.crosstalk.sel_handle[j];
      	    handle.set(selection, {rglSubsceneId: this.select.subscene});
      	  }
      	}
      }
    };
    
    /**
     * Respond to selection or filter change from crosstalk
     * @param { Object } event - crosstalk event
     * @param { boolean } filter - filter or selection?
     */
    rglwidgetClass.prototype.selection = function(event, filter) {
      	var i, j, ids, obj, keys, crosstalk = this.scene.crosstalk,
      	    selection, someHidden;

      	// Record the message and find out if this event makes some objects have mixed values:
      	
      	crosstalk = this.scene.crosstalk;
      	
      	if (filter) {
      	  filter = crosstalk.filter = event.value;
      	  selection = crosstalk.selection;
      	} else {  
          selection = crosstalk.selection = event.value;
          filter = crosstalk.filter;
      	}
        ids = crosstalk.id;
        for (i = 0; i < ids.length ; i++) {
          obj = this.getObj(ids[i]);
          obj.initialized = false;
          keys = crosstalk.key[i];
          someHidden = false;
          for (j = 0; j < keys.length && !someHidden; j++) {
            if ((filter && filter.indexOf(keys[j]) < 0) ||
                (selection.length && selection.indexOf(keys[j]) < 0))
                someHidden = true;
          }
          obj.someHidden = someHidden;
        }
        this.drawScene();
    };
    
    /**
     * Clear the selection brush
     * @param { number } except - Subscene that should ignore this request
     */
    rglwidgetClass.prototype.clearBrush = function(except) {
      if (this.select.subscene !== except) {
        this.select.region = {p1: {x:Infinity, y:Infinity}, 
                              p2: {x:Infinity, y:Infinity}};
        this.selectionChanged();
        this.select.state = "inactive";
        this.delFromSubscene(this.scene.brushId, this.select.subscene);
      }
      this.drawScene();
    };
    
    /**
     * Set the vertices in the selection box object
     */
    rglwidgetClass.prototype.initSelection = function(id) {
      if (typeof this.select.region === "undefined")
        return;
      var obj = this.getObj(id),
          p1 = this.select.region.p1,
          p2 = this.select.region.p2;
          
      obj.vertices = [[p1.x, p1.y, 0.0],
                      [p2.x, p1.y, 0.0],
                      [p2.x, p2.y, 0.0],
                      [p1.x, p2.y, 0.0],
                      [p1.x, p1.y, 0.0]];
    };
</script>
<script>
/* globals rgltimerClass: true */

/**
 * The class of an rgl timer object
 * @class
*/

/**
 * Construct an rgltimerClass object
 * @constructor
 * @param { function } Tick - action when timer fires
 * @param { number } startTime - nominal start time in seconds
 * @param { number } interval - seconds between updates
 * @param { number } stopTime - nominal stop time in seconds
 * @param { number } stepSize - nominal step size
 * @param { number } value - current nominal time
 * @param { number } rate - nominal units per second
 * @param { string } loop - "none", "cycle" or "oscillate"
 * @param { Object } actions - list of actions
 */
rgltimerClass = function(Tick, startTime, interval, stopTime, stepSize, value, rate, loop, actions) {
  this.enabled = false;
  this.timerId = 0;
  /** nominal start time in seconds */
  this.startTime = startTime;   
  /** current nominal time */      
  this.value = value;
  /** seconds between updates */                 
  this.interval = interval;
  /** nominal stop time */           
  this.stopTime = stopTime;
  /** nominal step size */           
  this.stepSize = stepSize;
  /** nominal units per second */           
  this.rate = rate;
  /** "none", "cycle", or "oscillate" */                   
  this.loop = loop;
  /** real world start time */                   
  this.realStart = undefined;
  /** multiplier for fast-forward or reverse */         
  this.multiplier = 1;                
  this.actions = actions;
  this.Tick = Tick;
};


    /**
     * Methods related to players
     * @name ___METHODS_FOR_PLAYERS___
     * @memberof rgltimerClass
     * @kind function
     * @instance
     */

  /**
   * Start playing
   * @memberof rgltimerClass
   */
  rgltimerClass.prototype.play = function() {
    if (this.enabled) {
      this.enabled = false;
      window.clearInterval(this.timerId);
      this.timerId = 0;
      return;
    }
    var tick = function(self) {
      var now = new Date();
      self.value = self.multiplier*self.rate*(now - self.realStart)/1000 + self.startTime;
      self.forceToRange();
      if (typeof self.Tick !== "undefined") {
        self.Tick(self.value);
      }

    };
    this.realStart = new Date() - 1000*(this.value - this.startTime)/this.rate/this.multiplier;
    this.timerId = window.setInterval(tick, 1000*this.interval, this);
    this.enabled = true;
  };

  /**
   * Force value into legal range
   */
  rgltimerClass.prototype.forceToRange = function() {
    if (this.value > this.stopTime + this.stepSize/2 || this.value < this.startTime - this.stepSize/2) {
      if (!this.loop) {
        this.reset();
      } else {
        var cycle = this.stopTime - this.startTime + this.stepSize,
            newval = (this.value - this.startTime) % cycle + this.startTime;
        if (newval < this.startTime) {
          newval += cycle;
        }
        this.realStart += (this.value - newval)*1000/this.multiplier/this.rate;
        this.value = newval;
      }
    }
  };

  /**
   * Reset to start values
   */
  rgltimerClass.prototype.reset = function() {
    this.value = this.startTime;
    this.newmultiplier(1);
    if (typeof this.Tick !== "undefined") {
        this.Tick(this.value);
    }
    if (this.enabled)
      this.play();  /* really pause... */
    if (typeof this.PlayButton !== "undefined")
      this.PlayButton.value = "Play";
  };

  /**
   * Increase the multiplier to play faster
   */
  rgltimerClass.prototype.faster = function() {
    this.newmultiplier(Math.SQRT2*this.multiplier);
  };

  /**
   * Decrease the multiplier to play slower
   */
  rgltimerClass.prototype.slower = function() {
    this.newmultiplier(this.multiplier/Math.SQRT2);
  };

  /**
   * Change sign of multiplier to reverse direction
   */
  rgltimerClass.prototype.reverse = function() {
    this.newmultiplier(-this.multiplier);
  };

  /**
   * Set multiplier for play speed
   * @param { number } newmult - new value
   */
  rgltimerClass.prototype.newmultiplier = function(newmult) {
    if (newmult !== this.multiplier) {
      this.realStart += 1000*(this.value - this.startTime)/this.rate*(1/this.multiplier - 1/newmult);
      this.multiplier = newmult;
    }
  };

  /**
   * Take one step
   */
  rgltimerClass.prototype.step = function() {
    this.value += this.rate*this.multiplier;
    this.forceToRange();
    if (typeof this.Tick !== "undefined")
      this.Tick(this.value);
  };
</script>
<script>/**
 * Pretty function from R
 * @name ___PRETTY_FROM_R___
 * @memberof rglwidgetClass
 * @kind function
 * @instance
 */


/* This file is translated from pretty.c, which was
 taken from the R sources, r61744 of src/appl/pretty.c,
 with minimal changes */

/*
 *  R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995-2012  The R Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

/**     
 * Construct pretty values to cover an interval
 * @param { number } lo - lower end of interval
 * @param { number } up - upper end of interval
 * @param { number } ndiv - requested number of divisions
 * @param { number } min_n - minimum divisions
 * @param { number } shrink_sml - if too many cells, amount to shrink by
 * @param { number } high_u_fact - bias in favour of larger units
 * @param { number } eps_correction - correction to bounds
 * @param { Boolean } return_bounds - whether to return bounds
 * @description
 * Pretty Intervals

 * Constructs m "pretty" values which cover the given interval	*lo <= *up
 *	m ~= *ndiv + 1	(i.e., ndiv := approximate number of INTERVALS)
 *
 * It is not quite clear what should happen for	 *lo = *up;
 * S itself behaves quite funilly, then.
 *
 * In my opinion, a proper 'pretty' should always ensure
 * *lo < *up, and hence *ndiv >=1 in the result.
 * However, in S and here, we allow  *lo == *up, and *ndiv = 0.
 * Note however, that we are NOT COMPATIBLE to S. [Martin M.]
 *
 * NEW (0.63.2): ns, nu are double (==> no danger of integer overflow)
 *
 * We determine
 * if the interval (up - lo) is ``small'' [<==>	 i_small == TRUE, below].
 * For the ``i_small'' situation, there is a parameter  shrink_sml,
 * the factor by which the "scale" is shrunk.		~~~~~~~~~~
 * It is advisable to set it to some (smaller) integer power of 2,
 * since this enables exact floating point division.
 */
rglwidgetClass.prototype.R_pretty = function(
  lo, up, ndiv, min_n, shrink_sml, high_u_fact,
  eps_correction, return_bounds) {
  /* From version 0.65 on, we had rounding_eps := 1e-5, before, r..eps = 0
   * 1e-7 is consistent with seq.default() */
  var rounding_eps = 1e-7,  h = high_u_fact[0],
                                           h5 = high_u_fact[1], 
                                                           dx, cell, unit, base, U, ns, nu, k, i_small,
                                                           DBL_EPSILON = Number.EPSILON,
                                                           DBL_MIN = Number.MIN_VALUE,
                                                           DBL_MAX = Number.MAX_VALUE;
  
  dx = up - lo;
  /* cell := "scale"	here */
  if (dx === 0 && up === 0) { /*  up == lo == 0	 */
  cell = 1;
    i_small = true;
  } else {
    cell = Math.max(Math.abs(lo), Math.abs(up));
    /* U = upper bound on cell/unit */
    U = (1 + (h5 >= 1.5*h+0.5)) ? 1/(1+h) : 1.5/(1+h5);
    /* added times 3, as several calculations here */
    i_small = dx < cell * U * Math.max(1,ndiv) * DBL_EPSILON *3;
  }
  
  /*OLD: cell = FLT_EPSILON+ dx / *ndiv; FLT_EPSILON = 1.192e-07 */
  if(i_small) {
    if(cell > 10)
      cell = 9 + cell/10;
    cell *= shrink_sml;
    if(min_n > 1) cell /= min_n;
  } else {
    cell = dx;
    if(ndiv > 1) cell /= ndiv;
  }
  
  if(cell < 20*DBL_MIN) {
    /* warning(_("Internal(pretty()): very small range.. corrected")); */
    cell = 20*DBL_MIN;
  } else if(cell * 10 > DBL_MAX) {
    /* warning(_("Internal(pretty()): very large range.. corrected")); */
    cell = 0.1*DBL_MAX;
  }
  base = Math.pow(10, Math.floor(Math.log10(cell))); /* base <= cell < 10*base */
    
    /* unit : from { 1,2,5,10 } * base
     *	 such that |u - cell| is small,
     * favoring larger (if h > 1, else smaller)  u  values;
     * favor '5' more than '2'  if h5 > h  (default h5 = .5 + 1.5 h) */
    unit = base;
    if((U = 2*base)-cell <  h*(cell-unit)) { unit = U;
      if((U = 5*base)-cell < h5*(cell-unit)) { unit = U;
        if((U =10*base)-cell <  h*(cell-unit)) unit = U; }}
    /* Result: c := cell,  u := unit,  b := base
     *	c in [	1,	      (2+ h) /(1+h) ] b ==> u=  b
     *	c in ( (2+ h)/(1+h),  (5+2h5)/(1+h5)] b ==> u= 2b
     *	c in ( (5+2h)/(1+h), (10+5h) /(1+h) ] b ==> u= 5b
     *	c in ((10+5h)/(1+h),	         10 ) b ==> u=10b
     *
     *	===>	2/5 *(2+h)/(1+h)  <=  c/u  <=  (2+h)/(1+h)	*/
    
    ns = Math.floor(lo/unit+rounding_eps);
    nu = Math.ceil (up/unit-rounding_eps);
    
    if(eps_correction && (eps_correction > 1 || !i_small)) {
      if(lo !== 0.0) lo *= (1- DBL_EPSILON); else lo = -DBL_MIN;
      if(up !== 0.0) up *= (1+ DBL_EPSILON); else up = +DBL_MIN;
    }
    
    while(ns*unit > lo + rounding_eps*unit) ns--;
    
    while(nu*unit < up - rounding_eps*unit) nu++;
    
    k = Math.floor(0.5 + nu - ns);
    if(k < min_n) {
      /* ensure that	nu - ns	 == min_n */
      
      k = min_n - k;
      if(ns >= 0) {
        nu += k/2;
        ns -= k/2 + k%2;/* ==> nu-ns = old(nu-ns) + min_n -k = min_n */
      } else {
        ns -= k/2;
        nu += k/2 + k%2;
      }
      ndiv = min_n;
    } else {
      ndiv = k;
    }
    if(return_bounds) { /* if()'s to ensure that result covers original range */
      if(ns * unit < lo) lo = ns * unit;
      if(nu * unit > up) up = nu * unit;
    } else {
      lo = ns;
      up = nu;
    }
    return {lo:lo, up:up, ndiv:ndiv, unit:unit};
};
</script>
<script>    /**
     * Methods related to axes
     * @name ___METHODS_FOR_AXES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Choose edges for ticks
     * @param { Matrix } prmv - projection-model-view matrix
     */
    rglwidgetClass.prototype.getTickEdges = function(prmv){
      var vertices = [[0,0,0,1], [0,0,1,1],
                      [0,1,0,1], [0,1,1,1],
                      [1,0,0,1], [1,0,1,1],
                      [1,1,0,1], [1,1,1,1]], 
           dim, i, j, k, edges, hull, step, result = [], proj = [],

        // Filter to edges that are on sides that would
        // be shown with a filled backing.
        
      has_back = function(edge) {
          var normals = [[], []],
              verts = [vertices[edge[0]], 
                       vertices[edge[1]]], 
              normal, m, n;
          n = 0;
          for (m=0; m<3; m++) {
            if (verts[0][m] === verts[1][m]) {
              normals[n] = [0,0,0,1];
              normals[n][m] = 2*verts[0][m] - 1;
              n++;
            }
          }
          for (n=0; n<2; n++) {
            normal = rglwidgetClass.multVM(normals[n], self.normMatrix);
            if (normal[2] < 0 ||
                (normal[2] === 0 && normal[0] < 0))
              return true;
          }
          return false;
        }, self = this;
        
      for (i = 0; i < vertices.length; i++) {
        proj[i] = rglwidgetClass.multVM(vertices[i], prmv);
        proj[i][0] = proj[i][0]/proj[i][3];
        proj[i][1] = proj[i][1]/proj[i][3];
        proj[i][2] = i;
      }
      hull = rglwidgetClass.chull(proj.slice());  
      for (i = 0; i < hull.length; i++)
        hull[i] = hull[i][2];
      hull.push(hull[0]);
      for (dim = 0; dim < 3; dim++) { 
        edges = [];
        step = Math.pow(2, 2-dim);
        for (i = 0; i < 4; i++) {
          j = (dim === 0) ? i : (dim === 1) ? i + 2*(i>1) : 2*i;
          for (k = 0; k < hull.length - 1; k++) {
            if ((hull[k] === j && hull[k+1] === j + step) ||
                (hull[k] === j+step && hull[k+1] === j))
          
              edges.push([j, j+step], [j+step, j]);
          }
        }

        edges = edges.filter(has_back);
        
        // Find the edge with a vertex closest
        // to the bottom left corner
        if (edges.length) {
          var best, best2, val = Infinity, newval;
          for (i = 0; i < edges.length; i++) {
            j = edges[i][0];
            newval = proj[j][0] + proj[j][1];
            if (newval < val) {
              best = j;
              best2 = edges[i][1];
              val = newval;
            }
          }
          if (typeof best !== "undefined") {
            result[dim] = vertices[best].slice(0,3);
            result[dim][dim] = undefined;
          } else
            result[dim] = undefined;
        }
      }
      return result;
    };
    
    /**
     * Choose tick locations
     * @param { Object } obj - The bboxdeco
    */
    rglwidgetClass.prototype.getTickLocations = function(obj){
      var dim, i, limits, locations = [], result = [[],[],[]], value,
          len, delta, range, bbox = obj.bbox;
      obj.needsAxisCallback = false;
      for (dim = 0; dim < 3; dim++) {
        limits = bbox.slice(2*dim, 2*dim + 2);
        range = limits[1] - limits[0];
        switch(obj.axes.mode[dim]) {
        case "custom":
          for (i=0; i < obj.vertices.length; i++) {
            value = (obj.vertices[i][dim] - limits[0])/range;
            if (typeof value !== "undefined" &&
                !isNaN(value))
              result[dim].push(value);
          }
          break;
        case "fixedstep":
          len = Math.floor(range/obj.axes.step[dim]);
          delta = obj.axes.step[dim];
          for (i = 0; i < len; i++)
            result[dim].push(i*delta);          
          break;
        case "fixednum":
          len = obj.axes.nticks[dim];
          delta = (len > 1) ? range/(len-1) : 0;
          for (i = 0; i < len; i++)
            result[dim].push(i*delta/range);
          break;
        case "pretty":
          locations = this.R_pretty(limits[0], limits[1], 5,
                                  2, // min_n
                                  0.75, // shrink_sml
                                  [1.5, 2.75], // high_u_fact
                                  0, // eps_correction
                                  0); // return_bounds)  
          for (i = locations.lo; i <= locations.up; i++) {
            value = (i*locations.unit - limits[0])/range;
            if (0 < value && value < 1)
              result[dim].push(value);
          }
          break;
        case "user":
          obj.needsAxisCallback = true;
          break;
        }
      }
      return result;
    };
    
    /**
     * Set tick vertices
     * @param { Object } ticks - the tick object
     * @param { Array }  edges - Which edges get the ticks?
    */
    rglwidgetClass.prototype.getTickVertices = function(ticks) {
      var dim, i, j, vertices = [], locations, 
          edges = ticks.edges, edge;
      for (dim = 0; dim < 3; dim++) {
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) 
            if (typeof edges[dim] !== "undefined") {
              edge = edges[dim].slice();
              edge[dim] = locations[i];
              vertices.push(edge);
              edge = edge.slice();
              for (j = 0; j < 3; j++)       
                if ((dim < 2 && j === 1 - dim) || 
                    (dim === 2 && j === 0))
                  edge[j] += 2*(edge[j] - 0.5)/ticks.axes.marklen[dim];
              vertices.push(edge);
            }
        }
      ticks.vertices = vertices;
      ticks.vertexCount = vertices.length;
      ticks.values = new Float32Array(rglwidgetClass.flatten(vertices));
      ticks.initialized = false;
    };
    
    /**
     * Set tick label positions
     * @param { Object } obj - the bbox object
    */
    rglwidgetClass.prototype.placeTickLabels = function(obj) {
      var ticks = obj.ticks, labels = obj.labels, i,j,k,
          vertices = [], tickvertices = ticks.vertices, 
          vertex, locations, dim, edges = obj.ticks.edges;
      j = 0;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) {
            if (isNaN(locations[i]))
              continue;
            while (j < tickvertices.length && 
                   tickvertices[j][dim] !== locations[i]) j++;
            if (j >= tickvertices.length)
              break;
            vertex = tickvertices[j].slice();
            for (k = 0; k < 3; k++)
              vertex[k] += 2*(tickvertices[j+1][k] - vertex[k]);
            vertices.push(vertex);
            j += 2;
          }
        }
      labels.vertices = vertices;
      labels.centers = labels.vertices;
      labels.initialized = false;
    };  
     
    /**
     * Set tick labels
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setTickLabels = function(obj) {
      var ticks = obj.ticks, mode, locations, labels = [],
      start = 0, nticks, dim, i, limits, range, values, max,
      edges = obj.ticks.edges;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        mode = obj.axes.mode[dim];
        nticks = obj.axes.nticks[dim]; // used on input only for custom!
        if (mode === "custom") 
          labels = labels.concat(obj.texts.slice(start, start + nticks));
        else {
          limits = obj.bbox.slice(2*dim, 2*(dim+1));
          range = limits[1] - limits[0];
          locations = ticks.locations[dim];
          max = -Infinity;
          values = [];
          for (i = 0; i < locations.length; i++) {
            values.push(limits[0] + range*locations[i]);
            max = Math.max(max, Math.abs(values[i]));
          }
          for (i = 0; i < locations.length; i++) {
            if (Math.abs(values[i])/max < Math.pow(10, -5))
              values[i] = 0;
            labels.push(rglwidgetClass.signif(values[i], 4).toString());
          }
          obj.axes.nticks[dim] = locations.length;  
        }
        start += nticks;
      }
      obj.labels.texts = labels;
    };

    /**
     * Set bboxdeco bbox and center vector 
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setBbox = function(obj, subscene) {
      var i, expand, center = [], bbox;
      if (!obj.initialized)
        this.initBBox(obj);
        
      bbox = [].concat(subscene.par3d.bbox);
      for (i = 0; i < 3; i++) {
        expand = obj.axes.expand[i];
        center[i] = (bbox[2*i] + bbox[2*i + 1])/2;
        bbox[2*i] = center[i] - expand*(bbox[2*i + 1] - center[i]);
        bbox[2*i+1] = center[i] + expand*(bbox[2*i + 1] - center[i]);
      }
      obj.bbox = bbox;
      obj.center = center;
    };

    rglwidgetClass.prototype.setBBoxMatrices = function(obj) {
      var saved = {normMatrix: new CanvasMatrix4(this.normMatrix),
                   mvMatrix: new CanvasMatrix4(this.mvMatrix)},
          bboxNorm, bboxMV, bbox = obj.bbox, scale;
          
      bboxNorm = new CanvasMatrix4();
      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];
      bboxNorm.scale(1/scale[0], 1/scale[1], 1/scale[2]);
      bboxNorm.multRight(saved.normMatrix);
      this.normMatrix = bboxNorm;

      bboxMV = new CanvasMatrix4();
      bboxMV.scale(scale[0], scale[1], scale[2]);
      bboxMV.translate(bbox[0], bbox[2], bbox[4]);
      bboxMV.multRight(saved.mvMatrix);
      this.mvMatrix = obj.mvMatrix = bboxMV;
      
      if (this.prmvMatrix === null)
        saved.prmvMatrix = null;
      else
        saved.prmvMatrix = new CanvasMatrix4(this.prmvMatrix);
        
      this.setprmvMatrix();
      obj.prmvMatrix = this.prmvMatrix;
      
      return saved;
    };
    
    rglwidgetClass.prototype.restoreBBoxMatrices = function(saved) {
      this.normMatrix = saved.normMatrix;
      this.mvMatrix   = saved.mvMatrix;
      this.prmvMatrix = saved.prmvMatrix;
    };
    
    rglwidgetClass.prototype.getMarginParameters = function(bboxdeco, material) {
      // Assume we've run this.setBbox(bboxdeco, subscene);
      var bbox = bboxdeco.bbox,
          edge = [].concat(material.edge),
          saved, edges, i, 
          at = material.margin, line, level, trans, scale;

      if (material.floating) {
        saved = this.setBBoxMatrices(bboxdeco);
        edges = this.getTickEdges(this.prmvMatrix)[at];
        this.restoreBBoxMatrices(saved);
        if (typeof edges !== "undefined")
          for (i = 0; i < 3; i++) {
            if (edges[i] < 1) edges[i] = -1;
              edge[i] = edge[i]*edges[i];
        } else
          return undefined;
      }
      switch(at) {
      case 0: line = 1;
              level = 2;
              break;
      case 1: line = 0;
              level = 2;
              break;
      case 2: line = 0;
              level = 1;
              break;
      }
      scale = [edge[0]*(bbox[1]-bbox[0])/bboxdeco.axes.marklen[0], 
               edge[1]*(bbox[3]-bbox[2])/bboxdeco.axes.marklen[1], 
               edge[2]*(bbox[5]-bbox[4])/bboxdeco.axes.marklen[2]];
      trans = [edge[0] === 1 ? bbox[1] : bbox[0],
               edge[1] === 1 ? bbox[3] : bbox[2],
               edge[2] === 1 ? bbox[5] : bbox[4]];
      return {at: at, line: line, level: level, trans: trans, scale: scale};        
    };
    
    rglwidgetClass.prototype.fixVertex = function(orig, parms, center, bbox) {
      var vertex = [0,0,0];
      if (rglwidgetClass.missing(orig[0]))
        vertex[parms.at] = center[parms.at];
      else if (orig[0] === "-Inf")
        vertex[parms.at] = bbox[2*parms.at];
      else if (orig[0] === "Inf")
        vertex[parms.at] = bbox[2*parms.at + 1];
      else
        vertex[parms.at] = orig[0];
      vertex[parms.line] = parms.scale[parms.line]*orig[1] + 
          parms.trans[parms.line];
      vertex[parms.level] = parms.scale[parms.level]*orig[2] + 
          parms.trans[parms.level];
      return vertex;
    };
    
    rglwidgetClass.prototype.fixNormal = function(orig, parms) {
      var vertex = [0,0,0];
      vertex[parms.at] = orig[0];
      vertex[parms.line] = orig[1]/parms.scale[parms.line];
      vertex[parms.level] = orig[2]/parms.scale[parms.level];
      return vertex;
    };

    rglwidgetClass.prototype.marginVecToDataVec = function(obj, subscene) {
      var bboxdeco = this.getBBoxDeco(subscene),
          center, bbox, parms, parmsjson,
          orig = obj.orig, 
          vertices = [], normals = [],
          centers = [], i, vertex;
      if (typeof orig === "undefined") {
        orig = {vert: obj.vertices,
                norm: obj.normals,
                cent: obj.centers,
                doNormals: typeof obj.normals !== "undefined",
                doCenters: typeof obj.centers !== "undefined",
                parms: ""
               };
        obj.orig = orig;
      }

      if (typeof bboxdeco !== "undefined") {
        this.setBbox(bboxdeco, subscene);
        center = bboxdeco.center;
        bbox = bboxdeco.bbox;
        parms = this.getMarginParameters(bboxdeco, obj.material);
        if (typeof parms === "undefined")
          return false;  /* axis is not currently shown */
        
        parmsjson = JSON.stringify(parms);
        if (parmsjson === orig.parms)
          return true;  /* nothing has changed */
    
        orig.parms = parmsjson;
        
        for (i=0; i < orig.vert.length; i++) {
          vertex = this.fixVertex(orig.vert[i], parms, center, bbox);
          vertices.push(vertex);
        }
        obj.vertices = vertices;
        if (orig.doNormals) {
          for (i=0; i < orig.norm.length; i++) {
            vertex = this.fixNormal(orig.norm[i], parms);
            normals.push(vertex);
          }
          obj.normals = normals;
        }
        if (orig.doCenters) {
          for (i=0; i < orig.cent.length; i++) {
            vertex = this.fixVertex(orig.cent[i], parms, center, bbox);
            centers.push(vertex);
          }
          obj.centers = centers;
        }
        
        obj.initialized = false;
        return true;
      } else {
        console.warn("bboxdeco not found");
        return false;
      }
    };

    rglwidgetClass.prototype.doAxisCallback = function(obj, edges) {
      var i, j, code, axis, fn;
      for (i = 0; i < 3; i++) {
        if (obj.axes.mode[i] === "user") {
          axis = ["x", "y", "z"][i];
          if (typeof obj.callbacks !== "undefined" &&
              typeof (code = obj.callbacks[axis]) !== "undefined") {
            if (typeof edges[i] !== "undefined")
              for (j = 0; j < 3; j++)
                if (typeof edges[i][j] !== "undefined")
                  axis = axis + (edges[i][j] > 0 ? "+" : "-");
            
          /* jshint evil:true */
            fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
            fn.call(this, axis);
          }
        }
      }
    };
</script>
<script>/**
     * Methods related to animations
     * @name ___METHODS_FOR_ANIMATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Binary search
     * @param x - x coordinates in increasing order
     * @param newx - value to find, assumed to be in the range of x
     * @result index of largest x value below newx
     */
    rglwidgetClass.bisect = function(x, newx) {
      var lo = 0, hi = x.length - 1, mid;
      while (lo < hi - 1) {
        mid = Math.round((lo + hi)/2);
        if (x[mid] < newx)
          lo = mid;
        else
          hi = mid;
      }
      return lo;
    };
    
    /**
     * Step interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.step = function(x, v, newx) {
      var n, lo;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      return v[lo];
    };
    
    /**
     * Linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.lerp = function(x, v, newx) {
      var i, n, lo, hi, alpha, result;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      alpha = (newx - x[lo])/(x[hi] - x[lo]);
      result = v[lo];
      n = result.length;
      if (typeof n !== "undefined") {
        for (i = 0; i < n; i++)
          result[i] = (1 - alpha)*result[i] + alpha*v[hi][i];
      } else
        result = (1 - alpha)*result + alpha*v[hi];
      return result;
    };
    
    /**
     * Spherical linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - a matrix of unit quaternions
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.slerp = function(x, v, newx) {
      var n, lo, hi, alpha, result,
          p0, p1, dot, Omega, alpha0, alpha1, len;
      if (newx <= x[0])
        return v[0];    
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      p0 = v[lo];
      p1 = v[hi];
      dot = p0[0]*p1[0] + 
            p0[1]*p1[1] +
            p0[2]*p1[2] +
            p0[3]*p1[3];
      if (dot < 0) {
        p1 = [-p1[0], -p1[1], -p1[2], -p1[3]];
        dot = -dot;
      }
      if (dot >= 1)
        result = p1;
      else {
        alpha = (newx - x[lo])/(x[hi] - x[lo]);
        Omega = Math.acos(dot);
        alpha0 = Math.sin((1 - alpha)*Omega);
        alpha1 = Math.sin(alpha*Omega);
        result = [alpha0*p0[0] + alpha1*p1[0],
                  alpha0*p0[1] + alpha1*p1[1],
                  alpha0*p0[2] + alpha1*p1[2],
                  alpha0*p0[3] + alpha1*p1[3]];
      }
      len = Math.sqrt(result[0]*result[0] +
                      result[1]*result[1] +
                      result[2]*result[2] +
                      result[3]*result[3]);
      return [result[0]/len,
              result[1]/len,
              result[2]/len,
              result[3]/len];
    };

    /**
     * Rotate using unit quaternion
     * @param q - a single unit quaternion
     */
    rglwidgetClass.rotateByQuaternion = function(M, q) {

    var xx = q[0]*q[0],
        xy = q[0]*q[1],
        xz = q[0]*q[2],
        xw = q[0]*q[3],
        yy = q[1]*q[1],
        yz = q[1]*q[2],
        yw = q[1]*q[3],
        zz = q[2]*q[2],
        zw = q[2]*q[3],
        matrix = new CanvasMatrix4();
      matrix.m11 = 1 - 2*(yy + zz);
      matrix.m12 = 2*(xy + zw);
      matrix.m13 = 2*(xz - yw);
        
      matrix.m21 = 2*(xy - zw);
      matrix.m22 = 1 - 2*(xx + zz);
      matrix.m23 = 2*(yz + xw);

      matrix.m31 = 2*(xz + yw);
      matrix.m32 = 2*(yz - xw);
      matrix.m33 = 1 - 2*(xx + yy);

      M.multRight(matrix);      
    };
</script>
<script>/* globals CanvasMatrix4: true */
/* globals WebGLFloatArray */
/* jshint eqeqeq: false */
/*
 * Copyright (C) 2009 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Copyright (2016) Duncan Murdoch - fixed CanvasMatrix4.ortho,
 * cleaned up.
 */
/*
    CanvasMatrix4 class

    This class implements a 4x4 matrix. It has functions which
    duplicate the functionality of the OpenGL matrix stack and
    glut functions.

    IDL:

    [
        Constructor(in CanvasMatrix4 matrix),           // copy passed matrix into new CanvasMatrix4
        Constructor(in sequence<float> array)           // create new CanvasMatrix4 with 16 floats (row major)
        Constructor()                                   // create new CanvasMatrix4 with identity matrix
    ]
    interface CanvasMatrix4 {
        attribute float m11;
        attribute float m12;
        attribute float m13;
        attribute float m14;
        attribute float m21;
        attribute float m22;
        attribute float m23;
        attribute float m24;
        attribute float m31;
        attribute float m32;
        attribute float m33;
        attribute float m34;
        attribute float m41;
        attribute float m42;
        attribute float m43;
        attribute float m44;

        void load(in CanvasMatrix4 matrix);                 // copy the values from the passed matrix
        void load(in sequence<float> array);                // copy 16 floats into the matrix
        sequence<float> getAsArray();                       // return the matrix as an array of 16 floats
        WebGLFloatArray getAsCanvasFloatArray();           // return the matrix as a WebGLFloatArray with 16 values
        void makeIdentity();                                // replace the matrix with identity
        void transpose();                                   // replace the matrix with its transpose
        void invert();                                      // replace the matrix with its inverse

        void translate(in float x, in float y, in float z); // multiply the matrix by passed translation values on the right
        void scale(in float x, in float y, in float z);     // multiply the matrix by passed scale values on the right
        void rotate(in float angle,                         // multiply the matrix by passed rotation values on the right
                    in float x, in float y, in float z);    // (angle is in degrees)
        void multRight(in CanvasMatrix matrix);             // multiply the matrix by the passed matrix on the right
        void multLeft(in CanvasMatrix matrix);              // multiply the matrix by the passed matrix on the left
        void ortho(in float left, in float right,           // multiply the matrix by the passed ortho values on the right
                   in float bottom, in float top,
                   in float near, in float far);
        void frustum(in float left, in float right,         // multiply the matrix by the passed frustum values on the right
                     in float bottom, in float top,
                     in float near, in float far);
        void perspective(in float fovy, in float aspect,    // multiply the matrix by the passed perspective values on the right
                         in float zNear, in float zFar);
        void lookat(in float eyex, in float eyey, in float eyez,    // multiply the matrix by the passed lookat
                    in float ctrx, in float ctry, in float ctrz,    // values on the right
                    in float upx, in float upy, in float upz);
    }
*/

CanvasMatrix4 = function(m)
{
    if (typeof m == 'object') {
        if ("length" in m && m.length >= 16) {
            this.load(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
            return;
        }
        else if (m instanceof CanvasMatrix4) {
            this.load(m);
            return;
        }
    }
    this.makeIdentity();
};

CanvasMatrix4.prototype.load = function()
{
    if (arguments.length == 1 && typeof arguments[0] == 'object') {
        var matrix = arguments[0];

        if ("length" in matrix && matrix.length == 16) {
            this.m11 = matrix[0];
            this.m12 = matrix[1];
            this.m13 = matrix[2];
            this.m14 = matrix[3];

            this.m21 = matrix[4];
            this.m22 = matrix[5];
            this.m23 = matrix[6];
            this.m24 = matrix[7];

            this.m31 = matrix[8];
            this.m32 = matrix[9];
            this.m33 = matrix[10];
            this.m34 = matrix[11];

            this.m41 = matrix[12];
            this.m42 = matrix[13];
            this.m43 = matrix[14];
            this.m44 = matrix[15];
            return;
        }

        if (arguments[0] instanceof CanvasMatrix4) {

            this.m11 = matrix.m11;
            this.m12 = matrix.m12;
            this.m13 = matrix.m13;
            this.m14 = matrix.m14;

            this.m21 = matrix.m21;
            this.m22 = matrix.m22;
            this.m23 = matrix.m23;
            this.m24 = matrix.m24;

            this.m31 = matrix.m31;
            this.m32 = matrix.m32;
            this.m33 = matrix.m33;
            this.m34 = matrix.m34;

            this.m41 = matrix.m41;
            this.m42 = matrix.m42;
            this.m43 = matrix.m43;
            this.m44 = matrix.m44;
            return;
        }
    }

    this.makeIdentity();
};

CanvasMatrix4.prototype.getAsArray = function()
{
    return [
        this.m11, this.m12, this.m13, this.m14,
        this.m21, this.m22, this.m23, this.m24,
        this.m31, this.m32, this.m33, this.m34,
        this.m41, this.m42, this.m43, this.m44
    ];
};

CanvasMatrix4.prototype.getAsWebGLFloatArray = function()
{
    return new WebGLFloatArray(this.getAsArray());
};

CanvasMatrix4.prototype.makeIdentity = function()
{
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;

    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;

    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;

    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
};

CanvasMatrix4.prototype.transpose = function()
{
    var tmp = this.m12;
    this.m12 = this.m21;
    this.m21 = tmp;

    tmp = this.m13;
    this.m13 = this.m31;
    this.m31 = tmp;

    tmp = this.m14;
    this.m14 = this.m41;
    this.m41 = tmp;

    tmp = this.m23;
    this.m23 = this.m32;
    this.m32 = tmp;

    tmp = this.m24;
    this.m24 = this.m42;
    this.m42 = tmp;

    tmp = this.m34;
    this.m34 = this.m43;
    this.m43 = tmp;
};

CanvasMatrix4.prototype.invert = function()
{
    // Calculate the 4x4 determinant
    // If the determinant is zero,
    // then the inverse matrix is not unique.
    var det = this._determinant4x4();

    if (Math.abs(det) < 1e-8)
        return null;

    this._makeAdjoint();

    // Scale the adjoint matrix to get the inverse
    this.m11 /= det;
    this.m12 /= det;
    this.m13 /= det;
    this.m14 /= det;

    this.m21 /= det;
    this.m22 /= det;
    this.m23 /= det;
    this.m24 /= det;

    this.m31 /= det;
    this.m32 /= det;
    this.m33 /= det;
    this.m34 /= det;

    this.m41 /= det;
    this.m42 /= det;
    this.m43 /= det;
    this.m44 /= det;
};

CanvasMatrix4.prototype.translate = function(x,y,z)
{
    if (x === undefined)
        x = 0;
    if (y === undefined)
        y = 0;
    if (z === undefined)
        z = 0;

    var matrix = new CanvasMatrix4();
    matrix.m41 = x;
    matrix.m42 = y;
    matrix.m43 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.scale = function(x,y,z)
{
    if (x === undefined)
        x = 1;
    if (z === undefined) {
        if (y === undefined) {
            y = x;
            z = x;
        }
        else
            z = 1;
    }
    else if (y === undefined)
        y = x;

    var matrix = new CanvasMatrix4();
    matrix.m11 = x;
    matrix.m22 = y;
    matrix.m33 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.rotate = function(angle,x,y,z)
{
    // angles are in degrees. Switch to radians
    angle = angle / 180 * Math.PI;

    angle /= 2;
    var sinA = Math.sin(angle);
    var cosA = Math.cos(angle);
    var sinA2 = sinA * sinA;

    // normalize
    var length = Math.sqrt(x * x + y * y + z * z);
    if (length === 0) {
        // bad vector, just use something reasonable
        x = 0;
        y = 0;
        z = 1;
    } else if (length != 1) {
        x /= length;
        y /= length;
        z /= length;
    }

    var mat = new CanvasMatrix4();

    // optimize case where axis is along major axis
    if (x == 1 && y === 0 && z === 0) {
        mat.m11 = 1;
        mat.m12 = 0;
        mat.m13 = 0;
        mat.m21 = 0;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 2 * sinA * cosA;
        mat.m31 = 0;
        mat.m32 = -2 * sinA * cosA;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y == 1 && z === 0) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 0;
        mat.m13 = -2 * sinA * cosA;
        mat.m21 = 0;
        mat.m22 = 1;
        mat.m23 = 0;
        mat.m31 = 2 * sinA * cosA;
        mat.m32 = 0;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y === 0 && z == 1) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 2 * sinA * cosA;
        mat.m13 = 0;
        mat.m21 = -2 * sinA * cosA;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 0;
        mat.m31 = 0;
        mat.m32 = 0;
        mat.m33 = 1;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else {
        var x2 = x*x;
        var y2 = y*y;
        var z2 = z*z;

        mat.m11 = 1 - 2 * (y2 + z2) * sinA2;
        mat.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
        mat.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
        mat.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
        mat.m22 = 1 - 2 * (z2 + x2) * sinA2;
        mat.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
        mat.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
        mat.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
        mat.m33 = 1 - 2 * (x2 + y2) * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    }
    this.multRight(mat);
};

CanvasMatrix4.prototype.multRight = function(mat)
{
    var m11 = (this.m11 * mat.m11 + this.m12 * mat.m21 +
               this.m13 * mat.m31 + this.m14 * mat.m41);
    var m12 = (this.m11 * mat.m12 + this.m12 * mat.m22 +
               this.m13 * mat.m32 + this.m14 * mat.m42);
    var m13 = (this.m11 * mat.m13 + this.m12 * mat.m23 +
               this.m13 * mat.m33 + this.m14 * mat.m43);
    var m14 = (this.m11 * mat.m14 + this.m12 * mat.m24 +
               this.m13 * mat.m34 + this.m14 * mat.m44);

    var m21 = (this.m21 * mat.m11 + this.m22 * mat.m21 +
               this.m23 * mat.m31 + this.m24 * mat.m41);
    var m22 = (this.m21 * mat.m12 + this.m22 * mat.m22 +
               this.m23 * mat.m32 + this.m24 * mat.m42);
    var m23 = (this.m21 * mat.m13 + this.m22 * mat.m23 +
               this.m23 * mat.m33 + this.m24 * mat.m43);
    var m24 = (this.m21 * mat.m14 + this.m22 * mat.m24 +
               this.m23 * mat.m34 + this.m24 * mat.m44);

    var m31 = (this.m31 * mat.m11 + this.m32 * mat.m21 +
               this.m33 * mat.m31 + this.m34 * mat.m41);
    var m32 = (this.m31 * mat.m12 + this.m32 * mat.m22 +
               this.m33 * mat.m32 + this.m34 * mat.m42);
    var m33 = (this.m31 * mat.m13 + this.m32 * mat.m23 +
               this.m33 * mat.m33 + this.m34 * mat.m43);
    var m34 = (this.m31 * mat.m14 + this.m32 * mat.m24 +
               this.m33 * mat.m34 + this.m34 * mat.m44);

    var m41 = (this.m41 * mat.m11 + this.m42 * mat.m21 +
               this.m43 * mat.m31 + this.m44 * mat.m41);
    var m42 = (this.m41 * mat.m12 + this.m42 * mat.m22 +
               this.m43 * mat.m32 + this.m44 * mat.m42);
    var m43 = (this.m41 * mat.m13 + this.m42 * mat.m23 +
               this.m43 * mat.m33 + this.m44 * mat.m43);
    var m44 = (this.m41 * mat.m14 + this.m42 * mat.m24 +
               this.m43 * mat.m34 + this.m44 * mat.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.multLeft = function(mat)
{
    var m11 = (mat.m11 * this.m11 + mat.m12 * this.m21 +
               mat.m13 * this.m31 + mat.m14 * this.m41);
    var m12 = (mat.m11 * this.m12 + mat.m12 * this.m22 +
               mat.m13 * this.m32 + mat.m14 * this.m42);
    var m13 = (mat.m11 * this.m13 + mat.m12 * this.m23 +
               mat.m13 * this.m33 + mat.m14 * this.m43);
    var m14 = (mat.m11 * this.m14 + mat.m12 * this.m24 +
               mat.m13 * this.m34 + mat.m14 * this.m44);

    var m21 = (mat.m21 * this.m11 + mat.m22 * this.m21 +
               mat.m23 * this.m31 + mat.m24 * this.m41);
    var m22 = (mat.m21 * this.m12 + mat.m22 * this.m22 +
               mat.m23 * this.m32 + mat.m24 * this.m42);
    var m23 = (mat.m21 * this.m13 + mat.m22 * this.m23 +
               mat.m23 * this.m33 + mat.m24 * this.m43);
    var m24 = (mat.m21 * this.m14 + mat.m22 * this.m24 +
               mat.m23 * this.m34 + mat.m24 * this.m44);

    var m31 = (mat.m31 * this.m11 + mat.m32 * this.m21 +
               mat.m33 * this.m31 + mat.m34 * this.m41);
    var m32 = (mat.m31 * this.m12 + mat.m32 * this.m22 +
               mat.m33 * this.m32 + mat.m34 * this.m42);
    var m33 = (mat.m31 * this.m13 + mat.m32 * this.m23 +
               mat.m33 * this.m33 + mat.m34 * this.m43);
    var m34 = (mat.m31 * this.m14 + mat.m32 * this.m24 +
               mat.m33 * this.m34 + mat.m34 * this.m44);

    var m41 = (mat.m41 * this.m11 + mat.m42 * this.m21 +
               mat.m43 * this.m31 + mat.m44 * this.m41);
    var m42 = (mat.m41 * this.m12 + mat.m42 * this.m22 +
               mat.m43 * this.m32 + mat.m44 * this.m42);
    var m43 = (mat.m41 * this.m13 + mat.m42 * this.m23 +
               mat.m43 * this.m33 + mat.m44 * this.m43);
    var m44 = (mat.m41 * this.m14 + mat.m42 * this.m24 +
               mat.m43 * this.m34 + mat.m44 * this.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.ortho = function(left, right, bottom, top, near, far)
{
    var tx = (left + right) / (left - right);
    var ty = (top + bottom) / (bottom - top);
    var tz = (far + near) / (near - far);

    var matrix = new CanvasMatrix4();
    matrix.m11 = 2 / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;
    matrix.m21 = 0;
    matrix.m22 = 2 / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;
    matrix.m31 = 0;
    matrix.m32 = 0;
    matrix.m33 = -2 / (far - near);
    matrix.m34 = 0;
    matrix.m41 = tx;
    matrix.m42 = ty;
    matrix.m43 = tz;
    matrix.m44 = 1;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.frustum = function(left, right, bottom, top, near, far)
{
    var matrix = new CanvasMatrix4();
    var A = (right + left) / (right - left);
    var B = (top + bottom) / (top - bottom);
    var C = -(far + near) / (far - near);
    var D = -(2 * far * near) / (far - near);

    matrix.m11 = (2 * near) / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;

    matrix.m21 = 0;
    matrix.m22 = 2 * near / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;

    matrix.m31 = A;
    matrix.m32 = B;
    matrix.m33 = C;
    matrix.m34 = -1;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = D;
    matrix.m44 = 0;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.perspective = function(fovy, aspect, zNear, zFar)
{
    var top = Math.tan(fovy * Math.PI / 360) * zNear;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    this.frustum(left, right, bottom, top, zNear, zFar);
};

CanvasMatrix4.prototype.lookat = function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)
{
    var matrix = new CanvasMatrix4(),
        xx, xy, xz;

    // Make rotation matrix

    // Z vector
    var zx = eyex - centerx;
    var zy = eyey - centery;
    var zz = eyez - centerz;
    var mag = Math.sqrt(zx * zx + zy * zy + zz * zz);
    if (mag) {
        zx /= mag;
        zy /= mag;
        zz /= mag;
    }

    // Y vector
    var yx = upx;
    var yy = upy;
    var yz = upz;

    // X vector = Y cross Z
    xx =  yy * zz - yz * zy;
    xy = -yx * zz + yz * zx;
    xz =  yx * zy - yy * zx;

    // Recompute Y = Z cross X
    yx = zy * xz - zz * xy;
    yy = -zx * xz + zz * xx;
    yx = zx * xy - zy * xx;

    // cross product gives area of parallelogram, which is < 1.0 for
    // non-perpendicular unit-length vectors; so normalize x, y here

    mag = Math.sqrt(xx * xx + xy * xy + xz * xz);
    if (mag) {
        xx /= mag;
        xy /= mag;
        xz /= mag;
    }

    mag = Math.sqrt(yx * yx + yy * yy + yz * yz);
    if (mag) {
        yx /= mag;
        yy /= mag;
        yz /= mag;
    }

    matrix.m11 = xx;
    matrix.m12 = xy;
    matrix.m13 = xz;
    matrix.m14 = 0;

    matrix.m21 = yx;
    matrix.m22 = yy;
    matrix.m23 = yz;
    matrix.m24 = 0;

    matrix.m31 = zx;
    matrix.m32 = zy;
    matrix.m33 = zz;
    matrix.m34 = 0;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = 0;
    matrix.m44 = 1;
    matrix.translate(-eyex, -eyey, -eyez);

    this.multRight(matrix);
};

// Support functions
CanvasMatrix4.prototype._determinant2x2 = function(a, b, c, d)
{
    return a * d - b * c;
};

CanvasMatrix4.prototype._determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3)
{
    return a1 * this._determinant2x2(b2, b3, c2, c3) -
         b1 * this._determinant2x2(a2, a3, c2, c3) +
         c1 * this._determinant2x2(a2, a3, b2, b3);
};

CanvasMatrix4.prototype._determinant4x4 = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    return a1 * this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
         b1 * this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
         c1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
         d1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

CanvasMatrix4.prototype._makeAdjoint = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    // Row column labeling reversed since we transpose rows & columns
    this.m11  =   this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    this.m21  = - this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    this.m31  =   this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    this.m41  = - this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    this.m12  = - this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    this.m22  =   this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    this.m32  = - this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    this.m42  =   this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    this.m13  =   this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    this.m23  = - this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    this.m33  =   this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    this.m43  = - this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    this.m14  = - this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    this.m24  =   this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    this.m34  = - this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    this.m44  =   this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
};
</script>

</head>
<body style="background-color: white;">
<div id="htmlwidget_container">
  <p id="rgl96104-aria" hidden>3D plot</p>
  <div aria-labelledby="rgl96104-aria" class="rglWebGL html-widget html-fill-item-overflow-hidden html-fill-item" id="rgl96104" style="width:960px;height:500px;"></div>
</div>
<script type="application/json" data-for="rgl96104">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#000000","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":21,"objects":{"28":{"id":28,"type":"points","material":{"lit":false,"size":4},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"29":{"id":29,"type":"lines","material":{"lit":false},"vertices":"3","colors":"4","centers":"5","ignoreExtent":true,"flags":32832},"30":{"id":30,"type":"text","material":{"lit":false},"vertices":"6","colors":"7","texts":[["0"],["2"],["4"],["6"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"31":{"id":31,"type":"lines","material":{"lit":false},"vertices":"9","colors":"10","centers":"11","ignoreExtent":true,"flags":32832},"32":{"id":32,"type":"text","material":{"lit":false},"vertices":"12","colors":"13","texts":[["0"],["1"],["2"],["3"],["4"],["5"],["6"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"14","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"33":{"id":33,"type":"lines","material":{"lit":false},"vertices":"15","colors":"16","centers":"17","ignoreExtent":true,"flags":32832},"34":{"id":34,"type":"text","material":{"lit":false},"vertices":"18","colors":"19","texts":[[" 0"],[" 5"],["10"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"20","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"25":{"id":25,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"24":{"id":24,"type":"background","material":{"specular":"#FFFFFF"},"colors":"21","centers":"22","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"26":{"id":26,"type":"background","material":{"lit":false,"specular":"#FFFFFF","back":"lines"},"colors":"23","centers":"24","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"27":{"id":27,"type":"background","material":{"lit":false,"specular":"#FFFFFF","back":"lines"},"colors":"25","centers":"26","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"21":{"id":21,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":21,"mouseMode":{"none":"none","left":"trackball","right":"user","middle":"fov","wheel":"pull"},"observer":[0,0,34.15694046020508],"modelMatrix":[[1,0,0,-3.538505077362061],[0,0.3420201539993286,0.9396926164627075,-7.912734985351562],[0,-0.9396926164627075,0.3420201539993286,-33.50334167480469],[0,0,0,1]],"projMatrix":[[3.732050895690918,0,0,0],[0,3.732050895690918,0,0],[0,0,-3.863703727722168,-123.1318359375],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201433256682,0.9396926207859085,0],[0,-0.9396926207859085,0.3420201433256682,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[0,7.077010154724121,0,6.640989780426025,-0.1776700019836426,14.60165977478027],"windowRect":[60,83,316,339],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[27,28,29,30,31,32,33,34,25],"subscenes":[],"flags":36176}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":257,"height":257,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":8989,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":8989,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":8989,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":10,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":5,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":4,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":4,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":16,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":7,"type":"VEC3"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":14,"componentType":5126,"count":7,"type":"VEC3"},{"bufferView":15,"componentType":5126,"count":8,"type":"VEC3"},{"bufferView":16,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":17,"componentType":5126,"count":4,"type":"VEC3"},{"bufferView":18,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":19,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":20,"componentType":5126,"count":3,"type":"VEC3"},{"bufferView":21,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":22,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":23,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":24,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":25,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":26,"componentType":5121,"count":1,"type":"VEC3"}],"bufferViews":[{"buffer":0,"byteLength":107868,"byteOffset":0},{"buffer":0,"byteLength":35956,"byteOffset":107868},{"buffer":0,"byteLength":107868,"byteOffset":143824},{"buffer":0,"byteLength":120,"byteOffset":251692},{"buffer":0,"byteLength":4,"byteOffset":251812},{"buffer":0,"byteLength":60,"byteOffset":251816},{"buffer":0,"byteLength":48,"byteOffset":251876},{"buffer":0,"byteLength":4,"byteOffset":251924},{"buffer":0,"byteLength":48,"byteOffset":251928},{"buffer":0,"byteLength":192,"byteOffset":251976},{"buffer":0,"byteLength":4,"byteOffset":252168},{"buffer":0,"byteLength":96,"byteOffset":252172},{"buffer":0,"byteLength":84,"byteOffset":252268},{"buffer":0,"byteLength":4,"byteOffset":252352},{"buffer":0,"byteLength":84,"byteOffset":252356},{"buffer":0,"byteLength":96,"byteOffset":252440},{"buffer":0,"byteLength":4,"byteOffset":252536},{"buffer":0,"byteLength":48,"byteOffset":252540},{"buffer":0,"byteLength":36,"byteOffset":252588},{"buffer":0,"byteLength":4,"byteOffset":252624},{"buffer":0,"byteLength":36,"byteOffset":252628},{"buffer":0,"byteLength":16,"byteOffset":252664},{"buffer":0,"byteLength":3,"byteOffset":252680},{"buffer":0,"byteLength":4,"byteOffset":252683},{"buffer":0,"byteLength":3,"byteOffset":252687},{"buffer":0,"byteLength":4,"byteOffset":252690},{"buffer":0,"byteLength":3,"byteOffset":252694}],"buffers":[{"byteLength":252697,"bytes":"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\nnUCSlnRAngxiQH2RgUChuXhAu+1cQHtmkkAsmtRAiuVoQPypnUAZxc9AlWCFP/GAoUCSdPhA\nyO9PQPD5gkDM0cFA+fdTQDjbgUA1DLVAiGiBQPily0DGhU9AngxiQK+ZrUD/st9A0sZrQPz7\nmUBMprhAgjk8QHE9ckBNhL5AFvY4QFnddED4a9JAt5c2QNpVdkDAz91AOC16QDm0pEAYz7ZA\nfbNdP3E9qkDN5LxA0sZrQOxRmEA+eZpAM21nP61uqkDU8btAOC16QLPvo0CTjKVALc/nPz24\nxkA8a9VAN4lpQLAgmEDWc35ATwYpQHsUzkAhzQRBmrZ7QHGPokDHLpRAByV2QDjbnUCYF8Q/\nhQi8PzSFs0BegHNAfVy/P/2CtEDnOoBAl4vcP23nv0CztdVAf2rcP7ubwEC+TedA2nIAQO0q\ny0Dkg+ZA8tLdP+xRwECBPvRAXKx0QP2CmEAO+Lw/DaZjQL6fokAFhvhA3J0nQG9kz0CZZP5A\nVYdeQPLSsUCOr+FAMIGFQOyjlECfdqg+U1xHQG5uekDl0KhA3sheQF9eckCreEVAfuNtQP2C\nhED61TZAzEVGQOQsekA7U9NApMKFQDvfl0AAAAAAf2oEQPZ6zEBolgNBthDYP28Sv0CKzahA\niGiBQGyVy0ADeFFAGqgeQCzZzkBi1vFADB+FP3NonUA+7cRAeGJgQNydb0DFPSpALxe5P/7U\nsEAFwPA/XtdrQLjMgECA8UZAQNlOQKzKxUDTEwpBMIGBQHe+j0C2uZk/yhp3QPGAjUB65CFA\nrDmEPzEInEC5U+9A7nx/P7Pvm0C8P9NAxsRYQDwxtEBKUg1BEydhQPtXoUC8P+RAwW5SQO58\nu0D+Nw5BG0xfQO9VikD8b8hAgZVjQD5ci0C78rlAOlhhQDwxjEDElKtAnWhhQHNosUDbv51A\nFOh7PwAAnEA1teFAOe5cP29kr0A1tb9AAACMQO0qh0AvaYw/VYc+QHk7y0B8GwxBnOFiQDPh\nikDb+ZxAAkjhP7gexUCjr8JAt5deQG9kk0De5dtAWK18P7Uao0CXHNJA1PFCQHhieECCqNBA\n2nJAQHNoeUDhKN9AxsRQQLR2gkDxurhAXTNTQDSFg0AhyMVAexROQLlwwUBuhsJA1PFaQDc3\nsUBBKwdBEydhQHGPrkDvOP1A18BiQH0/rUB06uhAVYd+QDm0jEAtJtY/ucJVQK5HhUBa8MlA\n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\nnkBxuFZBlucDQLwiq0CVAilB/tQYQG05uEBqEypBho9CQL3Gm0CrZypB+fcDQLpJrEAVkS5B\n+FMrQPcBw0Ce6idB/3g5QDjbiUAk1g1Bho8aQHnpfkCX/wFBeGIwQLubiEABhxVBWoEdQGGJ\neUDU5QBBjjsnQNhHeUCgw/tA2xYpQO7Ow0A/kRxBho8KQPilv0CNFx1BFvYoQPZ6yEDnYxNB\njjsfQMB4nUDFg2FBPzVeQECHnkDCwP9AeQbRP/hTj0BjKBJBLc/3P/ypnUCeB1RBiuUgQDeJ\nnUCMW15Bt5cOQPtXlUCI6DtBjbT4P3NooUAZkFZBgjkUQLlwpUCN7ltBBfomQG9kn0CrbFFB\nPzUuQHE9ckCIaORAoDcJQDAvwUDachZBvRg0QL/xqkB0XktBH6KlP27AokDy+wdBM233P3IW\nqUASWlJBvRg0QHsUqkAGDURB/MbbP61ulkBxvStBwATWP7Kdl0ASFB9BSYVLQKwcgkBwX+hA\n2xZJQPCngkBX7PZADB/1P3RBrEDXtFBBEHXzP+yjrEB1K1ZBvryUP7x0n0CCVgZBsKz8P3e+\nw0CzKQ9BtvNFQAAAnEBQKiNBpI3XPy2ymUBl5DBBMWwt/x9WIv8tYCL/OF4s/y1sL/85Sy7/\nZWtX/x1QIP81ay3/JFgg/0hjOf8cSxv/IWQh/zVzMv82WCz/Ilof/yZlJP8eTyH/Il8i/0dS\nMv9bbUz/V2RH/ylPIf9jY1D/UXBB/z9XMv9BYDX/O2Iw/xtZHf9TWjv/NV4o/ylZIP8cUiH/\nJlgf/zRqKv8jWCL/H1Qf/yVsJf9OVTv/K14k/0VgNv82SCf/IGYh/1JVO/9NZTz/O1gr/0Fl\nOf8paCX/OV0x/ylTIP8cVR7/I1Qe/xtLHf8ihyf/OF4t/ydSH/9fb1H/Jmch/y89Jf80Yiv/\nJ2Ef/0xmRP9FVTT/IF8h/xxeHv8eWyL/JEke/x1XIv84bSv/Pmkw/y9rK/8jYCP/I2Ei/yph\nKf8cUxz/Y2BM/1VrRf8hZyj/HFIf/0BfMv8mWh3/NFso/yZVHP9YZEP/N14r/zpxM/8/TjL/\nL1wm/09kP/80WSn/HVUg/xhHGv82bC3/LGUn/yBfJv8cTyD/NmAo/y93LP8eWSH/G04f/yti\nJP8pVx//T2M8/zNfKP8lcir/HmAh/zlZLP8mUB//H2Ei/xhYG/8oVR//UVY+/x5YIf8xVif/\nNWUt/y5aI/87XS3/R3g4/zN4Nv8kUxz/H2Ad/zJdKf80Yy7/JVQb/zRzLv8dUh3/WF1D/09h\nQP9bY0j/H1gh/xpYH/8cTyD/QGky/y9iJ/8hWhr/NVgp/1VXQf8iVx3/ImIk/x1ZIf9AUy//\nW2BH/x5cH/9VXz7/KWck/yZeH/83YCv/L1ol/19tTP8aVR7/R001/zpoM/8cUR//Nl8n/zZr\nMP8pYyH/Lnks/x1WHv8gaCL/V19E/ydaHv8kVhz/J3Ys/0xdPP9RYUT/IFgc/yNNHP8gYSL/\nKlMi/0hbPf8lVh7/HVUh/052PP8nWB//O1st/yFgI/8eVyL/HXoj/0RgNP89VC3/PWQt/yVp\nJP8xYCf/HVUe/xtQHv8vYyf/WlhA/zBHJP9EWDT/HFUg/1FbPf8qbCr/L2Ao/0FcMv8pUiP/\nLVMj/ydaH/8fTx//WV5F/zxjMP8odSv/IY8m/y5VI/8xXST/JHcj/yebKf8mmin/W21D/yiT\nK/8qZij/QGIv/0t3SP8sXSj/J2Ah/0lfNP8meyP/LFcj/y5hJv9bV0D/Qlkx/1RpOf8teCX/\nIp8m/zFdJ/9BXzn/K24l/0RVL/9GZTv/MWQr/01rRf84Yij/JGQg/zhnLv80Ui7/LXIo/zla\nLv8mYiH/QVgv/yOJKP9RYkP/Ql8x/ydmJP81Sin/Jl8e/zGCK/8ycCr/IGUe/yppH/84aSz/\nTmk0/yVpJv8giyT/IZEo/2hlSf8pWx//MYEs/0FcNf8oYB7/MHEu/y9tKf8fcyb/MGQn/yB0\nKP8xWyn/Q2wy/zZqKf8vgCr/Rl40/yphIv9MZTX/TGQ2/yBcG/9NaTz/JWIf/yJtHv8pbyr/\nP3Uv/1ZpRv8dWxn/S2Y2/ypWJv8wViT/WWI9/ySUKf8jYSH/IYYm/yCAJf8tcyj/KXAj/yOq\nKv8rjin/JV0j/zBpL/8wYCP/QmIy/05WN/8oaCH/JGwe/0FeLv8kpyr/OHAp/0NYNf8payP/\nIWwf/yV0JP8jeSP/Il4f/yWYKf8ggSf/IJYl/yGKKf84USv/P2Yu/zFsNv8rXTD/K2Au/yNY\nKv8rYC//I38n/yFdI/8OLQ//HT8i/ypJMf8XRhr/OXg9/yBAIP8nSiz/BBEG/0NTL/8wYjb/\nLXc2/yZbLP8oXiz/JXMm/xpmIP83eDz/N289/xErFv8eaSP/G1cd/x1MIP8hWSP/GV4b/xdI\nGf8fTiH/IEAg/xtfHv81czv/NXA6/xZBGP8tXzD/HTwe/x9WH/8oUi7/QF0w/zB+Ov82azr/\nKmIx/ypsMf8kTib/I4Qr/x9FI/8ybzn/LYIn/yZ2K/8uZzT/OXk+/x1jI/83dj7/SWM8/wUR\nBv8bKBz/GzMY/xyBIv8geyX/OGcu/xQvEv8pPin/MnU8/xpRG/8ecSD/ImMn/zmFQv8sUDP/\nHR8Y/yFMJP8iSh3/NXU7/yxhMP8qWi7/GSgb/x0eGf8taTH/JzAl/zh9Pf8xajb/JG8r/xlK\nGv8mXiv/JGEs/zNkM/8fcyX/MWc3/wseC/8oaSz/HGAg/yk9KP8nNSz/KWwt/zFvOP8eiCX/\nL2Ey/yFaIP85fz3/F1Yc/zNtO/9TVT3/JGcq/xtHHf8EEgb/OT8y/xAqFP8YPhf/HlEe/yVe\nKP8qTCz/M3Y7/zFpNP8iPCb/HGUg/wQRBP8dZR7/GWsb/yFJJ/8eZCP/GDQb/ypiMP8WShb/\nHkIl/zpKPP8wVyf/F0Mc/xE+E/8oUiv/NW86/ytdMP8YOx7/MWMy/zo+Ov8qXDD/HC4i/ypJ\nMf8eNyL/GnUe/wYVB/8fTiH/HlIb/yBeH/8tTCv/GCcX/xVGGf8UHBX/OodC/0BeNv8/XS3/\nMmc3/zBwNf86UjL/LXM0/yZYKv8giyr/G1Yf/xxQIf84dj3/EjwS/yBnJ/8vZjb/Hl0h/yZg\nI/8abiD/IV0l/wUWB/8pXiT/RXQ7/xRGFf8TPBf/FUwY/0RPOP8aSh3/Jk8p/wgZCf8jNiH/\nL1wn/zF6Of9FWDv/NHM6/zNuN/9IUTn/Gngg/2BcT/8ycjn/LHk0/z2CRP8hWiP/Nm09/yd1\nMf8OHQ3/LFAm/yJ/JP8gUyL/LWIw/ycyJ/8MHw3/MXM6/y1ZMf8EDgX/D0YW/yAuJf8oXTL/\nJlwk/x59I/8yeTj/IXMo/0ZhNf8xazf/I2sq/yR9JP8bSx//IHEj/yxkMf81fT//QVk5/0dW\nOP8xajf/TWo//x5yJv8vbDf/IEMh/1xhS/8qTCX/GkEc/ytiLv8NIAz/LXE0/yNLJf84Q0L/\nIEIj/0BaN/8ycjv/MnU4/z9oMv8hiSr/Ez8S/ydgKv80czv/Llww/xyII/8wbjj/GSsW/y2H\nKf8paS//HHMg/xtIHf8kVyj/Mmk1/yFhIP8tZzL/DB8N/x9zI/8/WC3/K24z/y5GNP8LJQ7/\nJV8m/wQNA/8lRyb/JYIu/x9pI/86UDH/WGFL/zF8OP8jdyP/KV0u/yhZKf87UjP/H2Yk/ydZ\nLP8sbDH/G24i/yBWHv8eZB//DzQT/xtVHf8LHgv/DSkP/y1kN/8LHQv/BA4E/1daQf8gKCP/\nLFkm/xVFF/8pWi3/M3c8/yNiJv8thzP/PE8x/0JcNP9DXTb/VlxJ/xlKGP8dSxn/F2ga/xhX\nG/8vbTb/aWVT/xx3I/8iWyb/BhEF/wkgB/8UPRP/NWgv/zZ2PP80bjn/TFA9/xtqH/8nOST/\nK3Qy/x9kIf8xUzD/P4dH/yCCKP8jeCX/SVM+/xxdIf8nYCv/JlIn/x98I/8pXC3/R1Y+/x1C\nH/8gTyT/IUUl/wgaCv85PDj/HzUi/ypJMf8XTRj/GTYc/yB0I/8yUDL/DR8L/xQ1GP8ycjn/\nNXA4/yh+MP8kbSn/Mm81/yNLKP8ofC7/HUwf/x5vIv8SMRH/M3U7/y9uNP8kVSv/JUEo/wQN\nBP8sKyf/Ijol/zN+Pf8wTS7/H3Yk/x94Iv9IWT//JE8n/ytgL/8hjSz/HlEi/xg7HP8WJRX/\nJDIm/yM3Kv8LHwv/FTIT/zNSM/8MLg7/Aw4E/yhVMf8zOSz/BA8E/yJQJv8lbyf/VlZD/z1d\nMv8ygTv/QWg0/xdpHP8dcyL/J2Qt/y1mNP8nYCT/LUoj/0BZNv82fDH/GnAi/zJxOP8uaTH/\nJlYt/ydqJP8fgSX/G1oe/yp0Lf8fVSH/GEga/yt4Nf8wbDj/HnEj/yhgMP8jYin/PGIz/xpM\nHP8pOCj/KXgz/yFaHv8FEAT/CyUO/zNqNf8XURv/Oj46/yJbIf8ZZRz/Hk4c/xMuEP8fUiL/\nH1gh/xxeIP8nbC3/LlMv/z2DRP8xZzX/RlE5/25qXf9FUDr/G28h/yBiJv87gkP/CRwK/zBu\nNv8kSSX/KDwr/ysrH/8dRBv/J1sk/xlKGP8aXR7/IEYk/zFhOP87fT//GWMc/zFyOP8ycjf/\nJ1st/yg2J/8UNhn/Ml86/yNDJ/8cTh3/HB0c/zh2Pv8ceSD/CiEL/xAVEf8xdDj/Jk8p/zM/\nOP8nUir/DiQS/ydBMf8zPTD/K2Y0/yVjKP8URxX/GFAX/zR6O/8yazb/HDsf/yM3Iv8FEgX/\nIU0k/wwfCv8aNx3/Ii0n/xkrFf8mcCf/HGsg/wsaCP8HFwn/MWg1/yl+MP9HTzT/KV4v/yKb\nKv8iaSr/OXYw/yRjIf8ZZiD/IFUj/yBsI/8mbSb/MHw3/0plOf8XYBr/Mn08/ypmMv8uajb/\nIZYp/y14KP8gZyL/Hisi/xpPHv8mbSb/Jm0m/zF3Of8zaTb/M247/ysyJ/8QHRD/H00i/yBX\nIv8mVCr/N3k+/yV0LP8XXxv/M3s8/ytgMP8vXDD/HGse/yRpKv9CcTb/HHAl/y5gMP8EFQT/\nJV0j/yNiJP8xPDP/MWo2/1pfTf9MXD3/FVQX/ytoNP8qZjL/I08l/yCPKf9IWDf/HFQg/yJb\nJf8XUBj/P3xG/0xQO/8kdy3/bWZX/xlmHP8hSiX/IF0m/ydcLP8zXS3/L2Um/xpcH/8WSxb/\nOVE6/zBiNP88TDL/WFxJ/yt1NP9VZ0T/FmAZ/yFIJP8dViX/X2RL/x+IKP8aVx7/Pnc//xg8\nHf8bTxz/EzsZ/w4rD/8zbDv/HVEh/zFlNf8dVSH/M3A7/yxcNf8oPy//Cx0N/yUwJf8sLCf/\nGVwg/ytlMv8tUDL/BREF/xdoG/8PNxP/OEQ8/zJnNf80dDv/MWc4/yJxI/8SKxT/AxEG/y9q\nNP8zbTj/J1gt/xgrGf8XNRn/Iy8k/ywrJ/8OHwz/H04h/ydbLP8aQh7/H3Ej/xlFH/80bDr/\nJlUn/2NURP8WUhr/Mogq/xx1If8dWyP/I2Mf/zl0Pv84dDz/J2Ut/zBdKP81djr/Nm4//zSF\nPP9DYjX/FGMW/yRrK/8lYCn/LmQ1/x5jH/8lLin/ImMh/zt6QP8eciP/N3dA/zt5Pv8sfyv/\nIpUr/yVVK/8xbzn/MW42/ypzJ/8efSX/HWgj/xtsH/8aTBz/IFsi/xdEGP8NHgv/JHUr/yty\nNP8lXSv/GDoc/zl1P/8pWiP/Mlgv/x8tJf85QzT/NXw//x9mJv84Ziz/Mmg2/x17Iv8qXzH/\nG0Af/x+LKP8cUiH/KXUn/yOQLf8rXCr/Im4o/ytlMP8uhiv/GU0c/ylkL/8rZjL/F2Mc/wgX\nCP8tZDf/IjUm/yJMJf8ufDf/F04W/xVRF/8PJA3/DisQ/yR0KP8uZyf/ME0o/xhkHf8NEg3/\nJl0p/ytRL/8ZGxT/Hh4d/x0lHv8YQhn/FkoZ/yM6If8hKib/MW04/yZNJv8uZjT/BA8F/ydo\nLf82bzn/MXA6/yxZMv8lYyj/ECwQ/zmGQP8zbDn/I0kk/w4lD/8UPxT/FU0X/xQtEv8OLRH/\nLmYz/wscC/8vXTH/Jiwl/wQPBf8jMCf/K3E0/wgWCv8QHQ//DDEN/yNWKf8zcjv/GjcY/zd3\nP/8ZRR//GFgb/zd2Pf8wYzf/NXA5/yJeH/85ez7/IGEg/xdTGf8XUBv/S046/xhjHP8ley//\nI1Yq/y9lM/8imCr/J1wf/yBWI/8sejb/IWso/zR4O/8nYCP/G18c/zBpNP8WTBb/IHAl/yOI\nLf8jVSr/NlAu/z1IMf8aYh//K2Iv/y5oM/8fYSf/JnIm/x10I/8ddST/Gkgd/yBXIv82fj7/\nLmk2/ygvKf8bKx//ESIQ/z1DNv80eT7/K1s2/y9GL/8xcDn/BA8E/ypDKv85fD3/GVge/y19\nOP80bjr/TVo7/xVYF/8gRyL/JWIu/y5oNP8rYCf/Gz4d/xhQG/8zfTr/NHg7/zV4Pf8hRyb/\nKF0y/yg+KP8VJBT/Gk8Z/xxSH/8dJR3/IkUm/y1zM/8sYTP/JW8q/ylfJf8vczX/K2Ev/y5n\nM/8WLBP/Hlkg/zx/Q/8TTBb/HWof/x9WH/80aTb/K1Yu/0hXNP86ckD/MGo1/y5MKv8ngSb/\nH3sl/ylhMP8oWi3/JXco/x1XIv8kTCj/H1El/zZzPv8jVij/MWU4/xUzGv8kRCv/BA0E/y97\nO/8YJh7/HEIg/xZDGP8gdCP/KUEo/xQyF/81bjz/MGs4/zFnOP82Wyv/P1ot/zZ4Lv8xbzn/\nLX4o/yxzNf8uZjX/J1Yq/xdQG/8eTiP/HlIf/w0lDv8gNSb/Fj4Y/zVyOv8gNSj/Ikwl/xtj\nJf8xdjf/H5ko/xU2FP9GVUP/HF4f/zBcMf8eNCL/MnU5/x5yI/8YVR3/Hzwj/w0eDP8iMSb/\nK10k/xloHP8UVhX/Nng9/zVuOv86dz7/J1Up/ycwJP8OLxD/J1Qs/xsdG/8eLCD/HGwd/z5b\nMv8gcCb/S10//zRqOf8HFwj/R2U7/x5UI/8uYzD/OGgv/1hVQ/8cLhn/Hnoi/xpuH/8RMhH/\nJl0s/zB6O/8USRX/RlI6/xpqH/8keS3/M3E7/yVVKP8xbzf/H2kl/yVZLP8mOyv/PVcx/yNa\nKf8gYCX/NFol/yJ7J/8XTxn/GUUf/zh+Pv8+gkX/HEMg/x8zH/85ekD/H1Ak/x4pIf88eD//\nGmQc/xdYGf8vNy//CRkJ/ytjMf8/fEL/JU0l/zZuPP8baCH/G14d/xp2H/8bMRr/GTMd/xZN\nF/8fXx//OHU//zRmPP8FEAb/NF4q/xY5G/8idif/LGY0/xVMFv85ez//MWg3/ydaLP8kTCj/\nCBcJ/y46Lf8bJB3/LmIz/2pfUf8efyP/OGIr/zWAP/8ubTX/OVIx/zZOLv8edyb/K2Ux/xtN\nHf8cTRz/G00f/yZxK/8rdjH/MWc3/yhVK/8qdDH/LH8r/yFOI/8baiD/JZEv/ypmL/8vZzX/\nL2Q0/1pVP/8VVhn/NG85/ytbLv8sYzL/Ikcl/x+JJv89hjT/J2Ms/yRuIv8dVyL/IlMm/ypc\nK/8dcCT/GG8b/xdNFv8OMBH/F1IY/ydiJP8ODwz/LVAt/wUOBP8WIhn/K3M2/yIsIv8ULRD/\nHWQf/yJtJf8aTx7/Hywi/y5oNP8nby3/LXos/x99J/8oUy3/JGoh/xtcIP8vazf/PHlC/2Nu\nU/9bYEn/G2Yf/xtBHv8sTCn/HmUl/yR+LP84gkH/N3M9/ytcLP8lXyn/GUod/ypTKf8lOCb/\nGV4c/xwkF/8aPR7/CBsJ/zJnNv8kSif/EB8N/xlLG/8xZTf/Ez4X/xQ8E/8bZR7/Gicc/x4f\nGf8VNRr/VlY8/xlXHP87dUD/K0Qn/0hSOv8hSST/IWUq/ytiMf8bPyH/I2Qg/x5fI/8cSh3/\nHWQg/wsaCP8tZjP/K1wv/zNqN/8gaSj/GGod/xApEv8xczn/L201/yA/H/8rTjH/BhMH/yY9\nJv8zTSn/HkQi/zJ7PP8WTBf/Fzoe/wwjDv8qLif/L183/y1dN/8FDQT/BREF/y+EOP8kbCv/\nMFws/xxaH/8VUhf/MGQ4/xk/Hf8iOyf/OXw9/yNcIv8UVBb/Imom/zd1Pf8FDwX/FycW/zR4\nO/8WSxn/F00Y/y9NLf8wZDP/Ll0w/ztbMf8mViz/SFQ+/1NcRf8shTX/Olsv/xVjGf8rYzH/\nKF4t/xt2If8vXDb/KSsl/yUxK/8dQxr/MWw3/yQ5Jf8tRC//VV9D/xU3Gf85eT7/LWgo/zxJ\nL/9MXj3/MXs3/yB1I/9RWET/MHE2/x5rJP80dS//HYEk/zN8O/81bjv/I2Ih/xxlIP8nYSv/\nKVov/y5kM/8pYiT/EUIV/zRCNv8yZzb/LWIw/yJOJ/8bLhv/MnE3/zZvOP8tbjT/LGMx/ydb\nLP8eOyD/BhEG/ztOQP8kLiP/CRsJ/xthHv8HHAb/NVs0/xpPHv8YXBr/Cx0L/w8UD/8GEgb/\nH04h/xdGGf9MXDT/IkMi/y9mNP8rUC3/NmY9/yM2Iv8rKx//HUUb/1dXPf8ceCH/NXE7/yiF\nJv8eViL/KFwr/yJsI/8iTST/BBAF/zZ7QP82dD3/Izgi/y9KJf9SbUT/XFtH/xhvHP8faib/\nHlck/zFqOP8oWCz/JVIi/y58M/8xYjb/HnAi/xxbHP8hWR7/G2oe/x1zIf8jRSf/L4U4/xo5\nH/8vXDP/IEom/yk0LP8ycDn/J3Qt/1RUPv82fT//MWk3/zFrN/8kcCn/JFkm/yFQIv86VDL/\nXlVC/yZxKv81gj//OHE+/xRFFv8eUx7/FEoT/zRkOf8sYC//PXg1/xtyIP8lYCj/J1Ys/yxq\nM/8fcSX/J2gi/xhfGv8TOxn/Fk4W/0CBSP8zgDz/GmUe/1NjRf8mXCv/NXAt/x52Jf8lZir/\nOXI+/0VONv8WWhn/IZEn/zJwN/8kZin/K2sj/x5gJf8hUST/Jlsp/xZNGf8uYTL/Jngp/yKR\nKv8nbS7/Ik0p/y9sNv8ycTb/KXEm/x10JP8feCb/G0gc/x9ZIv8mcy3/RlI0/zd2PP8beSH/\nOG8w/ylXK/8cbCL/I2Yh/wwaC/8xfzr/VVo8/xdnHf8taDT/Hjge/zKKLP8gmCj/Gkgc/yVk\nLP8bQx3/L2My/x92I/8qZi//F0MX/xUwEv8xYTj/JTol/xM9Ff8fWh//LUQv/y5wNv8qWCz/\nGDwe/wUTBv8sbin/IWcl/zJqNf9WVD//HXIf/y1+NP8cTyD/M3M7/yNII/8ePSH/NW04/xlO\nF/8xaTf/HjYh/z9DN/8GEwX/J2Qt/yQwK/8cOh//GCcX/wYVB/8iSyX/EDEU/zRzOv8KKAr/\nBBEG/wQRBP8hLyf/KWIk/ySELf8jbCT/LHo0/y9qNP9BUzr/L2Y1/0NQNf8jfCT/H4Qp/yth\nMP8aZR//Ilck/ydrK/83gEH/NnM6/x19Iv80ey3/J18q/xU0Gv85ckX/HGEh/xpzIP8vVzL/\nFjcU/zlANv8zcTn/GVIb/zBvKv82gj//MGQy/0lcQf80Uy3/KWEt/yhbLv8iUST/G3si/yA/\nG/8SPRT/Dh0N/zNxOf8xcDn/LFgv/wYTB/8RKhP/CB0I/zJQM/8xbD//CRkM/x5vIf8OEAz/\nMEon/xtFFv8wbjn/LFAu/yZIK/8gJiD/GFIY/zuAQv9MUj7/YFxM/yVbKv8oWi3/IGon/01f\nQP8feSb/NV4p/zN4PP8TOxn/BA8E/yRIJf8qSCb/DjES/wokDf8mPSn/Hy4l/zZuOf8JIAf/\nSmJC/zx8Q/8ybTn/LEYp/xhtHP8zcDz/IEQo/yoxJf8cKSD/K3A0/x5aHv8ydT7/KmEj/yZa\nLP8lQir/BQ4F/yIwIf8QShj/BRAF/yMnHv8dQxr/BhUH/xMtFP8vbzr/JEos/yw0K/8sLCj/\nKkMq/y1jM/8eSiT/NXQ8/ylcMf8jOCX/BQ4F/ywrJ/8lPij/ECIO/y18Ov88Vyz/G1Ib/wMO\nBP8xd0D/LU4x/09aP/8wezf/ESoT/yIwI/8gLh3/GiwZ/wYbBv8qXiz/CBgJ/wsUCP8MMw3/\nBhYE/xIeEP8LNw7/Eh8S/x1/Iv8IDgr/GU0c/xJTGP8EFQX/BA8G/wMNBP8XdBz/DhkM/x2S\nJP8hZiT/HYcj/x9DIf8ECgL/F2IZ/xp9H/8KHAf/HpIn/wkUCP8zUTL/PGY4/wQVBf8IIwn/\nEDwT/woRCP8EEgT/JEQl/yBcIv8fiiL/HVEd/wIUBf8KMQz/AgsB/wseCf8JIgr/IFwj/xck\nFf8oXCj/CSYI/wkSCP8cThv/G2og/wswDP8HDAb/AhUE/xyMIf8KGAj/CBME/0JwQv8geCL/\nFiIU/xqLHP8GGAr/JUYk/wcXBP8HFwT/Jj8k/0JxQ/8LMAz/FBwT/wkSB/8aixz/Aw0G/wUS\nBP8ccB7/GCMT/wILAf8iSyH/GHgd/wgVBf8geyT/HXMi/yCVJv8lVCb/BRIH/y1hMP8Zax3/\nBhwG/x5rIv8WRhf/MF0v/zRmNf8bbSD/Ii0i/zdlOf8ffyf/Fkkb/zFQM/8CCwH/BA8E/yI3\nHv8mPiX/CBQJ/y5VLP8QJxD/CBEF/wgUCv8QHxD/BhEI/wUWBf8IDgb/DxUM/yVII/8GDgX/\nDBgM/wcXBP8LIQr/LFAp/zBZLP8KLAv/JH8r/y1DK/89Zjr/CSML/zJnMf8SIBH/LGAr/xdP\nFf8sYC3/MF8v/xxcH/8LEQv/FB8Q/wkhCf8vVjD/Jkkl/wQVBf8RIxH/ChUI/wknCv8epiT/\nBBcG/xtpHv8HEwX/BhoF/xEuEv8adB3/EBwO/wgUB/8GEQT/CSsL/xZGGP8IFgj/DxkN/yhp\nLf8PJQ//EkIT/zVLNf8aixz/GGUb/wgNBv8RUhT/CB8H/yNEIv8KFAn/Jm8q/yAwHv8OFAz/\nBQwE/ydDJv8mriz/BQwE/xyHIv8RKw//NGM0/z1tQP8iMCL/ESMR/w0VCv8HHgn/CBIG/x4p\nG/8WIxP/HpMk/xokF/8DFwb/GHwe/wQPBv8EEwf/G4Ae/woWB/8WJhX/LEcm/zxsO/8OMA3/\nBxYE/yVbKf8TZRf/IWQo/xhSFv8OHQ3/OGY2/wYWA/8jZSr/H5cl/wYSCP8DEAP/DRgL/yNe\nJv8hmSj/Olw5/yhXKv8ekyT/BxQJ/wURBP8FGwf/I0Uh/zZsNv8JEgn/CC4L/xZyG/8chCD/\nChcI/zFgMf8ZYxv/HXAh/ytcLf8fmCX/CzAM/wseCv8KIgb/BAwD/wwmC/8ZZRv/BxwG/wIJ\nAf8ECwP/ChEI/wgNCP8XPxX/Eh4S/xwoGv85ZTj/EhsU/yRiJv8eVCD/DRsL/x6CJf8IHwn/\nCA0H/w1CEv8IHgj/HX4i/xtvIf8FEgf/GHId/yBcIv8HDQb/SXpK/yFAJP8XUBj/BA8G/wQS\nBP8fjyj/BA4E/xxwHv8NEwn/O2k2/ws1DP8oVSj/GiUc/zFZM/87bjv/Ji8k/wseCf8TYhf/\nMWIz/yNGJf8cgyP/D0ES/xqLHP9Ba0L/CA4G/w8UDf8FEwP/JF8o/xyFIv8ZKhb/NF82/xEc\nEP8oRib/OGU5/xUeE/8qUSj/K2Qr/yZOJf8JKAn/BxsH/xdhGP8PHA7/M2s1/yBKI/8RHg//\nBAoC/wgQBf8hKyH/M1ww/xyRIv8cjCH/ChoJ/yGLJf8glCb/EiEQ/wUdBf8dKRv/GV4b/xQz\nFv8mUSb/CBYG/xVbGP8GFAT/N2I3/xYhEv8SHBH/JUkj/x8tG/8kXyX/IGsl/yZ7Lf8uRS7/\nH4om/yZqKf8NMA3/DB4L/x90Jv8lWCb/Aw4G/wQSBP8MEQv/Ipor/0NsRf8IDgb/RXVD/wYO\nB/8CDAL/CSgK/woPB/8EEgT/Iogj/x5cIf8GEQT/NFw0/x1OH/87Zjj/EBgN/wgRBf8qZC3/\nLGEu/xIcEP8ZJxj/H0ke/yZbJ/8agyH/AhEE/wYTCP8IEwj/CSkK/wkoC/8aNxr/IzMg/w4Y\nC/8KFwj/JKcq/yGVJP8lTiT/DCYM/wMTBP8PGw3/H2Mi/xEwEf8UXBj/JGUl/wQSBP8lSCP/\nBA4E/wgTCf8EEQT/IGAj/yJDH/8QPBD/HHAe/wUZBv8HFwf/CBQG/wsVCf8eKB3/GSUX/x9a\nIf8bKBj/D0oR/wwhCv8GCwb/JV8p/ytTKv8jSSL/HIgh/xuGIP8KGgn/ChsH/xAcDv8HFAb/\nJlwo/y5iMf8bhiH/IE4f/w8oDv8GIAf/ERoS/wQVBf8iriv/IHQk/yGZKf8aJBf/Klos/wgf\nCf8RQBH/DSQN/xwmG/8CCwH/GG4c/yKCI/8bLRv/K10t/xcjFf8VMRf/CBMH/wQLA/8GDgT/\nHHAe/xs4G/8SFxD/GSgX/woXCf8ocir/ChcH/wURBv8CEQT/Aw4E/wILAf8MJAv/G30i/zdk\nOP85ZTb/G1Ac/xAfD/8cVB//I2co/wgQBf8pQSf/Gmoe/0JwQ/8JIAn/DS0P/xIzE/8bWRv/\nL1Qu/wooCf8GHgb/HCoa/xsmGf8tWS3/H3cg/womCf8XPxX/HHAe/xyII/83XTX/CiIG/wcO\nBf8GDQT/Gosc/wojCv8EDAT/AxAE/yKgKP8imCb/KG0r/xYvFf8UHhP/Bx0J/w8eDf8CDAL/\nBxYI/wQXBv8GGwf/HYsj/wsjC/8nUib/BBIE/xqDIP8WZRX/IX4o/yesK/8jPx//HDAb/wcX\nBP8ijiX/BiAH/xx+Iv8hiib/N1w1/w0mDf8XIhj/HIMg/wILAf8uXjD/CxAL/yhlK/8GFgX/\nHGgf/yKII/8Xdhv/CSgK/wYgB/8HDAf/Omg6/wkWCP8GIAf/DxcO/wkOBv8hZCb/Jmst/xt1\nIf8eZyH/H5Im/xgjFf8aJBf/H1Eg/yJVJv8Xbxj/G4Ei/xmEIP8EEwf/Imkk/xd3G/8gdSH/\nCCII/yGRKP8kkSn/HHYh/wo2Dv8fdyD/Floa/xxtH/8MIgv/CBwH/wsRCP8iiCP/JEkk/y1X\nLP8EDAT/DDYO/xVRF/8HIAn/CRYI/w0SDP8cQCL/J0gi/zdiNf87azj/CBQH/zFZMv8IEwr/\nIi8j/z1nPf8KFwn/MGYx/woiBv8MEw3/CBIG/wUQB/8LEwr/BhoF/ypYKv8ccCH/OFU0/woi\nBv8MEwz/CBMH/ypPKP8kLCL/EDkR/wkXCP8IEwj/Jjgk/wkYCv8EEAT/PWE6/wgdCP8WWhr/\nHHMh/zdjOP8fNxz/IFIg/x0mG/8QHg7/CBoF/w89D/8GGAb/M2I0/yAsHf8WSxb/CA0G/wgY\nB/8rXi7/AgsB/yhTJ/8djiX/CQ8I/ypVKf83Xzf/NWU3/zpkO/8kXST/HFUe/wQSBP8ROxL/\nFCcT/xyII/8QNxD/HoMh/wgfB/8JEAf/OGAz/wgNB/8JEwr/ITYh/wcSCP8jLiP/Gy8a/ytD\nKf86Tzr/GGsd/x5UIP8gXSH/Iogj/yBiI/8IEQb/Bw0F/yMyIP8yUzL/Floa/xpaHP8iLCH/\nHDEa/w0vEf8eKhv/GCUW/xkoF/8GFAX/EDUR/zdcN/8wYTH/H1sh/y9MLP83XjT/P3I//xZf\nG/8WThf/HHAe/x9YIf8rVCr/JaUo/wUgCf8FFgX/NWM1/wchCP9If0v/RndG/xc5F/8HDwj/\nBhIG/z1rOf8gWyH/Aw4C/0BmP/8oVyn/HIgj/wsnC/8gVyL/GCUY/yJqJv8NFwv/LUkn/yhZ\nKP8IEAf/P28+/y5ULv86Zjn/MFEs/xgkFv8EFQX/ESMR/wgNB/8gOR//NFoz/xhuHf8NFgr/\nCiQJ/wkSBv9LgUz/L3gz/zBSLf8ZUhz/Cy8N/zBpMf8cJxv/NlA2/zFjM/8XIhT/Aw4G/wcX\nCf8EFQX/ESMR/xAiDv8JDwr/Hywj/wQXBv8mTib/Ag8C/wILAf9CYkD/ChwM/xZdGv8WHxT/\nMVQy/wsmC/8HDwf/EBwO/zZmNP8MOw7/KFUp/xNMFP8VJhT/I0wi/wgVB/8iLiP/EFAV/wgh\nCP8mLyj/JTQl/wseCf8IGQn/O2U7/wQPBv8FDwf/AhAD/wQYBf8EFQX/ESMR/yI7H/8dbyH/\nIIck/wQTBP8NGgv/CRUI/w9HEv8OFw3/BhoF/xMeEP8jYCb/CRUG/yMvJP8EDgT/AgsB/xtv\nHv8iqir/HpMm/wwtDP8kYCb/HpIn/x48Hv8LJg7/F2Aa/wgiCP8GFwn/Hpwl/yGLJv8edCT/\nGosc/0qETv8EDAT/BRcF/yRJJv8MFAr/HFId/wkSB/8eYCL/GyYZ/w8bDf8lTiT/F3cc/wMO\nBP8GEQb/G1of/w8XC/8GEwX/CBMH/0FIS/8lLTD/H0Ig/0ljS/9cdFr/KjQs/yxCMP8WGRf/\nRGU//0pjR/8cHyT/JmAp/zlrRf9Ag03/GTQZ/1yFWf85PUL/QoVG/09vTv8QFBH/VmlS/0tV\nU/9WaEz/MDs1/19xWP8/a0P/V2di/w4REf9AZT//OUcz/yxcMP8rVi3/FiUY/2SRX/8zSDT/\neZaH/1prXv84cz3/aXlr/0NISP9UWl7/P0RE/2l5a/9VcVH/XHlY/2KGX/9DVkX/bYlq/xsk\nJ/9Ydlj/XHFc/zBgNP8fOB7/LDE3/z1CQ/8nUib/SWlA/1GYWv88dj7/QWpF/x9CIP82WzH/\nExgT/yQxLf9KTk7/YHdf/1x7XP9odmH/WYla/y83N/9Oe0v/DQ8N/y0yM/86QEH/EhwT/yJA\nH/8lKSj/RGo+/zFnNP9vemP/QmVA/ypaLf9Wb1H/PF04/zxgO/9bcEz/OnA9/y1vNf8yUzD/\nSlFR/zBqOf8aIB3/Sm1F/1N3Uf81YTT/aoNh/0BiP/9aaEf/a5Vq/zViOf80dDv/NGw5/01/\nTf8uOyj/R5NR/1R4Sv8ePB//dXt8/0ZlSv88TEz/PGxD/2h3Yv9JUk3/L1Yv/zZrPP9Pfkn/\nNXI6/zRtOP9BgEj/VXdR/0ViPP9fc2X/YH5d/ztzO/9dalz/PG89/0GDQv9ddVz/Jiku/zxj\nO/9XeVb/QWk5/1Z+Vf9KeEv/O3g//0uQUv9DbEP/OF03/zh1PP8gPBz/ESsT/x8mJf9LXkT/\nSpNR/0VlSf9OlFf/Xnhg/ylWL/83QTj/K18v/y1jM/8aIRz/SnhL/zlrRf9Ag03/Un9S/2qY\naP8gPh//QXFL/y03Nf87dUD/HDge/wsPDf8UFxX/Mmw2/1liS/9MbEj/KmEz/yBAIv8rLTH/\nGjAd/116W/8jKCn/GB8e/z1hOP9df17/PXBC/zlpO/8yZzn/NnM5/xwfJP8hPx//EBYV/zVr\nPP9EcUD/UWxN/zNiM/9ommj/SWpK/ywxN/8uMTP/KWgr/ys4L/8cMBv/R29E/zpvPf9KeEv/\nGR8a/zBrNv89d0H/Z49o/19zZf9olmP/KlQo/zBtN/9ijmT/PWY6/050TP9uiXj/P3hF/1F9\nTP9kkWD/U2ZU/12AXv85a0L/X4Jd/22Nev9mk23/dpWC/09uTP9VclH/MmU2/ztyQP9Vflr/\nVG5Q/0dfR/8qZCz/UmVY/zl+Qv8MEQ7/Hy8h/zp/Qf9glmb/RYhL/1JtUP9IbEn/RW1C/111\nXP9og2r/U3JP/1WCW/8WJRj/UohN/0dlQv9Efkj/PXZC/yxfL/9UbE7/Q2xD/zljPP+Efmr/\nX5Fl/zptPv9fg2P/M182/0t4SP8wZDf/UZJa/011S/9Ca0H/TVtF/ytfMP9BeUL/OXQ9/zQ3\nOf9zlG//Un5V/zd1O/8xZzb/IT8h/155Vf8zbzn/Ljc1/zIyNf8/Zzr/JSUp/xEYEv8VGhf/\nTHZH/4eUfv8mNSD/OFk2/zhyP/88eUH/QnVG/1JWUv83bTf/KC4u/0JESf88Q0X/Hh8e/zFm\nNv8oYTD/KFAo/xwfJP8QFhX/ExYT/ypyOP8hQiL/MnA6/y1oNP8+ZT//NF43/y9jMf9JYVH/\nMjMz/yRGJP9KeEv/QVZO/0J0Rf83czr/TYNM/yhaLP8SHBT/Qm1F/0hjRf9JjE7/QIhJ/ytp\nMv8pViz/J1kn/xgeGf8OEQ3/Ql87/1iCVf9efVr/U3NV/zh2PP8LDgz/Iycq/yosLP8tLTD/\nIioh/xQYGv8cICD/bI50/3SKe/81aTr/QkdJ/ztDRf8bHiP/KEsw/0mETP8tTS3/MGU0/zd2\nPv8xaDf/SYJO/zlyPv8yZjj/aJRu/0lMUf9da17/OmZF/zxMTP8nLi3/GxwY/w4PDf9WflX/\nFxkU/w4REf86gD//PUBD/zt7P/8tVjX/NEE9/zx1Qf9BaT3/OHs//2yOdP9XeVP/TF9U/zxv\nPf90inv/T2RS/0JETf9iaFH/bG9U/0RaPf8zaTf/Zotr/0JlOv9edln/KWgv/zRzOf8kVij/\nHSQn/x00Hf8pLyn/On9B/xs2IP8iQB//GB4Z/wsPDf8ZNxj/PYZH/02QUf85a0X/QINN/zZD\nP/87eED/RmpC/0djQf9RglT/ZI5g/0KJR/9Ogk7/UY9V/02GUv8pSSz/FhgW/3aNf/9WYlr/\nDQ8N/yotLP8uZTP/GTcZ/x0gHP9ZeFr/KTQj/1SYXf86aTz/OWI4/1F8Tv9Bf0X/QYBN/06Q\nW/8sZjj/KGAv/wgLCv86ZkX/Yn5g/z1pOf9XeVP/WHFm/1t+WP9FYzv/ZqFv/0prSP9QdE3/\nOHtB/y1bMP86dUH/PYZH/ytYKf87fkH/QmVC/3WLc/9zenn/LmIx/1B+Tv9CbUX/R5JO/zlr\nRf9Ag03/X31d/1hxVf9Vb1T/NWQ2/2V1ZP9kgFX/V2Nl/1KTW/9WYlr/TVhQ/z9nPf9beVH/\nQ39M/zphNv8rOC//bIV1/3SKe/9fa1P/UYJP/2l5a/9Bg0j/Wl5R/yxfMf9Zflj/UoZY/3aI\naP8fOCD/N2o7/x06HP81dDr/N203/2ZpVf9OcUv/Rl4//1BlSv80bDv/Plc+/0x2S/88Sjn/\nKVov/1+hZv9XgFr/UoZY/0x1Tv8rSiv/VIdT/0dPV/8/a0P/SI5P/0ZaP/9tnG3/Nm48/zRX\nNP8xbDf/O3k+/zVqO/81eED/SYtR/1RuUP8wMjT/UHFa/zAwNP9Vglv/JSoq/0VQSv9EXjv/\nNHM7/zFsNP8hUiX/HCAj/yVRJf8wMzP/RmM7/0RvQP9Fi0z/NXA6/0RfP/9vbVr/Q4JJ/yow\nJv85eT7/K14r/zRpPf80cDn/ZIBV/zp+Pv81YTr/XHFc/zA1NP9ng2H/cH9m/1uEW/8vZTL/\naXlr/0lNSv80cTj/M3BA/zFmNP8kKin/UGNR/x8vIf8hPh//GB8f/0NrQf9Gg03/fZ+J/1ts\nXv9FYUf/Okc7/zZ4Pv9bhlv/Mmw5/zM5QP8kMS3/OHE9/ylbLf8vYjL/f6OK/22Nev9NVVH/\nL2Iy/ylWL/8RGBL/NnQ6/xohHP9qdl3/VnxV/2iIZP9bhVn/TIlU/2R4X/9mc1f/X2tL/0hy\nQ/87fEH/UI1c/0BuQv8uZC//TFdQ/y1mN/8jVyj/GyQn/zxvPf9UgU7/MnE1/2qOdf8/bUr/\nFiwZ/zp5RP8taDH/TVVR/z5CRf8dICT/T29U/0tmSv9ecU7/V2Zh/zhzPP9EgUr/f6OK/1Jt\nUv8/YTz/RZBP/1+VYf9kkV3/aZNq/1RrVP81cjv/ToJN/0VhR/9ag1j/N3Q9/zJsOP9TeVL/\naIhk/1dwUP9kgFX/RmtF/0xzS/9DbEP/SW0//2iUZv9XdFX/QWQ+/zV4QP8zZTj/aIhn/0dv\nRf9BUTn/T4VO/zxYOf8uYzL/LV0w/0VQSv89hkf/R2tD/yk0Kv82cTz/JE8k/ys4L/9XdFP/\nHDUe/yJAH/9AY0D/RWM8/0ljTP9MbEj/SGZB/0NsQ/9dgWX/SW0//0JtRf8yNDb/NG89/0Zq\nPf8xcTn/bY16/zRnMf9IUUT/V4NX/1qLXv9RhFH/OXZB/zNwOP9WVUP/RYJJ/1mVYf9ZclL/\nRnBC/0R0RP88ZDf/IEAi/1J2U/9SgU//O3M//0JtRf8jKCn/Ll80/2l5a/9JTUr/aHhf/0xv\nSv8yNDb/R09T/1CCTv8sLzH/Lmc0/yRII/8rVC//FBga/yMrKf87QkP/GTAb/wkNC/8VHBr/\nV29R/yw4L/8OERH/JFMn/zJuN/8+bkP/LFwu/y8zNP9sjnT/Sk5O/z9HRv8mVCf/PX1A/1lr\nUP8kJSb/MWUy/zNYNP8uQDL/JVAl/0BpOf8TGhf/PExM/zt2P/8tYTT/ZnRg/1Z+Vf9CSkX/\nQUZA/ys4L/8eNBz/ICQo/0tVU/9cc1f/NDU3/zI0PP87dUD/TpBb/0CFRv8cHyT/IT8f/xEY\nEv8vbDf/TX1M/0hjR/9Hkk7/QWpF/1lgTP8+hET/WZNa/0JtRf8+PkH/JlQn/1eVXv9Dikz/\nN3E//zJjM/9tblv/VGtR/1l5Wf9BXzv/ZWtN/0tiRv9EaD7/QGA+/z52Rv9Hkk7/UX5P/158\nW/8+ajv/R1dC/2SOYP88P0P/P2pK/xIdFf8rTjL/ICUk/xEYEv8xNDj/LDcv/zhvQf8SHRT/\nIkAf/x8iJP8xbDv/LjAr/zV0Ov8vazf/VZlf/zZjOv9KcUb/UXxP/1ODVv89cz7/FRkb/1WJ\nU/8nUib/XXVc/ylULP8QGBL/GyEi/xQZFf8vZjL/OmxA/1qAW/89hkf/LzAy/0ltP/88bz3/\nQ2xA/1F2UP8yVDH/OnhB/zZwO/8/eEH/Hzsg/xUlFP9FZUL/R189/zFsNv87fEX/ZIxh/zp3\nPf9ggFr/TGpJ/09oS/8yWTL/T39S/zl0PP80XzX/V3JU/zlzQP9FYD//RXFE/01YUP9ValL/\nLzIx/z90Q/8VGhX/NDc4/zpxP/9Ie0j/HCMb/woNCv9Yk1v/RGZD/w4PDP9CRkn/KFEr/zBu\nPv8OERH/T29V/0xfVf9FWEz/MWo2/050S/9XeVP/PHlE/1RjV/9flWD/do1//3SJaP8/TDr/\nW3NM/0hxRv9CfUT/ME8v/3+Pbf9CgUP/ToVQ/1ugZP9dc1f/Q2hA/z91Q/8tYjD/UH9O/ypX\nLP9Fekj/UWlO/0J5Rf84cTr/M2E1/2SAVf87Xzj/WH9W/0ZlSv8xajb/aH9q/26BZv85b0D/\nNXA7/yIkI/8TFhP/JCoo/yAlJP9fhF7/PkNE/zNpNf8vZTL/Fxsb/x5EIf83P0D/FRgW/z52\nQv9kkWD/PkJD/xAWFf9IZ0P/RnBH/1mJXv9UbE7/WHFm/z16Qv8rWCr/Dg8N/yo6L/8nWSf/\nNXE9/4d+bP9RgE3/JDEt/3SKe/9KTk7/c45p/z52RP88eEH/OndD/zRfOP87cD3/dX5l/zp0\nPf9yaVr/WZRa/12TYv8sMTf/I1cn/xkeHv89g0T/Rm1G/1iXYf9EcT//PF03/1xrSv9obVj/\nMmEz/y1mLv8qRir/dYtp/11wZf82Yjr/OWc7/zp4P/9TfFH/SFFE/1iCWf9FdET/UmVL/zx4\nRf8wZTP/KEcn/zVkOf9PaEn/QIRI/ypyOP8oVC3/EBgS/x0kJf86dUH/SVg9/zh1Pf9QblD/\nO4hF/ytYKf86gkD/TZdW/zluO/84e0D/VGlS/0ltP/9rjnb/TVdQ/2iVY/8RJRL/KUQt/yEp\nKP8ZIxn/OodD/zNxOP9afFr/SVJR/0RtVP87dUD/MW86/xw2HP9JgU7/W3xa/0lhUf+LhnP/\nVGxO/ypcMf8QERL/UmxR/1BsS/9YcFX/JVUp/1ZpUv8+az//RVBK/0ZdRf99n4n/LC8v/zZq\nOP9Ge0n/MWk2/06QW/8PEQz/UHxQ/ytKKP82WzT/GBoY/y5lM/8gPR7/ISki/1mFWP9HeEj/\nSW9V/0J2S/9RgU//KVYv/x8vIf8WJRj/GTcY/x9MJv9NWFD/R5JO/1VrUv9Oh1X/U4BT/2uV\nav9aeFj/T2NG/1mYXv9jjnD/WHFm/z9+R/8nVyn/QHtH/0Z8Sf9NfUv/O3c9/ylVLP80ZTX/\nZZRl/2WHYv82eDz/NG43/xs2IP8pOSb/Cg0K/zleM/99knj/Nm87/0KBTP9BfkP/JSUn/wsO\nC/82ez//QXBA/zVhNP89cT//GiIZ/0ZOUP8rZzn/Iikn/zQ7OP8oYC//DhER/yRTJ/9MilL/\nUpNb/2SKZf83bTz/Ml0y/z+JSP9ERkz/OXs8/0F/Sf8zaDv/R5JO/010Sf8nKi7/SXlI/ycv\nLf8SGBb/NWs8/zBBNf8WGhj/Wm1i/xYZF/8XGxj/HR8i/woXDv9dgGf/R15D/0xXT/9SW17/\nLVww/0h9Sf9ReVH/Pk45/zZsO/8/dkX/Dg8M/xASDv8tYTL/Mm03/zM1Nf8rMC//Pm9D/1mF\nWv8pbzb/Q09A/zp7P/8tVjX/P4JB/0RoRP9PZk7/bZJk/1V6Uf91i3P/S3RI/0pZQv87d0L/\nkIRw/yxHKv9nlG3/cHd1/zt0Pv86ZkX/R09X/zxMTP9BVk7/boxx/zJuOf9mel3/R3FD/01w\nSf89dET/XpBb/zpiNf9VilX/Vn5V/01YUP9egF7/PExM/1BqTv8sYDH/RYhL/2d2W/9CZDv/\nQGo+/0N5Rv83aTr/KFkp/06KU/9WclX/dYtz/zhWOP80Xzj/S3BI/0prSv9JbT//LWMw/12K\nXf9BbT7/VHtT/zVtOf84cz3/QoFI/1xoTv9TgFL/XXVc/0FqQv8+Zjv/SWpK/y9lNP9Dd0r/\nT3dM/y9uOP88Yzn/TnRL/0ZnQP9Kbkf/WnZW/0KCRv8xaDf/P2Q7/z1zQ/9FbkL/QIRG/y5m\nM/8/RET/NWo7/xAWFf9BfUL/IyUj/1NpV/9CbUX/R01P/zdwPf8YLhj/GR8a/ykuMf8qXDH/\nNG46/1dzUP9RflL/W5BZ/1B9Uf83Yzr/O3Y8/2aAaP9niGf/UVFZ/zQ5Ov9tZl//NWY8/zpm\nQP9Qb0r/V25Q/zBqPf8mVy3/NWU3/zl4Pv9Bbz//SU1K/0hxRv9gg17/P31A/0RGTP83eUH/\nW19L/1COU/9Ua0//UmtM/1iLXP8uTS7/bYVr/01mSf86SDT/RXpK/1VrT/9hnGb/Pn5E/091\nTv81aTn/OXY//zBrNf9ZaF//GB4b/zlxPf8tWC7/bX5g/zNrN/9Hb0H/ZHtf/zlrOv8oSib/\nDxEO/2OEZ/89Tzn/S3JK/wwNCv8mVSr/Hy8h/z9RS/9lfF7/Q2xD/z2GR/8zZS//ER0R/3J8\nZP8eJx//boxx/yVVKf81OD//OG89/xowHf8nWSf/SHNF/y5jMv82ajr/JDEt/xYfGf9ZmmT/\nZYhj/1N4T/8waDL/UXlR/zd1P/9Fh0r/VG5O/z16Rv89hkf/N2c6/zFvN/8yXjb/KlMq/1Fy\nTv87YjX/UoRO/zM5QP8yMzT/O3o//yhaLP9AfEb/U5hc/0djQ/9ngmn/U3JP/0lvRP9AREf/\nOX8//0OCR/9BVU3/PHVB/z5CQ/8jTyr/ID8f/ztyO/8NDw3/QYBN/yNYJ/8kTyT/IkAf/zAz\nM/9QY1H/GSAe/z93SP9CWEX/L2Q0/w4PDf9ti2//WnNU/22Nev9UclH/UoJP/0xvS/82czv/\nOnY9/1F3S/9aeVT/WHxZ/y86Kv8vXzP/M3M6/xkeGf8tYjL/WXFU/z1uQf84cz3/Pns//0SM\nTv80bDf/U3RS/yxaMP82PTz/IkAf/x0iH/9tnG3/UXBL/0GCSP8sMTf/Mzk//ysvMv8UGRf/\nf6OK/1ZoV/9KUk//HyUj/zBsOf8bNB7/K1Qv/yhaKv9egF7/JDEt/0BuP/9KZUT/RXlJ/0RE\nRv8wZDX/X3Nl/zM5QP84Nj3/OmpC/3RxW/9Tklj/TnBH/2Z2XP8vXjP/Jiow/wkLC/89akD/\nQHtD/zBZMP8ODw3/TWle/z5hPf9YcFX/NXU7/y82Mv9Eikz/O3M//woXDv8dIyb/ISgi/1CP\nV/8uNjX/Jiow/woMDP8LDw3/GiAd/2Skaf8PHQ//LEgv/yInJf8ZIhn/QoFO/x4kIv8ODwz/\nFhkW/ygpKf9Cb0z/MG0+/xseHv8nSS3/HCYc/1WKWv89eEL/M1Iv/zVfNv84bDz/eJOG/2GH\nYf9HYkb/KVYv/xogHf8xaTP/MjU3/05hS/9EUEv/Hyci/xgfHP8yNDz/QWpM/ytYKf86gkD/\nWpNb/yphMv8nMTP/O3VA/x8kIv8MEQ3/PWg7/y9jM/9IX0L/RlQ9/2l5a/9tkmz/VmJa/0VF\nS/9Xa1j/dI9t/2BxWP9Iekj/Jioo/y5lM/8ZNhj/HBsZ/z5BQv8pWjH/HDge/zRqOv82Zjn/\nZoxr/058Tf8sYTH/Nzc9/wcKCf9Cg0f/PXND/zZmOP8/aDz/VX5T/1CBTv9MgVD/QHxC/0Rw\nSf9SVlL/Rk5P/0OASv87ez//RWxM/ygwLv9VlVz/CAoG/wwaDv8iKyr/U4JT/1l5Wf9tnG3/\nWJZf/zdpQP8NDw3/L2Q0/yo6L/9DbEP/Kiwu/y5lM/8jQiT/Ei0T/xomG/8kKyn/TpBb/yRI\nJf92lYL/FicW/09xWv8pVi//FiUY/1qfY/9ghV//LzQy/ztzP/8bNhz/GyQj/0GFR/9sjnT/\nTmNS/1dWX/8oMC7/CAoG/yE/H/8QHw7/O3U9/0N7Sf9Pb0z/Y45w/3iThv9jiWT/V4Nf/0Nk\nQf86cz//XZJi/06HTv9DYzv/XXVc/z5iPv8sMTf/QWQ+/1FoRv9FTFD/K1kq/154Wv9Ye1f/\nY3te/z1+Qv8XGxv/QIRD/ydQKv9eYk7/Iy0f/wkRCP8YHxT/RmhD/xwtGf8nLib/BwwE/yAq\nH/8YHBb/Jyor/wsPC/8LDwz/P1w6/wYLBv9tclf/FiAR/wYJA/8EBgH/SV9C/2ZpW/8cIhn/\nJTEf/woNCf8LEAv/PEM9/wkOCf8pLiH/Cg8J/xkbE/8zOjX/HSga/wQIBf8SGRX/CRAJ/wMH\nAv8LDgr/HSIe/0VnQ/81UTH/NTg0/woPCP8hKBz/UWpS/ztKRv8dIyT/CxIL/ycuIP9Jbkn/\nDBEK/09hTP8lKhz/AwgE/wkPCv8mLB3/CQ4H/wcOB/8GDAX/BgsG/wwWDP8HDwf/CAoF/wgM\nBf8ECQP/ExkP/xMXEP8NFgz/CQwG/wUJA/8LEgv/CQ8H/wQHA/87YDj/NVEx/wwUC/8GCgT/\nT3NM/15nXv8/STv/Mjwq/wQMAv8/Tjj/OEcy/wQHA/81Tjb/TVhK/ycxKv8dJxz/YZFm/wgO\nBv8GCwT/Zn5k/y0xJ/8FCQT/DA4J/wcOBv8BCAH/BAcD/w4SCf8VGhP/Iysg/wYIBP8eKRn/\nWGlX/0ttSP8hLhv/GR8W/wYPB/8ODwv/QmU+/wsMCP8FCwP/HCAZ/zpXNf9qdVv/P044/yYz\nIP8ZHxP/FxgT/2FoX/8JCwr/HSIe/0VoQv8tMyT/HScb/wgPCf8hKCD/CAsG/wkRCf8GCQf/\nHiwZ/wYJA/8MDgj/CQwH/y8yM/8XHBH/NTs5/wkOCf8KEAj/DBIL/ycrHv85RS//R1M//zU8\nOv9Makf/BAkD/woPBv8HCwX/SldI/yIsH/8HCgT/R11G/1hqUf8UFw//Iygg/yYyIf88SjP/\nHCYW/ygtJv8vQir/VWhV/yk1I/8tQi7/LTAu/wcKCf8+TTv/OT4u/wYLB/8sNCH/Iikf/1JX\nT/88ZT7/BwsI/wYNBv8nLC7/MTs3/wkOCv8bISH/Cg4K/wkNCf8uNjL/DA0K/xAaEf8FCQT/\nCAwF/wcKBf9NZ0z/N00z/xUiEP9RX1H/LS0k/2CTZP8aHhv/BwsI/zM3O/8ECQT/BAgF/wUK\nBv8DBwL/CRIK/w0WDf8NGA3/BwsE/xAYDP8GCQT/DA4J/wMIA/8MDgn/ZXVg/ztGNP8lLBv/\nXGlK/ykwJf83Qzb/Mkcv/wUJBP8JDAj/BwoH/w0WDf8PFhD/CQwF/wYKBP9UclH/DA4H/woP\nCP8MDQf/DhcM/zdDMf9OXEP/DhUO/wYLBf8IDAn/BwsG/wgQCv9AST3/HyYc/1ZgWP8oNSP/\nCxEJ/w0VC/8NEQn/BgoE/0VjSP9ObU//AwkC/wEJAv8XGhf/Bw4G/wcMBv8JDQb/BggD/wkR\nCP8IDQb/DhQM/xYcE/8XHRH/CREI/wYKA/8SGA//HSoX/w0TC/8IDwf/CAoF/zQ5Nv8JEAr/\nR1pF/wwTDP8KEQj/OUgy/woQCv8KDwr/FBYW/wsPC/8uMzD/CQ0K/wsTC/8LEAn/CBAH/xEd\nD/8pMCj/CQwG/xsiGf8JCwf/FxoS/wwPDP8FCgP/BgsE/yAgIP8CBwH/CBAI/xwhFv9md1f/\nRlU+/zdINP8VFhH/CQ4G/wgMBf8GCwf/UGhQ/wQIBf9LWEn/Mzot/xkjGf8hKB//Hicd/19y\naP88RkX/HCUZ/xogFP8HCgX/T2xQ/wgMCf8MFgz/BwsF/wkPCv8iKR3/ICce/1liW/8RGRv/\na4Fw/yIjHv8IDAn/DRIJ/wgMCP8IDgb/X2ll/wkOCP8HDAX/EBcX/05eU/8VGxz/Iysg/xQX\nEf8LEAj/BQgD/wwQCf8JDwj/CA4H/wcOBv8GCAP/BgoE/wgMCf8WGxj/BAkC/wQGA/8/SDT/\nHSsX/xgcFP82Qzv/Pks7/0xdTP8PFQ7/CAwF/x0hF/81UTH/UopY/0p3Sv8PEgz/My8y/w4R\nC/8tMTP/BAgD/wUKBf8OEwv/DhgP/wQIA/8DCAL/CAoI/wUKBv8KDgv/CAsH/wkQCf8IDQn/\nDBMK/w8VDv8KEAj/BwsF/wwSCP9DZUL/SVVE/zc/Lf9QgFL/CQ8H/woNCv8JDQn/DBAL/wgM\nBf8SGRv/ISkc/wUJBf9CTzz/DhcN/wwQCf8nLR//Q0pC/xYaGv8KDQf/Fh8T/wkPCP9KWEP/\nKDIg/ys5JP8HCQP/Mzk6/x0gHv8mMyP/DRYN/zhCMv8GCgT/Hi4a/xwgHf81TTT/YZNl/0pW\nSP9LVEL/CA8J/wkOB/8QFA7/CxEI/yQrI/9falX/BgoD/wcMB/8GCgb/DhEK/wcKBf8IEQv/\nCA0G/w0TDP8VGxH/ChAJ/zZDLv8CCwL/DxcO/zM9Lv8GCgX/DxIK/0lZRv8HCgT/DhcN/0hQ\nRP8qMCH/BgoE/yQpGf8rNi3/MDc3/x8lHf8NEwr/XW5d/0ZtQ/83Uzf/BgwE/wIJA/84SDz/\nR1o+/wkOCf8LEAr/Jyso/wgPB/8IEAj/DRUO/woNCv8ECQP/KDUj/xAYD/9LX0//Ijgf/0xk\nRv9AZj3/NVEx/1psVP8JDAf/EhcN/y06JP86Tjj/FxoR/wQJA/8tNSP/P0g6/w8VDf8GCQX/\nFRgR/wQJA/8PEw//DBEN/w0QDf9HVUf/LjYn/woQDP8HDgf/CxIK/woSC/8UFxX/ChEI/x0k\nGv8GCgT/BQkE/2R3YP8oMyP/DA8H/wQGA/8WHhL/MDYm/x8mGP8sMiL/JScc/xAVDf8JDAb/\nMkMx/yUkHP8TGRD/X3Fe/0JBOv9KXEL/CRAH/xYaEv8IDQX/EBUN/wcLCP8HCgj/BwwI/yov\nLf9UZlD/DA8I/yIoGP9IX0P/WF5U/wgMB/8IDAn/Cg8K/w0SCv9CVT//JDQg/zNFL/84SDD/\nEBIL/xsiE/8HCQX/FhkR/xQeEv8MEAn/Ql8//ytCKf9hdGX/DA4K/woOCP8GCAP/Cg4G/wgN\nCP8XGhD/OkQ0/wsQC/8IDAj/CA0I/wwQCv8JDwn/BQkE/wsOCv8IDAj/BwsF/wgNCf8GCQf/\nBgoE/wcPCf8aIBf/Cw0I/wQIA/8LDwf/CAsJ/wkOCf8IDQr/ChEL/woMC/9HWUD/TnpQ/y0y\nI/8QFBL/GiEd/wkNBv8HDgr/HSUa/2pyXP9EXj3/DxYL/zVVMv8PEwv/Fx8T/yExH/8fKhr/\nBwoH/wYKBf8MDAr/ERgN/wkNBv8LDwj/OUU4/zA0LP8sMij/BxAH/wYKBP9JWEP/KkIr/ztO\nN/8eKBz/Xmxf/xMaEP9MaE3/CAwG/wkOCf9SW0j/GCIV/xUfEf9BTED/SFZF/xASCv8SHBH/\nRGlA/1FYTv8nLyT/FiIT/x8qHP8GCwf/BggE/0Z3Rf8lMiT/CQ4G/woNB/8LDwb/BQoC/wIJ\nA/8sPSn/X5Nj/w0RDv8IDQb/Cg8I/wUJBP8GCgX/DBAJ/xkhFP8JDgb/Cg4H/0lWSv8TGw//\nDA8L/yQpH/9FTjz/Bw0H/wcLBf8ICwX/BAoD/wMGAv8IDAX/KTIr/wkPCf8GCgT/BgoF/wUI\nBP8NEwv/ChEK/wULA/8ICwX/Cg8H/wsSCv8gKh7/BgkE/wYKB/8JEAr/EBkQ/x4cFv8MEAn/\nCQ8I/wgNCP8TFhH/BwsF/wkPCf8KEQr/BwoH/woOCv8hKCX/BAcD/wMHA/8CBwD/DBMK/wcK\nCP8KDwv/BgkF/x4kHf8HCwb/cG5Y/w4TDf8IDQf/Cg4J/w8UC/8dJRn/Cw0J/wsRCv8HCwX/\nR2FH/zM8Lv8wNij/Pkk2/x8lF/8JDgf/BwsI/0tOS/8FCQb/TWFL/zU5Of8GCwf/Bw8J/wgK\nBv8JDQj/DxUL/xAVDv8FCwP/BAoD/wsRCP8HCAX/LDow/wYKB/8KDg3/PF88/zU9Mv9BQkP/\nDREM/wsTDP8ZHRT/ICkd/ygvLP8rNi7/OkhC/wcMBv9MY0b/BgwG/wYQB/8LFQv/Y3Fe/w0X\nDv8uNyT/GSMT/xYbEP8FCAP/TW1H/0ZsQ/8IDAb/CRAH/0NRRP8gJx7/CxIL/woPC/8qLS7/\nDRIN/y82MP8JDgr/Bw4H/xkcFP8LEwv/LjQx/wsSCv8LEQ//O0Q+/w0TDv83QTr/EBcX/0RU\nOP8FDgP/Eh4X/1SRXP8VGRn/RmxI/wMIAv8HDQb/BQkE/wQLA/8GCgX/VmlY/0ddP/8IDQX/\nVGtU/wgLBv8ZIBf/QF48/09lSP9KXkT/JCwi/xwgFv8VGg7/GB0R/wwQC/8LDwr/Izcd/yov\nJv9CV0D/PU05/y9PL/8GDAT/Pko6/0hiRP8GCQP/DBEL/1BgU/8jJij/BgoH/wYKBP86SzX/\nBQkE/xMXDP8FCgb/DBMM/wcJB/8KDwn/DRIM/wUKBv8GCgT/DBEN/xQdEP8GDAf/GyMX/wUI\nBP9EXkL/LTck/xseFv8LEgz/CREJ/wgPB/8GCAP/DxYO/wwOCf8LFAf/GB0X/1xfWv8JDAj/\nCxIK/xYZEv9BQkP/DhMP/wwSDP8NEwz/Bw0H/wQIA/8GDQf/ERcT/w4PC/80UDP/BgsH/wwN\nC/8mKy3/CA0I/wgNCP9CTTj/AQcB/wkRB/8GCgX/CA4K/wYLBv89RzD/MD0r/wIJA/82QDD/\nBwoJ/2J3af8DDAT/FBoQ/wsODf8FCAX/BgsG/0hgQ/86Tzb/QFA6/ygyH/8xPSj/Lz8p/ygx\nIf8ECAP/JjEg/0NFPP8TFg//CAoF/wUJB/8IDAj/Cw8H/0JcPP8YIxX/MFEv/yo3J/9IUUH/\nTGhI/wMHAv8EBgP/EhgP/wMIBf8/XT3/BAcE/xkgFv8YHRH/TV5N/xskGP8HCwf/CAoI/wcL\nB/8KEgr/BgoG/xodEv8fHxb/HycX/wgPCf8HDgf/CAwF/woOB/8gKCX/BwwE/wcIBf9HUUP/\nCg4K/x8nG/8RGhH/CQ0J/wcMBv8KDQr/ChIK/wgOB/8HCwf/ICkf/zJSMv9HUkr/UmhQ/zVG\nMP8GCgP/DxML/x0nGv85Qz3/CQ4L/wsRCv8HCwf/Jywr/wYKA/8GCgT/BgkF/wcKA/82Rjf/\nQUpG/woTCP8ICwn/Cg4I/wUJBP8FCQT/SWBF/yssHP8EBwT/BAcD/wYMCf9ibVj/BwoF/ycm\nIP8RFA3/ISgj/xoeGv8HCwf/CA4H/woQCf83Qy//BAYD/xAUC/8JDwj/DRYM/xMYD/8LDwr/\nCAoH/yc3K/84RDD/CQ8L/zE5KP9QW03/DA4I/yUrG/9LVkP/CQ8I/w0XDf8GDAf/BhAH/xMW\nDv8OFxD/BwkH/wgLCf8MEA3/BQgF/xEYD/8HCwT/BwsF/zVONP87RDn/DxcO/zNDMf9JVUP/\nNDgw/wgLCf8lLiL/Cg8M/wsRCv8IDAn/AgUA/ygxKv8VFxX/AQcB/wQMAv8IDgr/BQsF/xsi\nFv8CCQP/XYhc/x0gHP9BSjj/Cg8M/yQsGv8XFxD/BgkH/1+QY/8KCwn/Ul9K/wkOCP8OGA//\nBg4F/wkLBv8MEAj/VWxP/zZCLf8oPiX/FCIQ/1JdVP8lLCP/ExcN/wYLBf8oPCf/BQkD/zBH\nKv8oLCP/FBgO/wYLBP8YHhb/BgsG/wgMBv8DCAL/CgwJ/wgNCv8JEQf/EhcM/w4SCv8FCAP/\nGiIW/w8TCf8bIBb/SlZD/wQHAv8WGhX/CA8I/yswJv80Oiv/CxIJ/wkQB/8ECQL/EBcO/woO\nCP8OEgv/CA0I/yQxIf9aa1b/PmFB/xwdFf89Yjz/BQsD/wkNBv9CUDv/CAwF/woPCv8JDwj/\nCQ4I/wYKBf8IDgf/BQwE/wsOCP8JEgj/HCUb/wYJBP8NDgr/W29T/wsPB/9PW0b/FhwT/01j\nSP8RGBb/GSAR/w0QD/8SEwv/Cw8H/w0QCf9HUET/Cg4I/yAgGf9MWE3/JCoh/wMHAv8MDwj/\nKSkq/0NQQf87VTf/Jzkk/1tsXP8rLy3/EBcX/wsRCv81RTT/RVBC/wkQCf87RTL/GR4T/yYr\nHf9TZEj/BgsE/wYLB/8HDQT/Sn1J/wYLBv8FCQT/HCcY/zc+Ov8GDQX/GB8T/zZAL/8bHxj/\nIjIf/y0zIv9CTDr/Mzkq/xgdFf8PFgv/CAoE/xUfEP9XXFX/GyEW/0xnS/86SDP/O1I2/0pQ\nUP8NEw7/UGNJ/w8UDP9EZkT/EBYN/wgNCf8OExD/CAsG/xkfFv8XHBP/XGdM/21oT/8rOCX/\nICkb/xcbEv9lamr/OEQ2/xYaE/8IDQb/CxEK/xcbGf8QFBD/REhD/woPCP9LaUf/ERgQ/woO\nCP8lLiP/FyQS/wUJBP8KDgr/FBgX/wYMBP8HCgP/AQkC/xogFv8LFQv/CxMJ/yEqJf8qLS//\nBQkG/05fR/80PCn/BwoJ/2JsVv8DBwL/Njko/ys4Jf9OU0z/IiYf/zlDN/8nLiL/DRQM/yMo\nGv8TFw7/NlQx/zxNQv9dcmL/CAwI/0tiRv80TjP/K0Qm/yArHv8JDwn/FBkQ/0xqTv8JDQn/\nCQ4J/xUZGP8YIxX/FB8Q/0FDQv8HCwX/EBIK/wUJBP8SFwz/Iyca/wQIAv8LEgf/BAYD/wgN\nCf8JDgr/S3ZJ/zpUNP8KEAv/BwoF/x8mHP8EBgP/DRML/z1ROf8tNiL/KSwf/yAnGf80QzP/\nQkdC/wcJB/8MEQ7/P004/0ZhRP8NFhD/SGBH/wgQCP9WZE//Cg8K/wwRCv8dIRn/BgsG/woP\nB/8KDQf/CQ8H/w0SCP8qMjD/XpZj/yg0Iv9ZXFX/Iige/woNCv8MEQn/ERsP/xYYFf8WGRP/\nBAcE/xQZDv8JDgf/CQ4I/xMWDf8dIhb/GRkS/wQHA/8IDQb/HiQe/1RpUv8uPCj/QE45/xMX\nFf8TFRL/CxYL/yoxKP8IDQX/AwkC/wQJAv8NEAn/ChAL/x8mHf8QFg3/QmU+/ywvL/8HCQj/\nBAcC/wMHA/8CCAL/BgoH/wQMA/9VYVb/BQsD/yYxIf83UDT/CAwI/wkPCf8LEgv/DBUL/woO\nBv8gLB7/BgoG/w0XDv8TGxL/ExoP/xsgEv8GDQX/CRAJ/wcLCP8LEgz/DRMT/z1kO/8HCwX/\nBwoD/1ZuU/8WHBb/S2ZL/wgMCP8HDAb/CQ0K/wwQCv8pLSz/BAgD/wYLBP8ECgP/BQkE/y82\nMv81ODv/BwsH/woOCf8OFg7/CxEK/woQCv8MEgr/DA8M/wkPCP9QYUv/CREI/wgPB/8MDwn/\nBgkE/wUIBP8LEgr/EBIK/x8jHv8GCwX/Cg0J/0RjQ/8IDAj/Iiwl/wIJA/8JDgv/Bw8G/wYM\nBf8HDQb/BAoD/wcJBP8DBgL/DBQL/0VfQ/9FVj//CBAJ/xkbGf8HDAf/CxEK/w0UDP8NFg7/\nBwwG/wwTC/82UDP/CAwG/1dnVf8yOCj/UWJD/wkNBv8GDQb/Bg8G/woMCP8GCgX/Bw0G/wcM\nB/8hIiX/AwgC/wkOBv8HCQT/HSIb/wgMCP9Uh1P/BQkF/w0RCv8FCgT/Cw4H/yg1Iv9aX1v/\nHiQk/wgLCf8eIxb/IiMb/xgfGv8GCgT/OVI3/zdbOP8ZHhj/IzAe/w4TD/8HCwb/CAwK/w0U\nDv8IDwj/U35R/xcbGP8GCAT/JC8g/wUKBP8GCwb/ChAK/05ZQ/8PFxD/UGxQ/wcKBP8EDAP/\nITAe/zVKMf8REgz/DxEL/wcKBf86RzL/JDIe/yQrHv8IDAb/UF9N/yIxIP9BT07/BgsF/yxb\nMf9KW0v/BQkE/1B/T/9KZUP/Nzkz/wkPCv8IDQj/BgoH/wcLBP8GCQX/LzMw/wYLBv82OjL/\nEhUQ/ztlOf9CWj3/XWhV/y45KP8mKxz/WmBc/ycrIv8vOCr/S2VG/y00Kv9BRkT/BAkE/wIH\nAP8FDQT/CxEM/wcJB/8SFQ//CQsJ/wIJA/8xLzL/BgsH/zlKNv8IDwf/CAwJ/wULBP9AZEH/\nCRAH/wwVDP8OGA//CA0G/w8WD/8IEAn/BQkD/zhCMv8FDgb/DBcM/xAZEP8PGA3/FBsX/wkP\nCP8GCQT/BgoF/xghFf9IaET/CBAI/wgLCf8GDwb/DBAM/wgOCf8LEA3/BgkG/zA9N/8ICwr/\nDhQN/wgOCP8BCAL/LjYw/wsRCv8GCgb/BAcD/wYJBv8JDwj/FxsZ/wwRD/8iJyT/CA0I/xYj\nE/8GCQT/CRAK/yMsIv8ZHBT/Bw4H/yU3If8hJST/DBAN/yYoLf8HDgf/BQkH/wsRCP8MEwz/\nHiQb/1ZeV/8JDgn/IC0b/0RvRP8QEg3/AgkC/wkLBf8JDgr/DBAM/wYMBP9VVk7/OkUy/wcK\nA/8BCQL/GRsT/z9HQP9VblX/CQ4H/wwPDv8bHxz/BwoI/yAkH/8GCwf/BggE/wIIAv88Sjr/\nChEK/zQ9MP8dHx7/AwoE/y44Mv8OEwv/BQkE/wYKBP8LDgf/OE00/w4SCf8MEAv/IS4e/wkM\nB/8JDAf/Iiga/zdHMP8JDAX/Bw0F/zZSN/9FT0D/AwkC/wgNCv8JEAr/BAwG/xQdD/8JDAj/\nOkYw/0tgQv8RFAz/FxgR/0pXSP86QjH/DhML/wwOCP8HCwT/GR8W/wgNBf8KDwn/Bg8G/z08\nNf8ECAL/U2NV/yQtI/9ga17/CRAK/yAoGv8IEAj/CA8J/wQMBv8eKxr/AgkC/0tpR/8JEgj/\nBggD/wgLCP8NEgv/EhgQ/wwVC/8FCAT/BgsG/wUIBf8ICgf/Cg4J/xMXDv8IEAr/CA0H/wYM\nBv9CZUD/DA8J/wwPCf8PFAn/Nj8x/yEhGP8IDAX/ChAJ/wcMBP8FCQP/Cg4H/xskGf9Mc0v/\nM0wv/w0TCv8UFhH/FRkS/wkMBv8FCgP/BAkD/yYzIv8JDQj/N0Yx/wIJAv8GCwT/HiIY/zo+\nMv8+RzT/DhcO/y09LP8FCQT/DBMM/zNKMP87Skb/Cg4K/wgNCv8JEQr/Mzw4/x8iIP8FCQT/\nBwsH/woQCv8KEAz/KjMp/xATDP8RFg//AwwE/wwRCv8HDAX/Cw8K/wUJA/9gcF//Xnde/wQK\nA/8FBwP/GSEX/yUpKP8UGQ3/QV49/xIZDf9LWET/ICMY/wwTDP8xOib/U41a/xshF/86Ry//\nNT0s/y80I/8ZHxX/Cg4I/x4kG/9JWkD/Pk06/09dRP8iLCL/FRsS/wsVC/8OGA//YGpf/ys0\nJ/9PalD/AwgC/xwiHP9Zc1L/DBIK/wQMAv9YbFP/DhUL/1pnUf8JEAr/Cg8H/yAuHv8TFw3/\nN0It/0VUOv8nMCL/CxIK/wgKB/8pKy3/DRAM/wcLB/8FCAT/FxwY/w0UC/8GBwT/Kzko/y5G\nKf80Ojj/DBIO/wwPCv9cZ1v/ISod/wwQC/8PEw7/ERUP/wgMBv8JDQb/BgoE/yQqIf8PEwr/\nRE42/wgNCf86STX/BgsE/xQaE/8HCwX/Mk8v/0dYQv8ZHhb/XGVd/1pwXv8gKxz/IDEe/y47\nLv8IDAj/ChAK/wcNBv8LEgr/TWlM/wYLBP85SS//EBUL/xQfEP8YIxT/CQ0G/zpENP8EBgH/\nLzUp/zM2Kv8JDgf/EhgQ/yo5J/8yPDX/QkM8/xwgGf8MEQn/ExoQ/wgNCf8HCgX/BwsG/wkS\nC/8IEgr/BQkF/wQJBP8QFRH/CQ8I/yUlHv9EWDn/WF9W/woNCv8GCQT/BAwG/05rTP9IVkf/\nOVIz/xwmGv8HCwb/BgkF/wYMBf8RFhb/BQkG/wcLB/8LDgv/CA0I/xcbF/8iNR//HCMZ/wUJ\nBP8hJh3/Cg0G/wUJA/8HDAX/VmVP/01jS/8jKRv/Ki4s/xEUDf9UkFz/O0w7/xQbF/8GCgX/\nCg0L/wgMCf8KDw3/CREK/wQNBf8ICgj/BwkF/wYIBP8ICwn/Bg8G/wwPC/8GCQT/CA0I/0pt\nSf8GBwT/JSUe/wkOB/8MDwn/AwYB/0hPRv9QXk7/CBAL/wgQCf83Oyn/BAkG/woPCv8MExD/\nCw8I/wwTDP8JDgj/DRcN/xMaD/8UGhH/DBQN/wwVDf9mZkr/Mj4t/yYvH/8MFgv/Ymtm/zQ/\nMP8zRy7/AgkB/w8UDv8RGRD/BgsF/w0RC/8HDQf/BAoD/wkMBv8JDQb/BwgF/xATD/8DDAT/\nBgkE/yAkJP8tMDH/BwkE/w0QCv8wODH/BgoD/xMXEf8HDQj/P0s1/z1gQP8LDwn/N0Qv/zta\nN/9LcUz/Cw8L/wkOB/8rMSz/BgoH/wYIBP8CCAL/BwoE/xIbDv8mJi3/S19C/wYKBv8GCwb/\nCA4H/ycsLP8fKBz/Cg4L/wYHBP8JDgv/CAsI/w4XD/8IDAj/BwwK/woNCv8KDAn/CAwJ/wkS\nCP8tMi3/EhkV/xkbHf8jKCj/CAsI/wsQCv8MFA3/BgkD/zI6K/88STT/Pkw3/wsVC/8jMSD/\nERcT/wgMBf8GCAP/ChAL/z5QOv8oMCX/FRkR/w8TDf8MDwn/CxAJ/w8TCv8FCgL/R05A/ysz\nJP8dIRX/ERwO/yYtJf8JDgf/UWJV/yQrHf8HCgT/BgkE/wkMB/9IUjr/Pks7/wkNB/89SzX/\nHSUZ/xUbEf9caF3/TmVM/0VdQP8+SDj/CA0J/wQIBf9QVln/CA0H/wwTDP8WHxX/DBEJ/wgL\nCf8cJRn/Lzsr/yQtIP8xRS//Cg8I/w0XDv8JEAj/P001/wsPCv8KDwz/HSIV/xMYDv8xPTT/\nJy0p/wcLB/8KDwr/DRcM/w0UDP8HCQf/CQ4J/wEHAf8UIRH/DBAI/wQJA/8FCAT/Fh4T/wQG\nAf9bbVv/BQoF/wwVC/8MEgv/BwwG/wUKAv8OFwz/RVc7/2Jwav8sQSn/BwkF/x4jFv8IDgb/\nBwsF/wYMBP8CCwL/M0Yv/0xfQv9DcUX/ChAI/wcMBv8HCgb/Fx4U/yw5Lv8MFQ3/QlA5/z1P\nOf8GCwX/DBMP/xgfGf9DWT7/BQkD/xgbEf8WGRH/JS8h/wsSCf8QFg3/BwsF/woRC/8FCQP/\nCxYL/0dfQf9ZbFf/Jiwd/1FbQv8KDQv/WmJc/yAoG/9IXkP/Bw4K/wQHBP8KEAz/BgoE/wkO\nCf8nKyL/Qk9C/w8UDf8SFA7/DREL/wgLBv8TGg//EBkQ/zE4Kv8HCwj/LzYr/w4XDP8MEAr/\nDA8L/w4QDP8JEQj/DBIL/wYKBf8xNjP/NkI+/ykvL/8LDwz/OUpA/wgMC/8NEgj/BQ0E/w0Q\nDv8aHhr/BxAI/zhDMP8HCgX/OUVC/xsdE/83Qz//DRAO/wkQCv8MFQ3/Cg4L/wcOBv86STH/\nBgsE/0tbQv82PCz/FhwW/wcJB/8EBwP/AwcD/wIHAf8GCQT/CAsH/ykwHf8qNCX/ERkP/xYg\nE/9OaE7/QE4//wkNC/8aHBr/QVk7/1xuYP8JEgj/Cg4L/xoeGf8HCgT/VVpZ/wQHBP8ICwj/\nDxUO/wgKCP8LDwf/CQwI/wcLB/8GCQT/CAsI/wgPB/8KDQr/Pz9A/zA0M/8IDwf/CA8H/wsQ\nB/8GDAX/Jy8u/yUoJ/8yUjP/DhML/xEVDf8JDgn/BgsE/x4mHf8ZJhb/CRAJ/wYJB/8QEwr/\nCg0K/wcLCP8HCQX/JSog/wcNCP8sLy//BgoG/wkPCf8JDAj/BwoF/xEVEv8HCwj/CAwI/xIY\nFf8LEQj/BgwF/xEWFP8LEwv/CA8I/wcOB/8KEAj/LTot/woNCf8NFg7/CA4G/wgKBv8IDQf/\nBwkH/0tWUf8fKh3/REhI/wcKCP8dIB7/UnxR/w0UDP8OFw7/CQ4H/1hfWP8VGhH/N1o4/y4x\nMP8XGBn/TG5K/zpWNv8FCAT/JTAg/yQpKv8wNzT/BwwE/wYJBf8HCQP/BgsG/yMsIf9DT0f/\nAwkC/wEJAv8qKSD/DRIP/wgMB/8GCwT/DREO/wcNBv8cIhz/BgoH/wQKA/8EBgL/AgkD/wII\nAv8HCQT/AwYC/wQJA/8ECgP/CA0I/wcQB/8IDwf/BgoE/1ZsXf9ed17/EBUR/wkQCf8LDwj/\nRFQ4/xMXEP8rPiT/Kzgn/wUJA/8JEAn/Hh4Y/wkNCf9hb2T/BQkE/wcJB/8NEgz/CxAK/yEo\nG/8HCgj/BwoH/wsPCv8vOTX/LTcw/zM4OP8KDwv/Fx4i/wkLCP8HCwf/Cg4K/wQJBv8NEQ3/\nCAoG/xIWE/8MEQz/IS4d/1N+Uv9AbT//CQ8K/wMJA/8XGRj/BgoH/w8RDv8iIiP/AgkD/wIJ\nA/8FDgP/BwoI/wcKB/8MEQr/ChEK/ztKRv8JDQr/BwoF/09zUP9ck2D/ICMi/w0QDv8SFxP/\nQUNG/xAXF/8YHhX/CxEI/yctJf8mJyf/CAwK/wIHAf9LcEf/CQ8J/wkLB/9XdVb/aotw/0xr\nRv9ZiWH/eZ2K/2SKX/9TfVj/W4hX/2afbf9ci1n/VGhZ/1eRYf9nimz/aZps/0NtQ/9flWb/\nSnZO/0tySP9Hfk7/WYBa/2F+ZP9knGb/RGZG/1N+U/9EeUv/Zp9t/2WNZP9kl2X/R2lH/2yb\ncP9Lckv/Un1T/2F3Zf9okHD/SntO/2KRZv9dmV//YYxi/2qWbf9ae2T/UH5S/1yNV/9mmWb/\nQoZI/0lwR/9bmGb/U31V/2OIZ/9JbUn/V31b/2GLZP9Od0//U4RX/26Xdf9QZ1T/Q21D/1WQ\nWP9jjGX/QWdB/2F3Zf9Ih0//VI5a/1J6Uf9CZ0L/Wo5g/1qLX/9fimb/YJdk/0NtQ/9alGD/\nQ21D/1aGWv9MgVH/Vo5b/2KXZ/9DbUP/ZIBk/1t8aP95nYr/a5Jm/2afbf9Lf1X/Y4Jp/2GL\nY/9mnGb/W4lh/0+HVv9dgV//SHFK/1KAVf9PYlH/dJl6/2mXcP9Yi1z/WINW/2qGbf9gl2P/\nUnxS/3CPdf9glWL/W41i/1eOXf9olmj/gpSK/1SRW/9DbUP/YYdl/2CJZP9eh1//Y4xl/1WA\nR/9niWz/gpSK/2GRY/9miWv/TmxG/16MVv9UgFr/bJNy/1B/VP8mKyj/DREO/0VER/9unn3/\nDBIM/1d9Wf8rMjT/QUpD/wkPCP9kcV3/DhUP/3mYg/9OdEz/HiMb/6G1r/9PfFb/LzEy/woO\nCf8VIBb/DhcN/w0SDv9qfnD/nJmt/25qef+NraD/YZVo/yMoKv+fnqf/EBoS/xolHv9bflf/\nlo2Q/1VdYP8WGRX/TnVQ/1tmZv8QExL/TX9S/zlIOf8NFQ3/bGtp/5GKiv9BQkP/Y2Fj/xQd\nFf+Mh5L/DxsR/1t+Xv9YjmH/PkJF/xshGP8QExH/EBkQ/5WVoP8WGxj/FCAS/6Gouv+GgpD/\naWln/xEUE/9KW0z/Gx8e/woNCf+usbb/EBIQ/w4cD/8OHA//O2Y+/yw1J/8nLir/FRkU/2hn\naf9UU1P/e3mN/xMgFP8OEAz/GiMY/yMrHv9RgFP/nqmx/zg6P/8OFg3/SGFJ/1hYWP8yRjL/\nY2df/yMoIf9ASEL/EBQQ/1VrV/9ASj//EBoP/0FOQf9dkF//DxYM/wwSCf9PTUv/OkVA/y44\nKv8LFQz/O0E//0RGSf+DgYL/LzQo/zY+Mf9Sdln/ChAL/09ZUv9va3T/HSIf/xYbF/8WGhr/\nc3t5/7ewy/+Tlaj/VVVW/0xKVf8XGhj/Cw4J/1CCUf9RblD/gXZy/xsmHv+WtKn/s7nT/6C4\nrf8hKCX/WnxV/zIuOP9Vglv/Jigq/2KHZf82NzT/LC4p/zg9P/9ZcGP/VYJb/1qOZv9kZmH/\nIygq/w0VDP8RFRH/DxcS/2xwcf9BRkL/nKGr/1pbYP8rLSv/Z3lq/0dITf9TVlj/UV9S/xEV\nFP9bjGH/EhcT/ystJv+7sbj/MTMt/xYZFP9ZdVz/FCIX/3Zzcf8KDwr/DRUO/xUdF/8UHxT/\nnreu/1dtVf9ZXmD/EhUS/1lwYP8rMC//VWBq/zY3Qf82QDP/ZGVx/wwRDP8MGA3/ODU3/w8Y\n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\nGv8UJBb/DhsO/32Whf8dIiD/RGpG/ysuMP8rLi7/MTMw/0dTSf8QEQ//X3pp/xsdJP85PT7/\nHh8h/x4kIf8mLCL/T1RV/5mho/9Wa1f/naCe/1thT/+XtKn/l7Oo/01oTP9XflX/MTsy/2Vq\nZv92don/X2Zx/z0/Rv8lLCv/Vlxc/1aDWv+YlJz/CQwI/w8VD/9ugHX/YGFp/w8UDf9DVEP/\nCxEL/0lZUf81OjT/UnRR/2l/bf9vbG3/VlVf/wwaDv8SHhX/ISoi/wwTDf8hJiD/ChIK/yIl\nJ/9Rf1b/QURG/w8XEP8RFRH/S1VT/w8TD/8SFxT/YX9l/xQXFf8ZGxv/iomQ/xgWFf9OUFP/\nCg4K/0NPQf9FbkL/GCUa/0FCTv9cXmP/Y2hf/1dfYv8KDAj/Tl5P/5Shn/8vNiX/R3VI/4OX\nlv9wk3j/nLu0/zAxMf8OFg//foGB/xQXFP+gtKn/DhEN/w8WDf9DSEL/Nz43/26Uc/+brqn/\nICYf/xYaFv8YJBz/EBcQ/yMqK/8XHhr/S01N/xohHP8PHRD/ExoR/xEcEv8kJij/FyAX/2xr\ndv8eIiH/WFtY/xETEf9hYmT/DhkQ/5iUmv+fqLD/DBkM/wwTCv9KWEv/R21J/xwqGP+coqD/\nCAwH/zNFMf8fKxf/Iisr/y04Lv8PEw//PUNF/x8fIv8TGhf/bWp0/4eGi/+QnZX/XV1X/w8S\nD/9WWFP/U1dO/4iMgP91iHv/aWl5/xsjJP8OEgr/Kzoj/wwQDP+Zo6H/DRoO/6ymp/9vcXT/\nTE1h/xAVEP8LEAv/Hhwm/w8WD/9Vglv/gICE/5eaof+NhqL/RklC/0xsT/8LEgz/GCoV/1Zb\nWP9PZlL/ZWZg/09XVP9zcnX/REdB/3t3ff8MGg3/ZJNs/4OCj/9jYmP/DxMQ/zY+Of8qLi//\nTW5P/xMdF/+Zo6b/maai/2ZndP8KDQj/Un9b/w4dEf8eKBr/Ojw//x4lH/8VGRD/Mjst/1do\nVv8qMSX/Wl1e/xkbH/80OzP/DhcO/x4iIP8OEw7/iI2Z/6Siqv9VbFb/Y3Be/6Grs/8bHx7/\nkJai/y80K/+coqH/ExcV/3F4bv8TGBb/FxoZ/xYYF/84Pjz/Jiwn/yMnJP9CREf/GSMc/yow\nJv8OFhH/Vphc/zc6Nv9CQU7/Vl9q/5WVnP88bj//S3RO/7ezzP8rOCn/DhIP/xgaGP8OHQ//\nbWhu/358kP8PEg3/i4yL/2uFcv8OGw7/JjAh/1t1XP+EnIn/HCAe/xEVE/87Vjr/ISIm/wsQ\nC/83Ozj/dIFq/xoeIP8cHiD/FhkZ/ygqKP9cfVb/OUI7/0RGSP+Kjoj/rLzB/xIWEv9GbUP/\nFBYS/1NaVf9EcUP/Cw0H/113X/+Wm6f/QkI9/1t1Wv9BS0P/ISok/xUfFv8uOSz/FRgV/xEc\nFf8YGhj/ER4S/0hMUP8NEwv/Fhka/x8hJP9JRVH/JC8k/wkRCf8ZJhv/HiIi/xUUEv9FUUf/\nGiYc/wwXDf8QExH/LTUs/wsTC/8KEQr/RE9J/xIXFf9HRkL/X3pp/xIaDv9dW2b/TE5L/w4V\nD/8KEAr/CREK/w4bD/8/WTj/Yopm/1+GZP9gdWb/OlM1/wwTDP8QFBH/LzEs/z1EQ/9CS0P/\ne3mN/11dYf8VGRv/HCAc/1JoVP8OEQ3/DhUP/xgcHv80PTT/UWJX/1NoUf9nh27/DxYQ/6Gt\nsP9rim3/TG1N/1CAUv9cd17/Y4hm/zc4Of9VbVT/V4Ze/5m2qv8vNjb/XXli/4CDe/92f33/\nbX1r/3eHef+qprr/Lzku/11zYP9KSUf/d4d5/7S5uf81UTP/P2ZA/yktMP8gJSj/ZJ9o/y4w\nKv+eqbH/Cg0J/xQfFv8bJB7/DBQM/z08TP+AlYf/FhwX/4OCj/9FREf/Dg8L/xMXFf8LEwr/\nmaOm/w0SDv8OFg3/DBQN/yk4J/9HRUf/Cw8K/w0RDf8mKyj/b5F2/xchFP8PFg7/Higb/xIY\nFP8VGBT/X6dj/xsfG/8oLSv/UFdU/zJDNP9Xilr/W45m/7ivyv9FSEb/VlRW/4aAiv9KfEj/\nDxUQ/xAaE/9KSEj/FB0V/zc7OP9XVln/REZK/6Okrv8fIhv/e3mN/xwgH/+DgIn/aGNl/0lC\nRv8THxT/CAwH/yIlIv9EUkb/SUxM/zVJMP9qjXT/h4OO/1aAWv9GTUj/DxoP/25pfv8YGxr/\nWmph/2+JcP8SHhX/DRoO/yoxKP9SaVH/d4d5/2JjYv+MkJP/XYto/xEeE/8dHST/PkVA/wsU\nC/8hJCf/ZmZp/0RTQv9ERkn/Xnxd/xgbGf8XJBn/FxsV/4WYj/9oYWf/CQ4I/0lcS/+Tlpz/\nHyQe/z5AQ/8cHRr/FCEY/xETEf9+e3//DRYN/1V3Wv+Tk53/Gh8d/w0XDf9dXF//PUE8/0Vb\nQ/8QFBH/QmtD/xMYF/+vo6j/EBoS/313ff9YWmD/DxYR/zE7M/+ApIL/Ky8s/1tfXP9xeHD/\nUVNU/xYjGf8QGxH/bX1r/2Z2cf8PGhD/cG5z/2xpa/8RGhD/DRMK/zJCLv9nb27/IyUm/4iM\ngP8SFhL/GR0f/w8ZDv8tMyv/T1VL/xIfFP8KDQn/Qz9O/xAWEf8KFgr/ER8T/xAYD/8RGw7/\nMTU7/523rv8nLi7/HCMh/w0UDP+EiJf/MUcu/32Jfv9ek2b/DhcP/y8xL/+lr7r/EiAT/w8c\nEP8lKyP/DRIM/0tVT/8RFhL/EBEO/z9GPP8ZJR3/UmBW/zhDMf8mLSH/MEkv/wsSC/8NEAz/\nKjUm/w8cEP8rNSf/ICsZ/ygyKv8aIRv/HSMf/1hmX/8UHxf/dIFq/xMXE/+Hhoz/EBcQ/1FW\nUv8NFg3/QEc+/0ZMRf8NEwz/DhUO/0dqR/9QV1X/Iycl/zw9Qf8KCwX/DxwQ/3WIe/8RFRH/\npqK0/1WBWP9Da0T/LDQt/xEVE/8VFxX/Ojg+/2lpaP8yQS//GiAZ/w0WDf8KEQr/W2pg/xIV\nEv+ytcj/amly/56aqv9ESEr/GBYV/7O50/9cbF//LDIp/wsTCv8LEAj/VGBU/z5DP/8ZIBv/\nSklM/054Uv9UgVr/Wn5f/w4SCv9PY1L/RkVB/woRCP8XGxb/QFM+/1qSX/8TGxX/CxML/09Z\nT/89R07/OzxA/1BlTP9viG//KjEm/0hbUv+CjX7/OkM2/1VrV/8ZHxz/HB0f/0JDRv9LV0n/\nP0ND/xAUD/8PEAz/TXhQ/5Clm/8vRyr/j5aY/0RITP92nYT/lLmt/2iQav9Vgl7/Z2Rq/16A\nZf8QFBD/o7LB/1hxXP9NXUn/Y2Ni/zU3Ov8QEhD/qrOu/xEWEv8SHRP/lLmt/1hgbP+EnIn/\nYIVl/0JGT/9QTlH/ERQR/2+Mc/8VIBX/OEA2/1NkVP8QGhL/S2NH/wwQCv8XIxn/HR0e/1dT\ndf8kKSP/aJhw/ycrLv8jLSz/aqFs/yw0K/9Ve1b/urjU/w0bD/+zsLr/DhkO/xIZDf8QGRH/\nSUhN/w8YDv9dX1//DBMM/6Grs/9oaHj/CQ8K/zRHMf9sg2//Iyoj/zc8OP8QHxP/VVFZ/015\nUf9Zd1X/FCIX/0p7U/8OEw//HB8e/zo/Rf9LUFP/uavO/yYrHv9jZ2r/ERUW/7m/zv8sRCz/\nUldd/zM2Mf9FUkT/VJBY/0xOV/+CsIz/DBAK/2F2aP8hJyz/Iy0f/zU9L/8bICH/VYZZ/4SA\njP8kKSf/FhoW/xoeHf8bHh//JSwa/ycmL/85QDn/YFhd/1ODWv8hKB7/Z3pw/219a/9XXFr/\nPEVC/2CBYv9PTVT/R1BT/22eff+NnKD/KTIo/0pWSv9Telf/W2hg/2VjZv8RGhP/cWyA/0pI\nTP9SYlX/NDst/0lMTf8lKyL/T19P/xsfHv9ffGH/UIJY/xMXFv9do2H/lI+Q/0NGRv8RFhL/\nEx8U/w0UDf8MFwz/kpWS/2Zqav8zOy7/RmtI/0VqR/8SHBT/NDU8/zQ+M/9VgVj/REM//zI6\nM/8IDQf/DBAM/zE3Mf8LEw3/ExYU/xIiFP8PFA//FRgV/zM2Nv9BRUT/Fxwa/xATD/9FSEn/\nICYg/xIaFf9/fYP/ZoZu/1B2Vv9Wb1j/TExL/zdAN/9ddl7/OTxA/4upkP9ZjF//FBMS/42b\nkv8jJiL/Iiso/wkPCf8hJSL/dHeC/w8cEf8xNTP/Iikf/xggHP8UIxf/CxUJ/xAaEv9nbXP/\noKyr/ygvK/8NFQ//DxoR/xMfE/92iJX/FBkW/xUYF/9HSVP/V1ZW/7m2w/85UjP/Y4Fk/1p9\nYP8OFQ//mbSt/1OAWv8UGxX/DhYN/woPCv8TGBT/DhYP/1eTXf8jJyf/S21M/yw1KP9BUUP/\nLzIx/xUkF/9HSE3/ZnKB/yIjIf8lKir/WFlZ/wwQDf8WGhb/Gh4a/1V1Vv98cnf/P0JE/0A+\nQP+eqbH/XVhZ/1JUW/8LDgv/TExN/xUhGf8VGRb/JSgp/7qws/88PT7/WVBb/xETD/9DSDz/\neIh8/w4UEP8zOjT/UVJV/zlAOv9FZ0b/Iikl/6y5yP9PdVL/EBsS/3aVgP8+U0D/eHuT/4OC\nj/9ag2H/NDU2/0FERv8oKyX/JTQi/0NBP/86Qjn/HiUc/xcaGf9NaEv/DhsQ/y45Lf+ChpT/\nmqKs/6+7yv8QFxL/KCou/2qDaf8PGRH/EBgR/0JNQf8TFhX/dniK/0tPSv9MVlX/QGxA/ygu\nKP9iX2T/goGJ/0tOWv9CO0P/SFFJ/0NEQ/8tNib/LEAn/w0TCf+5wM//JjMg/1N2Vv8zNjv/\npLS3/0dIRv8PGxL/HigX/xQaF/8NGg7/ER4U/yAlJf8+cEL/KTMj/zpEPf9PZFH/DRcO/2ad\naf8mMyL/ExgQ/w4XD/8hJST/FBkV/xAYDv+anJz/Iy4m/yg0Jv8HDAf/LDEx/x0hHf9FUEf/\nkpSY/wwQDf8iLBv/Gh0b/xgdGv8QEg//Ki4u/0FiPv88P0X/WGJt/ywzK/8XGxb/DRkN/3KR\ndP9ldG//DhIJ/1RkXP8bJhb/NT8y/xMYE/+ks7L/ExgT/yAmHf8MEg3/EBwS/yMuHv8QHBH/\nRVBG/wsRDf8PFA7/fHl//xofG/8fHyL/DhYO/xAbEP9Kb0//DhUO/zk9Pv9IUFv/amlx/05Q\nTf8QGBH/Ki0v/xsoF/95nYP/paKz/091UP8oLSz/YWtm/ygwJv8NHA//LDEy/zU4Nv9rZGn/\na4Ru/ywwLv8SFBH/YmFh/w8cEf8nJyn/DhAO/w0YDf8PGBH/SEZH/yImIP81OTX/UHJV/1Nu\nWv8uNCv/NUEz/293gf9NW07/EBkR/xwiHf8RGRP/DRUO/1mUWP8QHhH/Ki4o/x8iIf8wSS//\ndp6B/yMlKv+eqbH/SHhT/1iIYP8sLin/EhQU/yAlIf8ODwz/ExgO/3CGd/9klWv/CxcL/4Ck\ngv8OFA//DRIN/1mIYv97nXv/KCwt/xEVE/8RHxL/cnKE/xwiHf8OHBD/Qk5D/5SQnv8jMB3/\nLTck/1mRXP9jcF7/Q0hF/1BNT/9ze3r/Nzs4/y4vMP8RHRP/FRkW/yIlKP9uc3D/ND4w/wwQ\nDP8WGRf/WllX/2qOdv+Xlan/dJuC/xIVFP8ZIhv/mJie/w8UD/8dHR7/DRMN/66xwP8ZHBb/\nVnJT/xgkG/8TFBH/sa25/yIlH/8QFxL/OEY5/1h3WP8gIyH/OkBG/yYuLv9xc4D/j7Gm/wwT\nDP9ablv/FRwW/5Gyo/87PEH/TEVV/wwaDv9ih17/k7Ch/3mQff+ZoKz/Mjc7/0VKVv8ZHBr/\nPDw4/xEUEf8+RT7/UFpX/3t5jf89QUD/rbm8/06AVf8MFw3/ZoRm/0VOR/8VExP/HCAf/w4V\nD/9ZcFn/aH1r/xwlG/8lKCn/YIBm/0xWVP8zOjP/IiYl/wwaD/8NFA3/GCca/w8ZEf8LFQz/\nRUdM/yktLf8QHBH/CxkL/yUpK/8SGRT/PUJA/1JWTf8OFw//tbK3/w0RDf9cWmH/FCEV/wwU\nDf8PFxD/FyAd/22Pa/8yRi7/FSEX/0RFSv9NbE3/WXxa/56rq/9LaEz/JSYs/5y5sP93h3n/\nt7vJ/ygqMf8/Sj3/IzIf/xMVFP8cHiH/DxsQ/w0aD/9gXGD/FSMZ/xAcEP87Pzr/DhMP/1mV\nZP9PSVD/Zmt2/4qbkf9SaVz/DxgO/6avtf99goH/DhkR/2Z1av9udoP/MDA2/1RjV/9AdkL/\nSE5R/6G2rf8pLCP/oKe4/4qNlP8bHh7/DRMO/15YYv9EbUP/naSg/05JRP9JTGD/nLm5/xQa\nFP9agGL/V31a/2CBXf9qmHX/FBkU/0dMSf+ot8H/HiIi/xMYFP8PGBH/DhsQ/x4oIP8iJCX/\nVFlY/zk9Rv+Fh4H/jYmL/xAbEf9GRkf/FB8T/1B8Wf8HCwf/fnyQ/7i21/9VcFD/LjIs/w4W\nEP8OEw//HyIh/3Z/ff8QExL/Nkwz/yMjJ/8wMC//jYyb/4iLmP8xODH/amt2/xEZE/8PHBD/\nh4GF/0lRSv9NfFf/ISgh/2eKcv89c0X/U2JR/0VHSv9cfFz/hIGG/zc9OP8hJif/dp6B/3KZ\nev9ohWz/jKqZ/3ighv9IUkn/ZINo/yYzIv+IkI3/CxQM/zg9RP9idWL/Pj1D/wwQDP+Kj4z/\nl5qh/5ukov+FgYL/kZKV/7Kuvf94d37/DxwQ/xodGP8vNi3/GCMV/1dsWv9/fHr/PGE7/0xI\nTv9ASkH/c4t2/0VVRf8KEQr/PEE5/3V5g/8ZJh3/SFJF/73Cz/8RHBL/Y3Fc/yksL/8QFBP/\ngISR/xIUE/9PSlb/FBkY/1teWf8XGxf/Cw8K/w4VDP8sLin/oJyp/xIWE/8UFxb/aYty/xQX\nFf8QHRL/Z3hu/56bqv8VGBf/DBAJ/4aDgf9ZcFf/FBsS/xwgIf82Ozv/mKKm/6ymuv8cHib/\nJzEk/xUaFf8QFBD/Lj4x/2ppeP8QGhL/Cw0I/3N5bf90gWr/Ymdw/05QVf9OY1j/WmlW/w0P\nC/8uMjL/ub3J/355gf+lpq7/HysX/0piSf9FRkH/SFlH/1thX/8MEw3/LTMu/ykvLf8MEgz/\nFBga/w8TEP8ZIRf/FRgX/z8/OP8JDwj/MDQs/w0VD/87PDn/DBAK/wsQC/8gJSD/DxIP/7y1\ny/+Al4f/enl3/xESDv9KbU//VI9X/w4ZD/9ofmn/DRgO/1WLV/84Rjv/HSEg/w0WDv8QHRH/\nQkVK/xQfF/8NFhD/ChYK/0ByRv+bnqL/io6L/1FfUv9lYmP/FxoY/w4SD/9FSlX/d5t6/zQ1\nMv9XX2L/DxMO/1uLY/9NTUz/DREN/5ONkf80ODf/d5t0/z1NR/9wcHP/ZGRv/xEVE/84ODr/\nLC4s/xUYGv8bHRr/lJOe/6qwu/8WGxj/dHR0/w4TD/8MFQv/DxkQ/xgnGv9ff2L/DBoN/1NP\nVP8TGBX/am1z/w8XEP9Ye1n/PT85/y8yMP+Pppj/iYSG/yUsIf9sb3X/DxkO/xcjGv8UGRb/\nFRwP/ylEKf8yTi7/CxQL/xEVD/8KEAj/DBkN/xkfHf9Oflb/Yoxi/w4SDP9BREL/Wl5O/zU/\nNP9GRUT/DxUQ/1+nY/+MjIf/hpOY/0ZuR/91iHv/KDMj/0FIT/8OFQ//aGhy/2mCa/8MEQz/\nDhwQ/2Vref9BSkH/JCYm/05jU/9JUkr/ICga/358kP9BR0v/kZGT/w4VDP9he1z/KC0q/2tp\ndv9PWF7/qqW9/3mfhP9almL/Uopg/3KDcv9McE7/iJCN/xweHf8uNSj/Jzku/1VtWP8+Q0D/\nmK6k/yo3Kf92nYT/ICEh/5agpP+Psab/aH1y/xAVD/8QFRL/IDEd/311fv8ZHBX/eJZ//3t5\njf8NFQ//rbm8/3ebev9Kdk7/UEhX/xUYF/+QlZr/Zn9n/2lmZ/9UalT/Oz08/2CIY/9Xfl//\ng5mc/w0SDv+dpKD/TFNQ/0VMRf9CR0z/a4Ju/wwXC/9uaX7/LTQw/yQwKP8OFQ//XXRg/w8S\nD/93l4r/U31V/w8SDv8PGBH/HiEf/zw8PP8OGw7/DBUL/zQ3MP8kKyL/iISJ/116XP8/O0D/\nQVI//z5lQv8TGBL/DhcP/w4RDv8UFhX/ICgc/z06P/9if1//k5qU/wYJBP8RFAv/XGdV/1md\nXv8sMy//Iich/yI1Hv8LEgn/YGVo/2+NeP9liGr/X31f/42Qjf+ApIL/U1lW/xAYEf8oLiv/\nOz0y/xMaE/9Ba0L/PUNK/zlJO/87O0X/iJCN/zM9Lv9haXD/ICUj/z9fQ/8MFw3/FSIY/zY5\nNv9ehWH/MDsx/wwYD/9UUVf/KCor/xAYEv+Jq57/ODo3/5Cinf9kZmH/YoZh/1d5W/9WhF3/\nZGNq/y87Mf+bn7L/THtT/0hOU/8YHxf/m8K1/xgZFv8MGAz/WHFc/wsPCv8kKCT/DxIQ/xsf\nHf9GVEb/DhQP/w4RDf84PD3/IScV/w0aD/8lJyT/DhsR/yAlJP90iHf/fJ2M/2uRdv9IVUr/\n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\nrD+9xrdAhnLsQIPdhD+7m6xAwa0AQQwf5T92bL9AHHylQN7IXkAwL5VAYM3fQIAOVUBslbdA\n/Km4QG8Soz/11rdAXlcBQQlQZUAArpNAy4TBQN7IdkA6BpFAjiMaQDvfF0DsUcxAA0P1QNfA\nYkDtKotAaryyQG5Mdz+3RaZAK97nQPCnlj90QbBAlgnOQG6Gaz+vmaVAPzWzQDemuz9sQ6dA\n3Ea7P6A3uT+uR7lA2xYLQGACc0C7m5hASrXPPxtMF0BtOdRA91joQGE3hUBtOZBA2UIoP8xF\nbkDsUYBAN/0nQDFCkD9slbNA0FABQaBsi0D2KIRAm8mPPzgtQkCADnVAP8aoQF9eckAAAKBA\nnKKmQB+idUC9xsNARbuDQAX6bkA/451ANlmSQKA3uT/9grxAhubyQP7xkj9/arBAoaHvQP7U\ncEA9uJ5Aje6FQN9sZ0D6fnpATfg9QLnCdUBzuolAgJo8QAlQfUCwIJxASl5NP4rlcECu9cRA\nX9KFQBMneUByFolAKH4EQFndfEBrYG1A0A+PP8NHiUBiEHhAjC2QP7vtZECsHKZAMj3yQIPd\nhD8z4apAqaTlQAIrhz+696tALILHQDfDpT90QbhACyS2QDsZhD87jatAZce6QBB1oz/zq7RA\nGjSlQCvByj81XsJA7nePQAJIwT+0yMJAu9WCQMjvf0BwmWlASgwyP3WTqD/xgLVAv2C7P/z7\niUB15YBAoE+gPxYTYz+/8a5AqBi+QLqDoD+xxLRAvTqLP4czgz8uBKZAcQMBQZbnW0DufL9A\nZogGQR7+XEAyWrhAr87eQPypWUBt57tAkrO0QNLGY0D4padA1lbSQBghSEBdFnlAlIehQDvf\nZ0D4pZNAnZ2sQFqBXUC3RbJAKroCQSApXEDyJJJAlj7OQN9sZ0As2Z5A0cvMQFWHZkAwL51A\nxha2QKA3aUB4l55AlPauQIwQcEDxgIlAflJPQLnCfUB3vpNAsAOzP3qNf0CwcpRAIF5vPw/R\nckD7BWlAZjHBPyMtgkBtOYBAYf3DP9LGc0A5YshA/3hvQDV7pD9w66lAoUpdPyl5yT/xgL1A\nTFT9QL0YXEAvi9BAb2SxQJeLXEC2oZVA5wDWQHnpZkDso6BA5+PLQHqNX0B87YBAf/Z/QIGV\nY0AxCIBAie9gQDeJaUC0yJpAOnqrQD81dkC9xotA3dIGQP1NekBbCGxASnujP+LMhEBvZINA\n+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"}]},"context":{"shiny":false,"rmarkdown":null},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, textureColor.a);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n#endif\n \n#endif\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<script type="application/htmlwidget-sizing" data-for="rgl96104">{"viewer":{"width":450,"height":350,"padding":15,"fill":true},"browser":{"width":960,"height":500,"padding":40,"fill":false}}</script>
</body>
</html>
